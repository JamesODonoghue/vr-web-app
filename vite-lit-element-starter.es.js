var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
const p$1 = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p$1();
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const isCEPolyfill = typeof window !== "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0;
const removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n2 = start.nextSibling;
    container.removeChild(start);
    start = n2;
  }
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
const nodeMarker = `<!--${marker}-->`;
const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
const boundAttributeSuffix = "$lit$";
class Template {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    const nodesToRemove = [];
    const stack = [];
    const walker = document.createTreeWalker(element.content, 133, null, false);
    let lastPartIndex = 0;
    let index = -1;
    let partIndex = 0;
    const { strings, values: { length } } = result;
    while (partIndex < length) {
      const node = walker.nextNode();
      if (node === null) {
        walker.currentNode = stack.pop();
        continue;
      }
      index++;
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attributes = node.attributes;
          const { length: length2 } = attributes;
          let count = 0;
          for (let i2 = 0; i2 < length2; i2++) {
            if (endsWith(attributes[i2].name, boundAttributeSuffix)) {
              count++;
            }
          }
          while (count-- > 0) {
            const stringForPart = strings[partIndex];
            const name = lastAttributeNameRegex.exec(stringForPart)[2];
            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
            const attributeValue = node.getAttribute(attributeLookupName);
            node.removeAttribute(attributeLookupName);
            const statics = attributeValue.split(markerRegex);
            this.parts.push({ type: "attribute", index, name, strings: statics });
            partIndex += statics.length - 1;
          }
        }
        if (node.tagName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
      } else if (node.nodeType === 3) {
        const data = node.data;
        if (data.indexOf(marker) >= 0) {
          const parent = node.parentNode;
          const strings2 = data.split(markerRegex);
          const lastIndex = strings2.length - 1;
          for (let i2 = 0; i2 < lastIndex; i2++) {
            let insert;
            let s2 = strings2[i2];
            if (s2 === "") {
              insert = createMarker();
            } else {
              const match = lastAttributeNameRegex.exec(s2);
              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                s2 = s2.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
              }
              insert = document.createTextNode(s2);
            }
            parent.insertBefore(insert, node);
            this.parts.push({ type: "node", index: ++index });
          }
          if (strings2[lastIndex] === "") {
            parent.insertBefore(createMarker(), node);
            nodesToRemove.push(node);
          } else {
            node.data = strings2[lastIndex];
          }
          partIndex += lastIndex;
        }
      } else if (node.nodeType === 8) {
        if (node.data === marker) {
          const parent = node.parentNode;
          if (node.previousSibling === null || index === lastPartIndex) {
            index++;
            parent.insertBefore(createMarker(), node);
          }
          lastPartIndex = index;
          this.parts.push({ type: "node", index });
          if (node.nextSibling === null) {
            node.data = "";
          } else {
            nodesToRemove.push(node);
            index--;
          }
          partIndex++;
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker, i2 + 1)) !== -1) {
            this.parts.push({ type: "node", index: -1 });
            partIndex++;
          }
        }
      }
    }
    for (const n2 of nodesToRemove) {
      n2.parentNode.removeChild(n2);
    }
  }
}
const endsWith = (str, suffix) => {
  const index = str.length - suffix.length;
  return index >= 0 && str.slice(index) === suffix;
};
const isTemplatePartActive = (part) => part.index !== -1;
const createMarker = () => document.createComment("");
const lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const walkerNodeFilter = 133;
function removeNodesFromTemplate(template, nodesToRemove) {
  const { element: { content }, parts: parts2 } = template;
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let part = parts2[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;
  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode;
    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    }
    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node);
      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    }
    if (currentRemovingNode !== null) {
      removeCount++;
    }
    while (part !== void 0 && part.index === nodeIndex) {
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
      part = parts2[partIndex];
    }
  }
  nodesToRemoveInTemplate.forEach((n2) => n2.parentNode.removeChild(n2));
}
const countNodes = (node) => {
  let count = node.nodeType === 11 ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
  while (walker.nextNode()) {
    count++;
  }
  return count;
};
const nextActiveIndexInTemplateParts = (parts2, startIndex = -1) => {
  for (let i2 = startIndex + 1; i2 < parts2.length; i2++) {
    const part = parts2[i2];
    if (isTemplatePartActive(part)) {
      return i2;
    }
  }
  return -1;
};
function insertNodeIntoTemplate(template, node, refNode = null) {
  const { element: { content }, parts: parts2 } = template;
  if (refNode === null || refNode === void 0) {
    content.appendChild(node);
    return;
  }
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let insertCount = 0;
  let walkerIndex = -1;
  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;
    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }
    while (partIndex !== -1 && parts2[partIndex].index === walkerIndex) {
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts2[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
        }
        return;
      }
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
    }
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const directives = /* @__PURE__ */ new WeakMap();
const isDirective = (o2) => {
  return typeof o2 === "function" && directives.has(o2);
};
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const noChange = {};
const nothing = {};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class TemplateInstance {
  constructor(template, processor, options) {
    this.__parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options;
  }
  update(values) {
    let i2 = 0;
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.setValue(values[i2]);
      }
      i2++;
    }
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.commit();
      }
    }
  }
  _clone() {
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts2 = this.template.parts;
    const walker = document.createTreeWalker(fragment, 133, null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode();
    while (partIndex < parts2.length) {
      part = parts2[partIndex];
      if (!isTemplatePartActive(part)) {
        this.__parts.push(void 0);
        partIndex++;
        continue;
      }
      while (nodeIndex < part.index) {
        nodeIndex++;
        if (node.nodeName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
        if ((node = walker.nextNode()) === null) {
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      }
      if (part.type === "node") {
        const part2 = this.processor.handleTextExpression(this.options);
        part2.insertAfterNode(node.previousSibling);
        this.__parts.push(part2);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }
      partIndex++;
    }
    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }
    return fragment;
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const policy = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: (s2) => s2 });
const commentMarker = ` ${marker} `;
class TemplateResult {
  constructor(strings, values, type, processor) {
    this.strings = strings;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  getHTML() {
    const l2 = this.strings.length - 1;
    let html2 = "";
    let isCommentBinding = false;
    for (let i2 = 0; i2 < l2; i2++) {
      const s2 = this.strings[i2];
      const commentOpen = s2.lastIndexOf("<!--");
      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s2.indexOf("-->", commentOpen + 1) === -1;
      const attributeMatch = lastAttributeNameRegex.exec(s2);
      if (attributeMatch === null) {
        html2 += s2 + (isCommentBinding ? commentMarker : nodeMarker);
      } else {
        html2 += s2.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
      }
    }
    html2 += this.strings[l2];
    return html2;
  }
  getTemplateElement() {
    const template = document.createElement("template");
    let value = this.getHTML();
    if (policy !== void 0) {
      value = policy.createHTML(value);
    }
    template.innerHTML = value;
    return template;
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const isPrimitive = (value) => {
  return value === null || !(typeof value === "object" || typeof value === "function");
};
const isIterable = (value) => {
  return Array.isArray(value) || !!(value && value[Symbol.iterator]);
};
class AttributeCommitter {
  constructor(element, name, strings) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings;
    this.parts = [];
    for (let i2 = 0; i2 < strings.length - 1; i2++) {
      this.parts[i2] = this._createPart();
    }
  }
  _createPart() {
    return new AttributePart(this);
  }
  _getValue() {
    const strings = this.strings;
    const l2 = strings.length - 1;
    const parts2 = this.parts;
    if (l2 === 1 && strings[0] === "" && strings[1] === "") {
      const v2 = parts2[0].value;
      if (typeof v2 === "symbol") {
        return String(v2);
      }
      if (typeof v2 === "string" || !isIterable(v2)) {
        return v2;
      }
    }
    let text = "";
    for (let i2 = 0; i2 < l2; i2++) {
      text += strings[i2];
      const part = parts2[i2];
      if (part !== void 0) {
        const v2 = part.value;
        if (isPrimitive(v2) || !isIterable(v2)) {
          text += typeof v2 === "string" ? v2 : String(v2);
        } else {
          for (const t2 of v2) {
            text += typeof t2 === "string" ? t2 : String(t2);
          }
        }
      }
    }
    text += strings[l2];
    return text;
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }
}
class AttributePart {
  constructor(committer) {
    this.value = void 0;
    this.committer = committer;
  }
  setValue(value) {
    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
      this.value = value;
      if (!isDirective(value)) {
        this.committer.dirty = true;
      }
    }
  }
  commit() {
    while (isDirective(this.value)) {
      const directive = this.value;
      this.value = noChange;
      directive(this);
    }
    if (this.value === noChange) {
      return;
    }
    this.committer.commit();
  }
}
class NodePart {
  constructor(options) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.options = options;
  }
  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  appendIntoPart(part) {
    part.__insert(this.startNode = createMarker());
    part.__insert(this.endNode = createMarker());
  }
  insertAfterPart(ref) {
    ref.__insert(this.startNode = createMarker());
    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    if (this.startNode.parentNode === null) {
      return;
    }
    while (isDirective(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = noChange;
      directive(this);
    }
    const value = this.__pendingValue;
    if (value === noChange) {
      return;
    }
    if (isPrimitive(value)) {
      if (value !== this.value) {
        this.__commitText(value);
      }
    } else if (value instanceof TemplateResult) {
      this.__commitTemplateResult(value);
    } else if (value instanceof Node) {
      this.__commitNode(value);
    } else if (isIterable(value)) {
      this.__commitIterable(value);
    } else if (value === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      this.__commitText(value);
    }
  }
  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }
  __commitNode(value) {
    if (this.value === value) {
      return;
    }
    this.clear();
    this.__insert(value);
    this.value = value;
  }
  __commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? "" : value;
    const valueAsString = typeof value === "string" ? value : String(value);
    if (node === this.endNode.previousSibling && node.nodeType === 3) {
      node.data = valueAsString;
    } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }
    this.value = value;
  }
  __commitTemplateResult(value) {
    const template = this.options.templateFactory(value);
    if (this.value instanceof TemplateInstance && this.value.template === template) {
      this.value.update(value.values);
    } else {
      const instance = new TemplateInstance(template, value.processor, this.options);
      const fragment = instance._clone();
      instance.update(value.values);
      this.__commitNode(fragment);
      this.value = instance;
    }
  }
  __commitIterable(value) {
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    }
    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      itemPart = itemParts[partIndex];
      if (itemPart === void 0) {
        itemPart = new NodePart(this.options);
        itemParts.push(itemPart);
        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }
      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }
  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }
}
class BooleanAttributePart {
  constructor(element, name, strings) {
    this.value = void 0;
    this.__pendingValue = void 0;
    if (strings.length !== 2 || strings[0] !== "" || strings[1] !== "") {
      throw new Error("Boolean attributes can only contain a single expression");
    }
    this.element = element;
    this.name = name;
    this.strings = strings;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = noChange;
      directive(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const value = !!this.__pendingValue;
    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, "");
      } else {
        this.element.removeAttribute(this.name);
      }
      this.value = value;
    }
    this.__pendingValue = noChange;
  }
}
class PropertyCommitter extends AttributeCommitter {
  constructor(element, name, strings) {
    super(element, name, strings);
    this.single = strings.length === 2 && strings[0] === "" && strings[1] === "";
  }
  _createPart() {
    return new PropertyPart(this);
  }
  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }
    return super._getValue();
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element[this.name] = this._getValue();
    }
  }
}
class PropertyPart extends AttributePart {
}
let eventOptionsSupported = false;
(() => {
  try {
    const options = {
      get capture() {
        eventOptionsSupported = true;
        return false;
      }
    };
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (_e2) {
  }
})();
class EventPart {
  constructor(element, eventName, eventContext) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;
    this.__boundHandleEvent = (e2) => this.handleEvent(e2);
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = noChange;
      directive(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    this.value = newListener;
    this.__pendingValue = noChange;
  }
  handleEvent(event) {
    if (typeof this.value === "function") {
      this.value.call(this.eventContext || this.element, event);
    } else {
      this.value.handleEvent(event);
    }
  }
}
const getOptions = (o2) => o2 && (eventOptionsSupported ? { capture: o2.capture, passive: o2.passive, once: o2.once } : o2.capture);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(result.type, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    template = new Template(result, result.getTemplateElement());
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
}
const templateCaches = /* @__PURE__ */ new Map();
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const parts = /* @__PURE__ */ new WeakMap();
const render$1 = (result, container, options) => {
  let part = parts.get(container);
  if (part === void 0) {
    removeNodes(container, container.firstChild);
    parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
    part.appendInto(container);
  }
  part.setValue(result);
  part.commit();
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class DefaultTemplateProcessor {
  handleAttributeExpressions(element, name, strings, options) {
    const prefix = name[0];
    if (prefix === ".") {
      const committer2 = new PropertyCommitter(element, name.slice(1), strings);
      return committer2.parts;
    }
    if (prefix === "@") {
      return [new EventPart(element, name.slice(1), options.eventContext)];
    }
    if (prefix === "?") {
      return [new BooleanAttributePart(element, name.slice(1), strings)];
    }
    const committer = new AttributeCommitter(element, name, strings);
    return committer.parts;
  }
  handleTextExpression(options) {
    return new NodePart(options);
  }
}
const defaultTemplateProcessor = new DefaultTemplateProcessor();
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
if (typeof window !== "undefined") {
  (window["litHtmlVersions"] || (window["litHtmlVersions"] = [])).push("1.4.1");
}
const html = (strings, ...values) => new TemplateResult(strings, values, "html", defaultTemplateProcessor);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
let compatibleShadyCSSVersion = true;
if (typeof window.ShadyCSS === "undefined") {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === "undefined") {
  console.warn(`Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
const shadyTemplateFactory = (scopeName) => (result) => {
  const cacheKey = getTemplateCacheKey(result.type, scopeName);
  let templateCache = templateCaches.get(cacheKey);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(cacheKey, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    const element = result.getTemplateElement();
    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element, scopeName);
    }
    template = new Template(result, element);
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
};
const TEMPLATE_TYPES = ["html", "svg"];
const removeStylesFromLitTemplates = (scopeName) => {
  TEMPLATE_TYPES.forEach((type) => {
    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
    if (templates !== void 0) {
      templates.keyString.forEach((template) => {
        const { element: { content } } = template;
        const styles = /* @__PURE__ */ new Set();
        Array.from(content.querySelectorAll("style")).forEach((s2) => {
          styles.add(s2);
        });
        removeNodesFromTemplate(template, styles);
      });
    }
  });
};
const shadyRenderSet = /* @__PURE__ */ new Set();
const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
  shadyRenderSet.add(scopeName);
  const templateElement = !!template ? template.element : document.createElement("template");
  const styles = renderedDOM.querySelectorAll("style");
  const { length } = styles;
  if (length === 0) {
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    return;
  }
  const condensedStyle = document.createElement("style");
  for (let i2 = 0; i2 < length; i2++) {
    const style2 = styles[i2];
    style2.parentNode.removeChild(style2);
    condensedStyle.textContent += style2.textContent;
  }
  removeStylesFromLitTemplates(scopeName);
  const content = templateElement.content;
  if (!!template) {
    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
  } else {
    content.insertBefore(condensedStyle, content.firstChild);
  }
  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
  const style = content.querySelector("style");
  if (window.ShadyCSS.nativeShadow && style !== null) {
    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
  } else if (!!template) {
    content.insertBefore(condensedStyle, content.firstChild);
    const removes = /* @__PURE__ */ new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template, removes);
  }
};
const render = (result, container, options) => {
  if (!options || typeof options !== "object" || !options.scopeName) {
    throw new Error("The `scopeName` option is required.");
  }
  const scopeName = options.scopeName;
  const hasRendered = parts.has(container);
  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 && !!container.host;
  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  render$1(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
  if (firstScopeRender) {
    const part = parts.get(renderContainer);
    parts.delete(renderContainer);
    const template = part.value instanceof TemplateInstance ? part.value.template : void 0;
    prepareTemplateStyles(scopeName, renderContainer, template);
    removeNodes(container, container.firstChild);
    container.appendChild(renderContainer);
    parts.set(container, part);
  }
  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var _a$1;
window.JSCompiler_renameProperty = (prop, _obj) => prop;
const defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value ? "" : null;
      case Object:
      case Array:
        return value == null ? value : JSON.stringify(value);
    }
    return value;
  },
  fromAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value !== null;
      case Number:
        return value === null ? null : Number(value);
      case Object:
      case Array:
        return JSON.parse(value);
    }
    return value;
  }
};
const notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
const STATE_HAS_UPDATED = 1;
const STATE_UPDATE_REQUESTED = 1 << 2;
const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
const finalized = "finalized";
class UpdatingElement extends HTMLElement {
  constructor() {
    super();
    this.initialize();
  }
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this._classProperties.forEach((v2, p2) => {
      const attr = this._attributeNameForProperty(p2, v2);
      if (attr !== void 0) {
        this._attributeToPropertyMap.set(attr, p2);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  static _ensureClassProperties() {
    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
      this._classProperties = /* @__PURE__ */ new Map();
      const superProperties = Object.getPrototypeOf(this)._classProperties;
      if (superProperties !== void 0) {
        superProperties.forEach((v2, k2) => this._classProperties.set(k2, v2));
      }
    }
  }
  static createProperty(name, options = defaultPropertyDeclaration) {
    this._ensureClassProperties();
    this._classProperties.set(name, options);
    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }
    const key = typeof name === "symbol" ? Symbol() : `__${name}`;
    const descriptor = this.getPropertyDescriptor(name, key, options);
    if (descriptor !== void 0) {
      Object.defineProperty(this.prototype, name, descriptor);
    }
  }
  static getPropertyDescriptor(name, key, options) {
    return {
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name];
        this[key] = value;
        this.requestUpdateInternal(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  static getPropertyOptions(name) {
    return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
  }
  static finalize() {
    const superCtor = Object.getPrototypeOf(this);
    if (!superCtor.hasOwnProperty(finalized)) {
      superCtor.finalize();
    }
    this[finalized] = true;
    this._ensureClassProperties();
    this._attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...typeof Object.getOwnPropertySymbols === "function" ? Object.getOwnPropertySymbols(props) : []
      ];
      for (const p2 of propKeys) {
        this.createProperty(p2, props[p2]);
      }
    }
  }
  static _attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  static _valueHasChanged(value, old, hasChanged = notEqual) {
    return hasChanged(value, old);
  }
  static _propertyValueFromAttribute(value, options) {
    const type = options.type;
    const converter = options.converter || defaultConverter;
    const fromAttribute = typeof converter === "function" ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value, type) : value;
  }
  static _propertyValueToAttribute(value, options) {
    if (options.reflect === void 0) {
      return;
    }
    const type = options.type;
    const converter = options.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value, type);
  }
  initialize() {
    this._updateState = 0;
    this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);
    this._changedProperties = /* @__PURE__ */ new Map();
    this._saveInstanceProperties();
    this.requestUpdateInternal();
  }
  _saveInstanceProperties() {
    this.constructor._classProperties.forEach((_v2, p2) => {
      if (this.hasOwnProperty(p2)) {
        const value = this[p2];
        delete this[p2];
        if (!this._instanceProperties) {
          this._instanceProperties = /* @__PURE__ */ new Map();
        }
        this._instanceProperties.set(p2, value);
      }
    });
  }
  _applyInstanceProperties() {
    this._instanceProperties.forEach((v2, p2) => this[p2] = v2);
    this._instanceProperties = void 0;
  }
  connectedCallback() {
    this.enableUpdating();
  }
  enableUpdating() {
    if (this._enableUpdatingResolver !== void 0) {
      this._enableUpdatingResolver();
      this._enableUpdatingResolver = void 0;
    }
  }
  disconnectedCallback() {
  }
  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this._attributeToProperty(name, value);
    }
  }
  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    const ctor = this.constructor;
    const attr = ctor._attributeNameForProperty(name, options);
    if (attr !== void 0) {
      const attrValue = ctor._propertyValueToAttribute(value, options);
      if (attrValue === void 0) {
        return;
      }
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }
  _attributeToProperty(name, value) {
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }
    const ctor = this.constructor;
    const propName = ctor._attributeToPropertyMap.get(name);
    if (propName !== void 0) {
      const options = ctor.getPropertyOptions(propName);
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = ctor._propertyValueFromAttribute(value, options);
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  requestUpdateInternal(name, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name !== void 0) {
      const ctor = this.constructor;
      options = options || ctor.getPropertyOptions(name);
      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        }
        if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === void 0) {
            this._reflectingProperties = /* @__PURE__ */ new Map();
          }
          this._reflectingProperties.set(name, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._updatePromise = this._enqueueUpdate();
    }
  }
  requestUpdate(name, oldValue) {
    this.requestUpdateInternal(name, oldValue);
    return this.updateComplete;
  }
  async _enqueueUpdate() {
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
    try {
      await this._updatePromise;
    } catch (e2) {
    }
    const result = this.performUpdate();
    if (result != null) {
      await result;
    }
    return !this._hasRequestedUpdate;
  }
  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }
  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  performUpdate() {
    if (!this._hasRequestedUpdate) {
      return;
    }
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }
    let shouldUpdate = false;
    const changedProperties = this._changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.update(changedProperties);
      } else {
        this._markUpdated();
      }
    } catch (e2) {
      shouldUpdate = false;
      this._markUpdated();
      throw e2;
    }
    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
    }
  }
  _markUpdated() {
    this._changedProperties = /* @__PURE__ */ new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  get updateComplete() {
    return this._getUpdateComplete();
  }
  _getUpdateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._updatePromise;
  }
  shouldUpdate(_changedProperties) {
    return true;
  }
  update(_changedProperties) {
    if (this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0) {
      this._reflectingProperties.forEach((v2, k2) => this._propertyToAttribute(k2, this[k2], v2));
      this._reflectingProperties = void 0;
    }
    this._markUpdated();
  }
  updated(_changedProperties) {
  }
  firstUpdated(_changedProperties) {
  }
}
_a$1 = finalized;
UpdatingElement[_a$1] = true;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const legacyCustomElement = (tagName, clazz) => {
  window.customElements.define(tagName, clazz);
  return clazz;
};
const standardCustomElement = (tagName, descriptor) => {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      window.customElements.define(tagName, clazz);
    }
  };
};
const customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
const constructionToken = Symbol();
class CSSResult {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
  }
  get styleSheet() {
    if (this._styleSheet === void 0) {
      if (supportsAdoptingStyleSheets) {
        this._styleSheet = new CSSStyleSheet();
        this._styleSheet.replaceSync(this.cssText);
      } else {
        this._styleSheet = null;
      }
    }
    return this._styleSheet;
  }
  toString() {
    return this.cssText;
  }
}
const unsafeCSS = (value) => {
  return new CSSResult(String(value), constructionToken);
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
(window["litElementVersions"] || (window["litElementVersions"] = [])).push("2.5.1");
const renderNotImplemented = {};
class LitElement extends UpdatingElement {
  static getStyles() {
    return this.styles;
  }
  static _getUniqueStyles() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) {
      return;
    }
    const userStyles = this.getStyles();
    if (Array.isArray(userStyles)) {
      const addStyles = (styles2, set2) => styles2.reduceRight((set3, s2) => Array.isArray(s2) ? addStyles(s2, set3) : (set3.add(s2), set3), set2);
      const set = addStyles(userStyles, /* @__PURE__ */ new Set());
      const styles = [];
      set.forEach((v2) => styles.unshift(v2));
      this._styles = styles;
    } else {
      this._styles = userStyles === void 0 ? [] : [userStyles];
    }
    this._styles = this._styles.map((s2) => {
      if (s2 instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
        const cssText = Array.prototype.slice.call(s2.cssRules).reduce((css, rule) => css + rule.cssText, "");
        return unsafeCSS(cssText);
      }
      return s2;
    });
  }
  initialize() {
    super.initialize();
    this.constructor._getUniqueStyles();
    this.renderRoot = this.createRenderRoot();
    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  createRenderRoot() {
    return this.attachShadow(this.constructor.shadowRootOptions);
  }
  adoptStyles() {
    const styles = this.constructor._styles;
    if (styles.length === 0) {
      return;
    }
    if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s2) => s2.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles.map((s2) => s2 instanceof CSSStyleSheet ? s2 : s2.styleSheet);
    } else {
      this._needsShimAdoptedStyleSheets = true;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.hasUpdated && window.ShadyCSS !== void 0) {
      window.ShadyCSS.styleElement(this);
    }
  }
  update(changedProperties) {
    const templateResult = this.render();
    super.update(changedProperties);
    if (templateResult !== renderNotImplemented) {
      this.constructor.render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
    }
    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;
      this.constructor._styles.forEach((s2) => {
        const style = document.createElement("style");
        style.textContent = s2.cssText;
        this.renderRoot.appendChild(style);
      });
    }
  }
  render() {
    return renderNotImplemented;
  }
}
LitElement["finalized"] = true;
LitElement.render = render;
LitElement.shadowRootOptions = { mode: "open" };
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const t = typeof window != "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0, e = (t2, e2, n2 = null) => {
  for (; e2 !== n2; ) {
    const n3 = e2.nextSibling;
    t2.removeChild(e2), e2 = n3;
  }
}, n = `{{lit-${String(Math.random()).slice(2)}}}`, i = `<!--${n}-->`, r = new RegExp(`${n}|${i}`);
class s {
  constructor(t2, e2) {
    this.parts = [], this.element = e2;
    const i2 = [], s2 = [], o2 = document.createTreeWalker(e2.content, 133, null, false);
    let h2 = 0, u2 = -1, d2 = 0;
    const { strings: p2, values: { length: m2 } } = t2;
    for (; d2 < m2; ) {
      const t3 = o2.nextNode();
      if (t3 !== null) {
        if (u2++, t3.nodeType === 1) {
          if (t3.hasAttributes()) {
            const e3 = t3.attributes, { length: n2 } = e3;
            let i3 = 0;
            for (let t4 = 0; t4 < n2; t4++)
              a(e3[t4].name, "$lit$") && i3++;
            for (; i3-- > 0; ) {
              const e4 = p2[d2], n3 = c.exec(e4)[2], i4 = n3.toLowerCase() + "$lit$", s3 = t3.getAttribute(i4);
              t3.removeAttribute(i4);
              const a2 = s3.split(r);
              this.parts.push({ type: "attribute", index: u2, name: n3, strings: a2 }), d2 += a2.length - 1;
            }
          }
          t3.tagName === "TEMPLATE" && (s2.push(t3), o2.currentNode = t3.content);
        } else if (t3.nodeType === 3) {
          const e3 = t3.data;
          if (e3.indexOf(n) >= 0) {
            const n2 = t3.parentNode, s3 = e3.split(r), o3 = s3.length - 1;
            for (let e4 = 0; e4 < o3; e4++) {
              let i3, r2 = s3[e4];
              if (r2 === "")
                i3 = l();
              else {
                const t4 = c.exec(r2);
                t4 !== null && a(t4[2], "$lit$") && (r2 = r2.slice(0, t4.index) + t4[1] + t4[2].slice(0, -"$lit$".length) + t4[3]), i3 = document.createTextNode(r2);
              }
              n2.insertBefore(i3, t3), this.parts.push({ type: "node", index: ++u2 });
            }
            s3[o3] === "" ? (n2.insertBefore(l(), t3), i2.push(t3)) : t3.data = s3[o3], d2 += o3;
          }
        } else if (t3.nodeType === 8)
          if (t3.data === n) {
            const e3 = t3.parentNode;
            t3.previousSibling !== null && u2 !== h2 || (u2++, e3.insertBefore(l(), t3)), h2 = u2, this.parts.push({ type: "node", index: u2 }), t3.nextSibling === null ? t3.data = "" : (i2.push(t3), u2--), d2++;
          } else {
            let e3 = -1;
            for (; (e3 = t3.data.indexOf(n, e3 + 1)) !== -1; )
              this.parts.push({ type: "node", index: -1 }), d2++;
          }
      } else
        o2.currentNode = s2.pop();
    }
    for (const t3 of i2)
      t3.parentNode.removeChild(t3);
  }
}
const a = (t2, e2) => {
  const n2 = t2.length - e2.length;
  return n2 >= 0 && t2.slice(n2) === e2;
}, o = (t2) => t2.index !== -1, l = () => document.createComment(""), c = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
function h(t2, e2) {
  const { element: { content: n2 }, parts: i2 } = t2, r2 = document.createTreeWalker(n2, 133, null, false);
  let s2 = d(i2), a2 = i2[s2], o2 = -1, l2 = 0;
  const c2 = [];
  let h2 = null;
  for (; r2.nextNode(); ) {
    o2++;
    const t3 = r2.currentNode;
    for (t3.previousSibling === h2 && (h2 = null), e2.has(t3) && (c2.push(t3), h2 === null && (h2 = t3)), h2 !== null && l2++; a2 !== void 0 && a2.index === o2; )
      a2.index = h2 !== null ? -1 : a2.index - l2, s2 = d(i2, s2), a2 = i2[s2];
  }
  c2.forEach((t3) => t3.parentNode.removeChild(t3));
}
const u = (t2) => {
  let e2 = t2.nodeType === 11 ? 0 : 1;
  const n2 = document.createTreeWalker(t2, 133, null, false);
  for (; n2.nextNode(); )
    e2++;
  return e2;
}, d = (t2, e2 = -1) => {
  for (let n2 = e2 + 1; n2 < t2.length; n2++) {
    const e3 = t2[n2];
    if (o(e3))
      return n2;
  }
  return -1;
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const p = /* @__PURE__ */ new WeakMap(), m = (t2) => typeof t2 == "function" && p.has(t2), f = {}, g = {};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class v {
  constructor(t2, e2, n2) {
    this.__parts = [], this.template = t2, this.processor = e2, this.options = n2;
  }
  update(t2) {
    let e2 = 0;
    for (const n2 of this.__parts)
      n2 !== void 0 && n2.setValue(t2[e2]), e2++;
    for (const t3 of this.__parts)
      t3 !== void 0 && t3.commit();
  }
  _clone() {
    const e2 = t ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true), n2 = [], i2 = this.template.parts, r2 = document.createTreeWalker(e2, 133, null, false);
    let s2, a2 = 0, l2 = 0, c2 = r2.nextNode();
    for (; a2 < i2.length; )
      if (s2 = i2[a2], o(s2)) {
        for (; l2 < s2.index; )
          l2++, c2.nodeName === "TEMPLATE" && (n2.push(c2), r2.currentNode = c2.content), (c2 = r2.nextNode()) === null && (r2.currentNode = n2.pop(), c2 = r2.nextNode());
        if (s2.type === "node") {
          const t2 = this.processor.handleTextExpression(this.options);
          t2.insertAfterNode(c2.previousSibling), this.__parts.push(t2);
        } else
          this.__parts.push(...this.processor.handleAttributeExpressions(c2, s2.name, s2.strings, this.options));
        a2++;
      } else
        this.__parts.push(void 0), a2++;
    return t && (document.adoptNode(e2), customElements.upgrade(e2)), e2;
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const y = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: (t2) => t2 }), x = ` ${n} `;
class b {
  constructor(t2, e2, n2, i2) {
    this.strings = t2, this.values = e2, this.type = n2, this.processor = i2;
  }
  getHTML() {
    const t2 = this.strings.length - 1;
    let e2 = "", r2 = false;
    for (let s2 = 0; s2 < t2; s2++) {
      const t3 = this.strings[s2], a2 = t3.lastIndexOf("<!--");
      r2 = (a2 > -1 || r2) && t3.indexOf("-->", a2 + 1) === -1;
      const o2 = c.exec(t3);
      e2 += o2 === null ? t3 + (r2 ? x : i) : t3.substr(0, o2.index) + o2[1] + o2[2] + "$lit$" + o2[3] + n;
    }
    return e2 += this.strings[t2], e2;
  }
  getTemplateElement() {
    const t2 = document.createElement("template");
    let e2 = this.getHTML();
    return y !== void 0 && (e2 = y.createHTML(e2)), t2.innerHTML = e2, t2;
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const w = (t2) => t2 === null || !(typeof t2 == "object" || typeof t2 == "function"), _ = (t2) => Array.isArray(t2) || !(!t2 || !t2[Symbol.iterator]);
class M {
  constructor(t2, e2, n2) {
    this.dirty = true, this.element = t2, this.name = e2, this.strings = n2, this.parts = [];
    for (let t3 = 0; t3 < n2.length - 1; t3++)
      this.parts[t3] = this._createPart();
  }
  _createPart() {
    return new S(this);
  }
  _getValue() {
    const t2 = this.strings, e2 = t2.length - 1, n2 = this.parts;
    if (e2 === 1 && t2[0] === "" && t2[1] === "") {
      const t3 = n2[0].value;
      if (typeof t3 == "symbol")
        return String(t3);
      if (typeof t3 == "string" || !_(t3))
        return t3;
    }
    let i2 = "";
    for (let r2 = 0; r2 < e2; r2++) {
      i2 += t2[r2];
      const e3 = n2[r2];
      if (e3 !== void 0) {
        const t3 = e3.value;
        if (w(t3) || !_(t3))
          i2 += typeof t3 == "string" ? t3 : String(t3);
        else
          for (const e4 of t3)
            i2 += typeof e4 == "string" ? e4 : String(e4);
      }
    }
    return i2 += t2[e2], i2;
  }
  commit() {
    this.dirty && (this.dirty = false, this.element.setAttribute(this.name, this._getValue()));
  }
}
class S {
  constructor(t2) {
    this.value = void 0, this.committer = t2;
  }
  setValue(t2) {
    t2 === f || w(t2) && t2 === this.value || (this.value = t2, m(t2) || (this.committer.dirty = true));
  }
  commit() {
    for (; m(this.value); ) {
      const t2 = this.value;
      this.value = f, t2(this);
    }
    this.value !== f && this.committer.commit();
  }
}
class T {
  constructor(t2) {
    this.value = void 0, this.__pendingValue = void 0, this.options = t2;
  }
  appendInto(t2) {
    this.startNode = t2.appendChild(l()), this.endNode = t2.appendChild(l());
  }
  insertAfterNode(t2) {
    this.startNode = t2, this.endNode = t2.nextSibling;
  }
  appendIntoPart(t2) {
    t2.__insert(this.startNode = l()), t2.__insert(this.endNode = l());
  }
  insertAfterPart(t2) {
    t2.__insert(this.startNode = l()), this.endNode = t2.endNode, t2.endNode = this.startNode;
  }
  setValue(t2) {
    this.__pendingValue = t2;
  }
  commit() {
    if (this.startNode.parentNode === null)
      return;
    for (; m(this.__pendingValue); ) {
      const t3 = this.__pendingValue;
      this.__pendingValue = f, t3(this);
    }
    const t2 = this.__pendingValue;
    t2 !== f && (w(t2) ? t2 !== this.value && this.__commitText(t2) : t2 instanceof b ? this.__commitTemplateResult(t2) : t2 instanceof Node ? this.__commitNode(t2) : _(t2) ? this.__commitIterable(t2) : t2 === g ? (this.value = g, this.clear()) : this.__commitText(t2));
  }
  __insert(t2) {
    this.endNode.parentNode.insertBefore(t2, this.endNode);
  }
  __commitNode(t2) {
    this.value !== t2 && (this.clear(), this.__insert(t2), this.value = t2);
  }
  __commitText(t2) {
    const e2 = this.startNode.nextSibling, n2 = typeof (t2 = t2 == null ? "" : t2) == "string" ? t2 : String(t2);
    e2 === this.endNode.previousSibling && e2.nodeType === 3 ? e2.data = n2 : this.__commitNode(document.createTextNode(n2)), this.value = t2;
  }
  __commitTemplateResult(t2) {
    const e2 = this.options.templateFactory(t2);
    if (this.value instanceof v && this.value.template === e2)
      this.value.update(t2.values);
    else {
      const n2 = new v(e2, t2.processor, this.options), i2 = n2._clone();
      n2.update(t2.values), this.__commitNode(i2), this.value = n2;
    }
  }
  __commitIterable(t2) {
    Array.isArray(this.value) || (this.value = [], this.clear());
    const e2 = this.value;
    let n2, i2 = 0;
    for (const r2 of t2)
      n2 = e2[i2], n2 === void 0 && (n2 = new T(this.options), e2.push(n2), i2 === 0 ? n2.appendIntoPart(this) : n2.insertAfterPart(e2[i2 - 1])), n2.setValue(r2), n2.commit(), i2++;
    i2 < e2.length && (e2.length = i2, this.clear(n2 && n2.endNode));
  }
  clear(t2 = this.startNode) {
    e(this.startNode.parentNode, t2.nextSibling, this.endNode);
  }
}
class E {
  constructor(t2, e2, n2) {
    if (this.value = void 0, this.__pendingValue = void 0, n2.length !== 2 || n2[0] !== "" || n2[1] !== "")
      throw new Error("Boolean attributes can only contain a single expression");
    this.element = t2, this.name = e2, this.strings = n2;
  }
  setValue(t2) {
    this.__pendingValue = t2;
  }
  commit() {
    for (; m(this.__pendingValue); ) {
      const t3 = this.__pendingValue;
      this.__pendingValue = f, t3(this);
    }
    if (this.__pendingValue === f)
      return;
    const t2 = !!this.__pendingValue;
    this.value !== t2 && (t2 ? this.element.setAttribute(this.name, "") : this.element.removeAttribute(this.name), this.value = t2), this.__pendingValue = f;
  }
}
class A extends M {
  constructor(t2, e2, n2) {
    super(t2, e2, n2), this.single = n2.length === 2 && n2[0] === "" && n2[1] === "";
  }
  _createPart() {
    return new R(this);
  }
  _getValue() {
    return this.single ? this.parts[0].value : super._getValue();
  }
  commit() {
    this.dirty && (this.dirty = false, this.element[this.name] = this._getValue());
  }
}
class R extends S {
}
let L = false;
(() => {
  try {
    const t2 = { get capture() {
      return L = true, false;
    } };
    window.addEventListener("test", t2, t2), window.removeEventListener("test", t2, t2);
  } catch (t2) {
  }
})();
class C {
  constructor(t2, e2, n2) {
    this.value = void 0, this.__pendingValue = void 0, this.element = t2, this.eventName = e2, this.eventContext = n2, this.__boundHandleEvent = (t3) => this.handleEvent(t3);
  }
  setValue(t2) {
    this.__pendingValue = t2;
  }
  commit() {
    for (; m(this.__pendingValue); ) {
      const t3 = this.__pendingValue;
      this.__pendingValue = f, t3(this);
    }
    if (this.__pendingValue === f)
      return;
    const t2 = this.__pendingValue, e2 = this.value, n2 = t2 == null || e2 != null && (t2.capture !== e2.capture || t2.once !== e2.once || t2.passive !== e2.passive), i2 = t2 != null && (e2 == null || n2);
    n2 && this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options), i2 && (this.__options = P(t2), this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options)), this.value = t2, this.__pendingValue = f;
  }
  handleEvent(t2) {
    typeof this.value == "function" ? this.value.call(this.eventContext || this.element, t2) : this.value.handleEvent(t2);
  }
}
const P = (t2) => t2 && (L ? { capture: t2.capture, passive: t2.passive, once: t2.once } : t2.capture);
function I(t2) {
  let e2 = D.get(t2.type);
  e2 === void 0 && (e2 = { stringsArray: /* @__PURE__ */ new WeakMap(), keyString: /* @__PURE__ */ new Map() }, D.set(t2.type, e2));
  let i2 = e2.stringsArray.get(t2.strings);
  if (i2 !== void 0)
    return i2;
  const r2 = t2.strings.join(n);
  return i2 = e2.keyString.get(r2), i2 === void 0 && (i2 = new s(t2, t2.getTemplateElement()), e2.keyString.set(r2, i2)), e2.stringsArray.set(t2.strings, i2), i2;
}
const D = /* @__PURE__ */ new Map(), N = /* @__PURE__ */ new WeakMap(), F = (t2, n2, i2) => {
  let r2 = N.get(n2);
  r2 === void 0 && (e(n2, n2.firstChild), N.set(n2, r2 = new T(Object.assign({ templateFactory: I }, i2))), r2.appendInto(n2)), r2.setValue(t2), r2.commit();
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const O = new class {
  handleAttributeExpressions(t2, e2, n2, i2) {
    const r2 = e2[0];
    if (r2 === ".") {
      return new A(t2, e2.slice(1), n2).parts;
    }
    if (r2 === "@")
      return [new C(t2, e2.slice(1), i2.eventContext)];
    if (r2 === "?")
      return [new E(t2, e2.slice(1), n2)];
    return new M(t2, e2, n2).parts;
  }
  handleTextExpression(t2) {
    return new T(t2);
  }
}();
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
typeof window != "undefined" && (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.4.1");
const U = (t2, ...e2) => new b(t2, e2, "html", O), k = (t2, e2) => `${t2}--${e2}`;
let z = true;
window.ShadyCSS === void 0 ? z = false : window.ShadyCSS.prepareTemplateDom === void 0 && (console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."), z = false);
const B = (t2) => (e2) => {
  const i2 = k(e2.type, t2);
  let r2 = D.get(i2);
  r2 === void 0 && (r2 = { stringsArray: /* @__PURE__ */ new WeakMap(), keyString: /* @__PURE__ */ new Map() }, D.set(i2, r2));
  let a2 = r2.stringsArray.get(e2.strings);
  if (a2 !== void 0)
    return a2;
  const o2 = e2.strings.join(n);
  if (a2 = r2.keyString.get(o2), a2 === void 0) {
    const n2 = e2.getTemplateElement();
    z && window.ShadyCSS.prepareTemplateDom(n2, t2), a2 = new s(e2, n2), r2.keyString.set(o2, a2);
  }
  return r2.stringsArray.set(e2.strings, a2), a2;
}, H = ["html", "svg"], V = /* @__PURE__ */ new Set(), G = (t2, e2, n2) => {
  V.add(t2);
  const i2 = n2 ? n2.element : document.createElement("template"), r2 = e2.querySelectorAll("style"), { length: s2 } = r2;
  if (s2 === 0)
    return void window.ShadyCSS.prepareTemplateStyles(i2, t2);
  const a2 = document.createElement("style");
  for (let t3 = 0; t3 < s2; t3++) {
    const e3 = r2[t3];
    e3.parentNode.removeChild(e3), a2.textContent += e3.textContent;
  }
  ((t3) => {
    H.forEach((e3) => {
      const n3 = D.get(k(e3, t3));
      n3 !== void 0 && n3.keyString.forEach((t4) => {
        const { element: { content: e4 } } = t4, n4 = /* @__PURE__ */ new Set();
        Array.from(e4.querySelectorAll("style")).forEach((t5) => {
          n4.add(t5);
        }), h(t4, n4);
      });
    });
  })(t2);
  const o2 = i2.content;
  n2 ? function(t3, e3, n3 = null) {
    const { element: { content: i3 }, parts: r3 } = t3;
    if (n3 == null)
      return void i3.appendChild(e3);
    const s3 = document.createTreeWalker(i3, 133, null, false);
    let a3 = d(r3), o3 = 0, l3 = -1;
    for (; s3.nextNode(); )
      for (l3++, s3.currentNode === n3 && (o3 = u(e3), n3.parentNode.insertBefore(e3, n3)); a3 !== -1 && r3[a3].index === l3; ) {
        if (o3 > 0) {
          for (; a3 !== -1; )
            r3[a3].index += o3, a3 = d(r3, a3);
          return;
        }
        a3 = d(r3, a3);
      }
  }(n2, a2, o2.firstChild) : o2.insertBefore(a2, o2.firstChild), window.ShadyCSS.prepareTemplateStyles(i2, t2);
  const l2 = o2.querySelector("style");
  if (window.ShadyCSS.nativeShadow && l2 !== null)
    e2.insertBefore(l2.cloneNode(true), e2.firstChild);
  else if (n2) {
    o2.insertBefore(a2, o2.firstChild);
    const t3 = /* @__PURE__ */ new Set();
    t3.add(a2), h(n2, t3);
  }
};
window.JSCompiler_renameProperty = (t2, e2) => t2;
const W = { toAttribute(t2, e2) {
  switch (e2) {
    case Boolean:
      return t2 ? "" : null;
    case Object:
    case Array:
      return t2 == null ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, e2) {
  switch (e2) {
    case Boolean:
      return t2 !== null;
    case Number:
      return t2 === null ? null : Number(t2);
    case Object:
    case Array:
      return JSON.parse(t2);
  }
  return t2;
} }, j = (t2, e2) => e2 !== t2 && (e2 == e2 || t2 == t2), q = { attribute: true, type: String, converter: W, reflect: false, hasChanged: j };
class X extends HTMLElement {
  constructor() {
    super(), this.initialize();
  }
  static get observedAttributes() {
    this.finalize();
    const t2 = [];
    return this._classProperties.forEach((e2, n2) => {
      const i2 = this._attributeNameForProperty(n2, e2);
      i2 !== void 0 && (this._attributeToPropertyMap.set(i2, n2), t2.push(i2));
    }), t2;
  }
  static _ensureClassProperties() {
    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
      this._classProperties = /* @__PURE__ */ new Map();
      const t2 = Object.getPrototypeOf(this)._classProperties;
      t2 !== void 0 && t2.forEach((t3, e2) => this._classProperties.set(e2, t3));
    }
  }
  static createProperty(t2, e2 = q) {
    if (this._ensureClassProperties(), this._classProperties.set(t2, e2), e2.noAccessor || this.prototype.hasOwnProperty(t2))
      return;
    const n2 = typeof t2 == "symbol" ? Symbol() : `__${t2}`, i2 = this.getPropertyDescriptor(t2, n2, e2);
    i2 !== void 0 && Object.defineProperty(this.prototype, t2, i2);
  }
  static getPropertyDescriptor(t2, e2, n2) {
    return { get() {
      return this[e2];
    }, set(i2) {
      const r2 = this[t2];
      this[e2] = i2, this.requestUpdateInternal(t2, r2, n2);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this._classProperties && this._classProperties.get(t2) || q;
  }
  static finalize() {
    const t2 = Object.getPrototypeOf(this);
    if (t2.hasOwnProperty("finalized") || t2.finalize(), this.finalized = true, this._ensureClassProperties(), this._attributeToPropertyMap = /* @__PURE__ */ new Map(), this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const t3 = this.properties, e2 = [...Object.getOwnPropertyNames(t3), ...typeof Object.getOwnPropertySymbols == "function" ? Object.getOwnPropertySymbols(t3) : []];
      for (const n2 of e2)
        this.createProperty(n2, t3[n2]);
    }
  }
  static _attributeNameForProperty(t2, e2) {
    const n2 = e2.attribute;
    return n2 === false ? void 0 : typeof n2 == "string" ? n2 : typeof t2 == "string" ? t2.toLowerCase() : void 0;
  }
  static _valueHasChanged(t2, e2, n2 = j) {
    return n2(t2, e2);
  }
  static _propertyValueFromAttribute(t2, e2) {
    const n2 = e2.type, i2 = e2.converter || W, r2 = typeof i2 == "function" ? i2 : i2.fromAttribute;
    return r2 ? r2(t2, n2) : t2;
  }
  static _propertyValueToAttribute(t2, e2) {
    if (e2.reflect === void 0)
      return;
    const n2 = e2.type, i2 = e2.converter;
    return (i2 && i2.toAttribute || W.toAttribute)(t2, n2);
  }
  initialize() {
    this._updateState = 0, this._updatePromise = new Promise((t2) => this._enableUpdatingResolver = t2), this._changedProperties = /* @__PURE__ */ new Map(), this._saveInstanceProperties(), this.requestUpdateInternal();
  }
  _saveInstanceProperties() {
    this.constructor._classProperties.forEach((t2, e2) => {
      if (this.hasOwnProperty(e2)) {
        const t3 = this[e2];
        delete this[e2], this._instanceProperties || (this._instanceProperties = /* @__PURE__ */ new Map()), this._instanceProperties.set(e2, t3);
      }
    });
  }
  _applyInstanceProperties() {
    this._instanceProperties.forEach((t2, e2) => this[e2] = t2), this._instanceProperties = void 0;
  }
  connectedCallback() {
    this.enableUpdating();
  }
  enableUpdating() {
    this._enableUpdatingResolver !== void 0 && (this._enableUpdatingResolver(), this._enableUpdatingResolver = void 0);
  }
  disconnectedCallback() {
  }
  attributeChangedCallback(t2, e2, n2) {
    e2 !== n2 && this._attributeToProperty(t2, n2);
  }
  _propertyToAttribute(t2, e2, n2 = q) {
    const i2 = this.constructor, r2 = i2._attributeNameForProperty(t2, n2);
    if (r2 !== void 0) {
      const t3 = i2._propertyValueToAttribute(e2, n2);
      if (t3 === void 0)
        return;
      this._updateState = 8 | this._updateState, t3 == null ? this.removeAttribute(r2) : this.setAttribute(r2, t3), this._updateState = -9 & this._updateState;
    }
  }
  _attributeToProperty(t2, e2) {
    if (8 & this._updateState)
      return;
    const n2 = this.constructor, i2 = n2._attributeToPropertyMap.get(t2);
    if (i2 !== void 0) {
      const t3 = n2.getPropertyOptions(i2);
      this._updateState = 16 | this._updateState, this[i2] = n2._propertyValueFromAttribute(e2, t3), this._updateState = -17 & this._updateState;
    }
  }
  requestUpdateInternal(t2, e2, n2) {
    let i2 = true;
    if (t2 !== void 0) {
      const r2 = this.constructor;
      n2 = n2 || r2.getPropertyOptions(t2), r2._valueHasChanged(this[t2], e2, n2.hasChanged) ? (this._changedProperties.has(t2) || this._changedProperties.set(t2, e2), n2.reflect !== true || 16 & this._updateState || (this._reflectingProperties === void 0 && (this._reflectingProperties = /* @__PURE__ */ new Map()), this._reflectingProperties.set(t2, n2))) : i2 = false;
    }
    !this._hasRequestedUpdate && i2 && (this._updatePromise = this._enqueueUpdate());
  }
  requestUpdate(t2, e2) {
    return this.requestUpdateInternal(t2, e2), this.updateComplete;
  }
  async _enqueueUpdate() {
    this._updateState = 4 | this._updateState;
    try {
      await this._updatePromise;
    } catch (t3) {
    }
    const t2 = this.performUpdate();
    return t2 != null && await t2, !this._hasRequestedUpdate;
  }
  get _hasRequestedUpdate() {
    return 4 & this._updateState;
  }
  get hasUpdated() {
    return 1 & this._updateState;
  }
  performUpdate() {
    if (!this._hasRequestedUpdate)
      return;
    this._instanceProperties && this._applyInstanceProperties();
    let t2 = false;
    const e2 = this._changedProperties;
    try {
      t2 = this.shouldUpdate(e2), t2 ? this.update(e2) : this._markUpdated();
    } catch (e3) {
      throw t2 = false, this._markUpdated(), e3;
    }
    t2 && (1 & this._updateState || (this._updateState = 1 | this._updateState, this.firstUpdated(e2)), this.updated(e2));
  }
  _markUpdated() {
    this._changedProperties = /* @__PURE__ */ new Map(), this._updateState = -5 & this._updateState;
  }
  get updateComplete() {
    return this._getUpdateComplete();
  }
  _getUpdateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._updatePromise;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach((t3, e2) => this._propertyToAttribute(e2, this[e2], t3)), this._reflectingProperties = void 0), this._markUpdated();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
}
X.finalized = true;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const Y = (t2, e2) => e2.kind === "method" && e2.descriptor && !("value" in e2.descriptor) ? Object.assign(Object.assign({}, e2), { finisher(n2) {
  n2.createProperty(e2.key, t2);
} }) : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, initializer() {
  typeof e2.initializer == "function" && (this[e2.key] = e2.initializer.call(this));
}, finisher(n2) {
  n2.createProperty(e2.key, t2);
} };
function Z(t2) {
  return (e2, n2) => n2 !== void 0 ? ((t3, e3, n3) => {
    e3.constructor.createProperty(n3, t3);
  })(t2, e2, n2) : Y(t2, e2);
}
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const J = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, $ = Symbol();
class K {
  constructor(t2, e2) {
    if (e2 !== $)
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2;
  }
  get styleSheet() {
    return this._styleSheet === void 0 && (J ? (this._styleSheet = new CSSStyleSheet(), this._styleSheet.replaceSync(this.cssText)) : this._styleSheet = null), this._styleSheet;
  }
  toString() {
    return this.cssText;
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
(window.litElementVersions || (window.litElementVersions = [])).push("2.5.1");
const Q = {};
class tt extends X {
  static getStyles() {
    return this.styles;
  }
  static _getUniqueStyles() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this)))
      return;
    const t2 = this.getStyles();
    if (Array.isArray(t2)) {
      const e2 = (t3, n3) => t3.reduceRight((t4, n4) => Array.isArray(n4) ? e2(n4, t4) : (t4.add(n4), t4), n3), n2 = e2(t2, /* @__PURE__ */ new Set()), i2 = [];
      n2.forEach((t3) => i2.unshift(t3)), this._styles = i2;
    } else
      this._styles = t2 === void 0 ? [] : [t2];
    this._styles = this._styles.map((t3) => {
      if (t3 instanceof CSSStyleSheet && !J) {
        const e2 = Array.prototype.slice.call(t3.cssRules).reduce((t4, e3) => t4 + e3.cssText, "");
        return new K(String(e2), $);
      }
      return t3;
    });
  }
  initialize() {
    super.initialize(), this.constructor._getUniqueStyles(), this.renderRoot = this.createRenderRoot(), window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot && this.adoptStyles();
  }
  createRenderRoot() {
    return this.attachShadow(this.constructor.shadowRootOptions);
  }
  adoptStyles() {
    const t2 = this.constructor._styles;
    t2.length !== 0 && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow ? J ? this.renderRoot.adoptedStyleSheets = t2.map((t3) => t3 instanceof CSSStyleSheet ? t3 : t3.styleSheet) : this._needsShimAdoptedStyleSheets = true : window.ShadyCSS.ScopingShim.prepareAdoptedCssText(t2.map((t3) => t3.cssText), this.localName));
  }
  connectedCallback() {
    super.connectedCallback(), this.hasUpdated && window.ShadyCSS !== void 0 && window.ShadyCSS.styleElement(this);
  }
  update(t2) {
    const e2 = this.render();
    super.update(t2), e2 !== Q && this.constructor.render(e2, this.renderRoot, { scopeName: this.localName, eventContext: this }), this._needsShimAdoptedStyleSheets && (this._needsShimAdoptedStyleSheets = false, this.constructor._styles.forEach((t3) => {
      const e3 = document.createElement("style");
      e3.textContent = t3.cssText, this.renderRoot.appendChild(e3);
    }));
  }
  render() {
    return Q;
  }
}
tt.finalized = true, tt.render = (t2, n2, i2) => {
  if (!i2 || typeof i2 != "object" || !i2.scopeName)
    throw new Error("The `scopeName` option is required.");
  const r2 = i2.scopeName, s2 = N.has(n2), a2 = z && n2.nodeType === 11 && !!n2.host, o2 = a2 && !V.has(r2), l2 = o2 ? document.createDocumentFragment() : n2;
  if (F(t2, l2, Object.assign({ templateFactory: B(r2) }, i2)), o2) {
    const t3 = N.get(l2);
    N.delete(l2);
    const i3 = t3.value instanceof v ? t3.value.template : void 0;
    G(r2, l2, i3), e(n2, n2.firstChild), n2.appendChild(l2), N.set(n2, t3);
  }
  !s2 && a2 && window.ShadyCSS.styleElement(n2.host);
}, tt.shadowRootOptions = { mode: "open" };
class et {
  addEventListener(t2, e2) {
    this._listeners === void 0 && (this._listeners = {});
    const n2 = this._listeners;
    n2[t2] === void 0 && (n2[t2] = []), n2[t2].indexOf(e2) === -1 && n2[t2].push(e2);
  }
  hasEventListener(t2, e2) {
    if (this._listeners === void 0)
      return false;
    const n2 = this._listeners;
    return n2[t2] !== void 0 && n2[t2].indexOf(e2) !== -1;
  }
  removeEventListener(t2, e2) {
    if (this._listeners === void 0)
      return;
    const n2 = this._listeners[t2];
    if (n2 !== void 0) {
      const t3 = n2.indexOf(e2);
      t3 !== -1 && n2.splice(t3, 1);
    }
  }
  dispatchEvent(t2) {
    if (this._listeners === void 0)
      return;
    const e2 = this._listeners[t2.type];
    if (e2 !== void 0) {
      t2.target = this;
      const n2 = e2.slice(0);
      for (let e3 = 0, i2 = n2.length; e3 < i2; e3++)
        n2[e3].call(this, t2);
      t2.target = null;
    }
  }
}
const nt = [];
for (let t2 = 0; t2 < 256; t2++)
  nt[t2] = (t2 < 16 ? "0" : "") + t2.toString(16);
let it = 1234567;
const rt = Math.PI / 180, st = 180 / Math.PI;
function at() {
  const t2 = 4294967295 * Math.random() | 0, e2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0;
  return (nt[255 & t2] + nt[t2 >> 8 & 255] + nt[t2 >> 16 & 255] + nt[t2 >> 24 & 255] + "-" + nt[255 & e2] + nt[e2 >> 8 & 255] + "-" + nt[e2 >> 16 & 15 | 64] + nt[e2 >> 24 & 255] + "-" + nt[63 & n2 | 128] + nt[n2 >> 8 & 255] + "-" + nt[n2 >> 16 & 255] + nt[n2 >> 24 & 255] + nt[255 & i2] + nt[i2 >> 8 & 255] + nt[i2 >> 16 & 255] + nt[i2 >> 24 & 255]).toUpperCase();
}
function ot(t2, e2, n2) {
  return Math.max(e2, Math.min(n2, t2));
}
function lt(t2, e2) {
  return (t2 % e2 + e2) % e2;
}
function ct(t2, e2, n2) {
  return (1 - n2) * t2 + n2 * e2;
}
function ht(t2) {
  return (t2 & t2 - 1) == 0 && t2 !== 0;
}
function ut(t2) {
  return Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
}
function dt(t2) {
  return Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
}
var pt = Object.freeze({ __proto__: null, DEG2RAD: rt, RAD2DEG: st, generateUUID: at, clamp: ot, euclideanModulo: lt, mapLinear: function(t2, e2, n2, i2, r2) {
  return i2 + (t2 - e2) * (r2 - i2) / (n2 - e2);
}, inverseLerp: function(t2, e2, n2) {
  return t2 !== e2 ? (n2 - t2) / (e2 - t2) : 0;
}, lerp: ct, damp: function(t2, e2, n2, i2) {
  return ct(t2, e2, 1 - Math.exp(-n2 * i2));
}, pingpong: function(t2, e2 = 1) {
  return e2 - Math.abs(lt(t2, 2 * e2) - e2);
}, smoothstep: function(t2, e2, n2) {
  return t2 <= e2 ? 0 : t2 >= n2 ? 1 : (t2 = (t2 - e2) / (n2 - e2)) * t2 * (3 - 2 * t2);
}, smootherstep: function(t2, e2, n2) {
  return t2 <= e2 ? 0 : t2 >= n2 ? 1 : (t2 = (t2 - e2) / (n2 - e2)) * t2 * t2 * (t2 * (6 * t2 - 15) + 10);
}, randInt: function(t2, e2) {
  return t2 + Math.floor(Math.random() * (e2 - t2 + 1));
}, randFloat: function(t2, e2) {
  return t2 + Math.random() * (e2 - t2);
}, randFloatSpread: function(t2) {
  return t2 * (0.5 - Math.random());
}, seededRandom: function(t2) {
  return t2 !== void 0 && (it = t2 % 2147483647), it = 16807 * it % 2147483647, (it - 1) / 2147483646;
}, degToRad: function(t2) {
  return t2 * rt;
}, radToDeg: function(t2) {
  return t2 * st;
}, isPowerOfTwo: ht, ceilPowerOfTwo: ut, floorPowerOfTwo: dt, setQuaternionFromProperEuler: function(t2, e2, n2, i2, r2) {
  const s2 = Math.cos, a2 = Math.sin, o2 = s2(n2 / 2), l2 = a2(n2 / 2), c2 = s2((e2 + i2) / 2), h2 = a2((e2 + i2) / 2), u2 = s2((e2 - i2) / 2), d2 = a2((e2 - i2) / 2), p2 = s2((i2 - e2) / 2), m2 = a2((i2 - e2) / 2);
  switch (r2) {
    case "XYX":
      t2.set(o2 * h2, l2 * u2, l2 * d2, o2 * c2);
      break;
    case "YZY":
      t2.set(l2 * d2, o2 * h2, l2 * u2, o2 * c2);
      break;
    case "ZXZ":
      t2.set(l2 * u2, l2 * d2, o2 * h2, o2 * c2);
      break;
    case "XZX":
      t2.set(o2 * h2, l2 * m2, l2 * p2, o2 * c2);
      break;
    case "YXY":
      t2.set(l2 * p2, o2 * h2, l2 * m2, o2 * c2);
      break;
    case "ZYZ":
      t2.set(l2 * m2, l2 * p2, o2 * h2, o2 * c2);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r2);
  }
} });
class mt {
  constructor(t2 = 0, e2 = 0) {
    this.x = t2, this.y = e2;
  }
  get width() {
    return this.x;
  }
  set width(t2) {
    this.x = t2;
  }
  get height() {
    return this.y;
  }
  set height(t2) {
    this.y = t2;
  }
  set(t2, e2) {
    return this.x = t2, this.y = e2, this;
  }
  setScalar(t2) {
    return this.x = t2, this.y = t2, this;
  }
  setX(t2) {
    return this.x = t2, this;
  }
  setY(t2) {
    return this.y = t2, this;
  }
  setComponent(t2, e2) {
    switch (t2) {
      case 0:
        this.x = e2;
        break;
      case 1:
        this.y = e2;
        break;
      default:
        throw new Error("index is out of range: " + t2);
    }
    return this;
  }
  getComponent(t2) {
    switch (t2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t2) {
    return this.x = t2.x, this.y = t2.y, this;
  }
  add(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this);
  }
  addScalar(t2) {
    return this.x += t2, this.y += t2, this;
  }
  addVectors(t2, e2) {
    return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this;
  }
  addScaledVector(t2, e2) {
    return this.x += t2.x * e2, this.y += t2.y * e2, this;
  }
  sub(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this);
  }
  subScalar(t2) {
    return this.x -= t2, this.y -= t2, this;
  }
  subVectors(t2, e2) {
    return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this;
  }
  multiply(t2) {
    return this.x *= t2.x, this.y *= t2.y, this;
  }
  multiplyScalar(t2) {
    return this.x *= t2, this.y *= t2, this;
  }
  divide(t2) {
    return this.x /= t2.x, this.y /= t2.y, this;
  }
  divideScalar(t2) {
    return this.multiplyScalar(1 / t2);
  }
  applyMatrix3(t2) {
    const e2 = this.x, n2 = this.y, i2 = t2.elements;
    return this.x = i2[0] * e2 + i2[3] * n2 + i2[6], this.y = i2[1] * e2 + i2[4] * n2 + i2[7], this;
  }
  min(t2) {
    return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this;
  }
  max(t2) {
    return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this;
  }
  clamp(t2, e2) {
    return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this;
  }
  clampScalar(t2, e2) {
    return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this;
  }
  clampLength(t2, e2) {
    const n2 = this.length();
    return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t2) {
    return this.x * t2.x + this.y * t2.y;
  }
  cross(t2) {
    return this.x * t2.y - this.y * t2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(t2) {
    return Math.sqrt(this.distanceToSquared(t2));
  }
  distanceToSquared(t2) {
    const e2 = this.x - t2.x, n2 = this.y - t2.y;
    return e2 * e2 + n2 * n2;
  }
  manhattanDistanceTo(t2) {
    return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y);
  }
  setLength(t2) {
    return this.normalize().multiplyScalar(t2);
  }
  lerp(t2, e2) {
    return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this;
  }
  lerpVectors(t2, e2, n2) {
    return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this;
  }
  equals(t2) {
    return t2.x === this.x && t2.y === this.y;
  }
  fromArray(t2, e2 = 0) {
    return this.x = t2[e2], this.y = t2[e2 + 1], this;
  }
  toArray(t2 = [], e2 = 0) {
    return t2[e2] = this.x, t2[e2 + 1] = this.y, t2;
  }
  fromBufferAttribute(t2, e2, n2) {
    return n2 !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this;
  }
  rotateAround(t2, e2) {
    const n2 = Math.cos(e2), i2 = Math.sin(e2), r2 = this.x - t2.x, s2 = this.y - t2.y;
    return this.x = r2 * n2 - s2 * i2 + t2.x, this.y = r2 * i2 + s2 * n2 + t2.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
mt.prototype.isVector2 = true;
class ft {
  constructor() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  set(t2, e2, n2, i2, r2, s2, a2, o2, l2) {
    const c2 = this.elements;
    return c2[0] = t2, c2[1] = i2, c2[2] = a2, c2[3] = e2, c2[4] = r2, c2[5] = o2, c2[6] = n2, c2[7] = s2, c2[8] = l2, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t2) {
    const e2 = this.elements, n2 = t2.elements;
    return e2[0] = n2[0], e2[1] = n2[1], e2[2] = n2[2], e2[3] = n2[3], e2[4] = n2[4], e2[5] = n2[5], e2[6] = n2[6], e2[7] = n2[7], e2[8] = n2[8], this;
  }
  extractBasis(t2, e2, n2) {
    return t2.setFromMatrix3Column(this, 0), e2.setFromMatrix3Column(this, 1), n2.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t2) {
    const e2 = t2.elements;
    return this.set(e2[0], e2[4], e2[8], e2[1], e2[5], e2[9], e2[2], e2[6], e2[10]), this;
  }
  multiply(t2) {
    return this.multiplyMatrices(this, t2);
  }
  premultiply(t2) {
    return this.multiplyMatrices(t2, this);
  }
  multiplyMatrices(t2, e2) {
    const n2 = t2.elements, i2 = e2.elements, r2 = this.elements, s2 = n2[0], a2 = n2[3], o2 = n2[6], l2 = n2[1], c2 = n2[4], h2 = n2[7], u2 = n2[2], d2 = n2[5], p2 = n2[8], m2 = i2[0], f2 = i2[3], g2 = i2[6], v2 = i2[1], y2 = i2[4], x2 = i2[7], b2 = i2[2], w2 = i2[5], _2 = i2[8];
    return r2[0] = s2 * m2 + a2 * v2 + o2 * b2, r2[3] = s2 * f2 + a2 * y2 + o2 * w2, r2[6] = s2 * g2 + a2 * x2 + o2 * _2, r2[1] = l2 * m2 + c2 * v2 + h2 * b2, r2[4] = l2 * f2 + c2 * y2 + h2 * w2, r2[7] = l2 * g2 + c2 * x2 + h2 * _2, r2[2] = u2 * m2 + d2 * v2 + p2 * b2, r2[5] = u2 * f2 + d2 * y2 + p2 * w2, r2[8] = u2 * g2 + d2 * x2 + p2 * _2, this;
  }
  multiplyScalar(t2) {
    const e2 = this.elements;
    return e2[0] *= t2, e2[3] *= t2, e2[6] *= t2, e2[1] *= t2, e2[4] *= t2, e2[7] *= t2, e2[2] *= t2, e2[5] *= t2, e2[8] *= t2, this;
  }
  determinant() {
    const t2 = this.elements, e2 = t2[0], n2 = t2[1], i2 = t2[2], r2 = t2[3], s2 = t2[4], a2 = t2[5], o2 = t2[6], l2 = t2[7], c2 = t2[8];
    return e2 * s2 * c2 - e2 * a2 * l2 - n2 * r2 * c2 + n2 * a2 * o2 + i2 * r2 * l2 - i2 * s2 * o2;
  }
  invert() {
    const t2 = this.elements, e2 = t2[0], n2 = t2[1], i2 = t2[2], r2 = t2[3], s2 = t2[4], a2 = t2[5], o2 = t2[6], l2 = t2[7], c2 = t2[8], h2 = c2 * s2 - a2 * l2, u2 = a2 * o2 - c2 * r2, d2 = l2 * r2 - s2 * o2, p2 = e2 * h2 + n2 * u2 + i2 * d2;
    if (p2 === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m2 = 1 / p2;
    return t2[0] = h2 * m2, t2[1] = (i2 * l2 - c2 * n2) * m2, t2[2] = (a2 * n2 - i2 * s2) * m2, t2[3] = u2 * m2, t2[4] = (c2 * e2 - i2 * o2) * m2, t2[5] = (i2 * r2 - a2 * e2) * m2, t2[6] = d2 * m2, t2[7] = (n2 * o2 - l2 * e2) * m2, t2[8] = (s2 * e2 - n2 * r2) * m2, this;
  }
  transpose() {
    let t2;
    const e2 = this.elements;
    return t2 = e2[1], e2[1] = e2[3], e2[3] = t2, t2 = e2[2], e2[2] = e2[6], e2[6] = t2, t2 = e2[5], e2[5] = e2[7], e2[7] = t2, this;
  }
  getNormalMatrix(t2) {
    return this.setFromMatrix4(t2).invert().transpose();
  }
  transposeIntoArray(t2) {
    const e2 = this.elements;
    return t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8], this;
  }
  setUvTransform(t2, e2, n2, i2, r2, s2, a2) {
    const o2 = Math.cos(r2), l2 = Math.sin(r2);
    return this.set(n2 * o2, n2 * l2, -n2 * (o2 * s2 + l2 * a2) + s2 + t2, -i2 * l2, i2 * o2, -i2 * (-l2 * s2 + o2 * a2) + a2 + e2, 0, 0, 1), this;
  }
  scale(t2, e2) {
    const n2 = this.elements;
    return n2[0] *= t2, n2[3] *= t2, n2[6] *= t2, n2[1] *= e2, n2[4] *= e2, n2[7] *= e2, this;
  }
  rotate(t2) {
    const e2 = Math.cos(t2), n2 = Math.sin(t2), i2 = this.elements, r2 = i2[0], s2 = i2[3], a2 = i2[6], o2 = i2[1], l2 = i2[4], c2 = i2[7];
    return i2[0] = e2 * r2 + n2 * o2, i2[3] = e2 * s2 + n2 * l2, i2[6] = e2 * a2 + n2 * c2, i2[1] = -n2 * r2 + e2 * o2, i2[4] = -n2 * s2 + e2 * l2, i2[7] = -n2 * a2 + e2 * c2, this;
  }
  translate(t2, e2) {
    const n2 = this.elements;
    return n2[0] += t2 * n2[2], n2[3] += t2 * n2[5], n2[6] += t2 * n2[8], n2[1] += e2 * n2[2], n2[4] += e2 * n2[5], n2[7] += e2 * n2[8], this;
  }
  equals(t2) {
    const e2 = this.elements, n2 = t2.elements;
    for (let t3 = 0; t3 < 9; t3++)
      if (e2[t3] !== n2[t3])
        return false;
    return true;
  }
  fromArray(t2, e2 = 0) {
    for (let n2 = 0; n2 < 9; n2++)
      this.elements[n2] = t2[n2 + e2];
    return this;
  }
  toArray(t2 = [], e2 = 0) {
    const n2 = this.elements;
    return t2[e2] = n2[0], t2[e2 + 1] = n2[1], t2[e2 + 2] = n2[2], t2[e2 + 3] = n2[3], t2[e2 + 4] = n2[4], t2[e2 + 5] = n2[5], t2[e2 + 6] = n2[6], t2[e2 + 7] = n2[7], t2[e2 + 8] = n2[8], t2;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
function gt(t2) {
  if (t2.length === 0)
    return -1 / 0;
  let e2 = t2[0];
  for (let n2 = 1, i2 = t2.length; n2 < i2; ++n2)
    t2[n2] > e2 && (e2 = t2[n2]);
  return e2;
}
function vt(t2) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t2);
}
let yt;
ft.prototype.isMatrix3 = true;
class xt {
  static getDataURL(t2) {
    if (/^data:/i.test(t2.src))
      return t2.src;
    if (typeof HTMLCanvasElement == "undefined")
      return t2.src;
    let e2;
    if (t2 instanceof HTMLCanvasElement)
      e2 = t2;
    else {
      yt === void 0 && (yt = vt("canvas")), yt.width = t2.width, yt.height = t2.height;
      const n2 = yt.getContext("2d");
      t2 instanceof ImageData ? n2.putImageData(t2, 0, 0) : n2.drawImage(t2, 0, 0, t2.width, t2.height), e2 = yt;
    }
    return e2.width > 2048 || e2.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t2), e2.toDataURL("image/jpeg", 0.6)) : e2.toDataURL("image/png");
  }
}
let bt = 0;
class wt extends et {
  constructor(t2 = wt.DEFAULT_IMAGE, e2 = wt.DEFAULT_MAPPING, n2 = 1001, i2 = 1001, r2 = 1006, s2 = 1008, a2 = 1023, o2 = 1009, l2 = 1, c2 = 3e3) {
    super(), Object.defineProperty(this, "id", { value: bt++ }), this.uuid = at(), this.name = "", this.image = t2, this.mipmaps = [], this.mapping = e2, this.wrapS = n2, this.wrapT = i2, this.magFilter = r2, this.minFilter = s2, this.anisotropy = l2, this.format = a2, this.internalFormat = null, this.type = o2, this.offset = new mt(0, 0), this.repeat = new mt(1, 1), this.center = new mt(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new ft(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c2, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t2) {
    return this.name = t2.name, this.image = t2.image, this.mipmaps = t2.mipmaps.slice(0), this.mapping = t2.mapping, this.wrapS = t2.wrapS, this.wrapT = t2.wrapT, this.magFilter = t2.magFilter, this.minFilter = t2.minFilter, this.anisotropy = t2.anisotropy, this.format = t2.format, this.internalFormat = t2.internalFormat, this.type = t2.type, this.offset.copy(t2.offset), this.repeat.copy(t2.repeat), this.center.copy(t2.center), this.rotation = t2.rotation, this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrix.copy(t2.matrix), this.generateMipmaps = t2.generateMipmaps, this.premultiplyAlpha = t2.premultiplyAlpha, this.flipY = t2.flipY, this.unpackAlignment = t2.unpackAlignment, this.encoding = t2.encoding, this.userData = JSON.parse(JSON.stringify(t2.userData)), this;
  }
  toJSON(t2) {
    const e2 = t2 === void 0 || typeof t2 == "string";
    if (!e2 && t2.textures[this.uuid] !== void 0)
      return t2.textures[this.uuid];
    const n2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    if (this.image !== void 0) {
      const i2 = this.image;
      if (i2.uuid === void 0 && (i2.uuid = at()), !e2 && t2.images[i2.uuid] === void 0) {
        let e3;
        if (Array.isArray(i2)) {
          e3 = [];
          for (let t3 = 0, n3 = i2.length; t3 < n3; t3++)
            i2[t3].isDataTexture ? e3.push(_t(i2[t3].image)) : e3.push(_t(i2[t3]));
        } else
          e3 = _t(i2);
        t2.images[i2.uuid] = { uuid: i2.uuid, url: e3 };
      }
      n2.image = i2.uuid;
    }
    return JSON.stringify(this.userData) !== "{}" && (n2.userData = this.userData), e2 || (t2.textures[this.uuid] = n2), n2;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t2) {
    if (this.mapping !== 300)
      return t2;
    if (t2.applyMatrix3(this.matrix), t2.x < 0 || t2.x > 1)
      switch (this.wrapS) {
        case 1e3:
          t2.x = t2.x - Math.floor(t2.x);
          break;
        case 1001:
          t2.x = t2.x < 0 ? 0 : 1;
          break;
        case 1002:
          Math.abs(Math.floor(t2.x) % 2) === 1 ? t2.x = Math.ceil(t2.x) - t2.x : t2.x = t2.x - Math.floor(t2.x);
      }
    if (t2.y < 0 || t2.y > 1)
      switch (this.wrapT) {
        case 1e3:
          t2.y = t2.y - Math.floor(t2.y);
          break;
        case 1001:
          t2.y = t2.y < 0 ? 0 : 1;
          break;
        case 1002:
          Math.abs(Math.floor(t2.y) % 2) === 1 ? t2.y = Math.ceil(t2.y) - t2.y : t2.y = t2.y - Math.floor(t2.y);
      }
    return this.flipY && (t2.y = 1 - t2.y), t2;
  }
  set needsUpdate(t2) {
    t2 === true && this.version++;
  }
}
function _t(t2) {
  return typeof HTMLImageElement != "undefined" && t2 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t2 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t2 instanceof ImageBitmap ? xt.getDataURL(t2) : t2.data ? { data: Array.prototype.slice.call(t2.data), width: t2.width, height: t2.height, type: t2.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
wt.DEFAULT_IMAGE = void 0, wt.DEFAULT_MAPPING = 300, wt.prototype.isTexture = true;
class Mt {
  constructor(t2 = 0, e2 = 0, n2 = 0, i2 = 1) {
    this.x = t2, this.y = e2, this.z = n2, this.w = i2;
  }
  get width() {
    return this.z;
  }
  set width(t2) {
    this.z = t2;
  }
  get height() {
    return this.w;
  }
  set height(t2) {
    this.w = t2;
  }
  set(t2, e2, n2, i2) {
    return this.x = t2, this.y = e2, this.z = n2, this.w = i2, this;
  }
  setScalar(t2) {
    return this.x = t2, this.y = t2, this.z = t2, this.w = t2, this;
  }
  setX(t2) {
    return this.x = t2, this;
  }
  setY(t2) {
    return this.y = t2, this;
  }
  setZ(t2) {
    return this.z = t2, this;
  }
  setW(t2) {
    return this.w = t2, this;
  }
  setComponent(t2, e2) {
    switch (t2) {
      case 0:
        this.x = e2;
        break;
      case 1:
        this.y = e2;
        break;
      case 2:
        this.z = e2;
        break;
      case 3:
        this.w = e2;
        break;
      default:
        throw new Error("index is out of range: " + t2);
    }
    return this;
  }
  getComponent(t2) {
    switch (t2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t2) {
    return this.x = t2.x, this.y = t2.y, this.z = t2.z, this.w = t2.w !== void 0 ? t2.w : 1, this;
  }
  add(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this.w += t2.w, this);
  }
  addScalar(t2) {
    return this.x += t2, this.y += t2, this.z += t2, this.w += t2, this;
  }
  addVectors(t2, e2) {
    return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this.w = t2.w + e2.w, this;
  }
  addScaledVector(t2, e2) {
    return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this.w += t2.w * e2, this;
  }
  sub(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this.w -= t2.w, this);
  }
  subScalar(t2) {
    return this.x -= t2, this.y -= t2, this.z -= t2, this.w -= t2, this;
  }
  subVectors(t2, e2) {
    return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this.w = t2.w - e2.w, this;
  }
  multiply(t2) {
    return this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this.w *= t2.w, this;
  }
  multiplyScalar(t2) {
    return this.x *= t2, this.y *= t2, this.z *= t2, this.w *= t2, this;
  }
  applyMatrix4(t2) {
    const e2 = this.x, n2 = this.y, i2 = this.z, r2 = this.w, s2 = t2.elements;
    return this.x = s2[0] * e2 + s2[4] * n2 + s2[8] * i2 + s2[12] * r2, this.y = s2[1] * e2 + s2[5] * n2 + s2[9] * i2 + s2[13] * r2, this.z = s2[2] * e2 + s2[6] * n2 + s2[10] * i2 + s2[14] * r2, this.w = s2[3] * e2 + s2[7] * n2 + s2[11] * i2 + s2[15] * r2, this;
  }
  divideScalar(t2) {
    return this.multiplyScalar(1 / t2);
  }
  setAxisAngleFromQuaternion(t2) {
    this.w = 2 * Math.acos(t2.w);
    const e2 = Math.sqrt(1 - t2.w * t2.w);
    return e2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t2.x / e2, this.y = t2.y / e2, this.z = t2.z / e2), this;
  }
  setAxisAngleFromRotationMatrix(t2) {
    let e2, n2, i2, r2;
    const s2 = 0.01, a2 = 0.1, o2 = t2.elements, l2 = o2[0], c2 = o2[4], h2 = o2[8], u2 = o2[1], d2 = o2[5], p2 = o2[9], m2 = o2[2], f2 = o2[6], g2 = o2[10];
    if (Math.abs(c2 - u2) < s2 && Math.abs(h2 - m2) < s2 && Math.abs(p2 - f2) < s2) {
      if (Math.abs(c2 + u2) < a2 && Math.abs(h2 + m2) < a2 && Math.abs(p2 + f2) < a2 && Math.abs(l2 + d2 + g2 - 3) < a2)
        return this.set(1, 0, 0, 0), this;
      e2 = Math.PI;
      const t3 = (l2 + 1) / 2, o3 = (d2 + 1) / 2, v3 = (g2 + 1) / 2, y2 = (c2 + u2) / 4, x2 = (h2 + m2) / 4, b2 = (p2 + f2) / 4;
      return t3 > o3 && t3 > v3 ? t3 < s2 ? (n2 = 0, i2 = 0.707106781, r2 = 0.707106781) : (n2 = Math.sqrt(t3), i2 = y2 / n2, r2 = x2 / n2) : o3 > v3 ? o3 < s2 ? (n2 = 0.707106781, i2 = 0, r2 = 0.707106781) : (i2 = Math.sqrt(o3), n2 = y2 / i2, r2 = b2 / i2) : v3 < s2 ? (n2 = 0.707106781, i2 = 0.707106781, r2 = 0) : (r2 = Math.sqrt(v3), n2 = x2 / r2, i2 = b2 / r2), this.set(n2, i2, r2, e2), this;
    }
    let v2 = Math.sqrt((f2 - p2) * (f2 - p2) + (h2 - m2) * (h2 - m2) + (u2 - c2) * (u2 - c2));
    return Math.abs(v2) < 1e-3 && (v2 = 1), this.x = (f2 - p2) / v2, this.y = (h2 - m2) / v2, this.z = (u2 - c2) / v2, this.w = Math.acos((l2 + d2 + g2 - 1) / 2), this;
  }
  min(t2) {
    return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this.w = Math.min(this.w, t2.w), this;
  }
  max(t2) {
    return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this.w = Math.max(this.w, t2.w), this;
  }
  clamp(t2, e2) {
    return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this.w = Math.max(t2.w, Math.min(e2.w, this.w)), this;
  }
  clampScalar(t2, e2) {
    return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this.w = Math.max(t2, Math.min(e2, this.w)), this;
  }
  clampLength(t2, e2) {
    const n2 = this.length();
    return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t2) {
    return this.x * t2.x + this.y * t2.y + this.z * t2.z + this.w * t2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t2) {
    return this.normalize().multiplyScalar(t2);
  }
  lerp(t2, e2) {
    return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this.w += (t2.w - this.w) * e2, this;
  }
  lerpVectors(t2, e2, n2) {
    return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this.z = t2.z + (e2.z - t2.z) * n2, this.w = t2.w + (e2.w - t2.w) * n2, this;
  }
  equals(t2) {
    return t2.x === this.x && t2.y === this.y && t2.z === this.z && t2.w === this.w;
  }
  fromArray(t2, e2 = 0) {
    return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this.w = t2[e2 + 3], this;
  }
  toArray(t2 = [], e2 = 0) {
    return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2[e2 + 3] = this.w, t2;
  }
  fromBufferAttribute(t2, e2, n2) {
    return n2 !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this.w = t2.getW(e2), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
Mt.prototype.isVector4 = true;
class St extends et {
  constructor(t2, e2, n2 = {}) {
    super(), this.width = t2, this.height = e2, this.depth = 1, this.scissor = new Mt(0, 0, t2, e2), this.scissorTest = false, this.viewport = new Mt(0, 0, t2, e2), this.texture = new wt(void 0, n2.mapping, n2.wrapS, n2.wrapT, n2.magFilter, n2.minFilter, n2.format, n2.type, n2.anisotropy, n2.encoding), this.texture.isRenderTargetTexture = true, this.texture.image = { width: t2, height: e2, depth: 1 }, this.texture.generateMipmaps = n2.generateMipmaps !== void 0 && n2.generateMipmaps, this.texture.internalFormat = n2.internalFormat !== void 0 ? n2.internalFormat : null, this.texture.minFilter = n2.minFilter !== void 0 ? n2.minFilter : 1006, this.depthBuffer = n2.depthBuffer === void 0 || n2.depthBuffer, this.stencilBuffer = n2.stencilBuffer !== void 0 && n2.stencilBuffer, this.depthTexture = n2.depthTexture !== void 0 ? n2.depthTexture : null;
  }
  setTexture(t2) {
    t2.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t2;
  }
  setSize(t2, e2, n2 = 1) {
    this.width === t2 && this.height === e2 && this.depth === n2 || (this.width = t2, this.height = e2, this.depth = n2, this.texture.image.width = t2, this.texture.image.height = e2, this.texture.image.depth = n2, this.dispose()), this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t2) {
    return this.width = t2.width, this.height = t2.height, this.depth = t2.depth, this.viewport.copy(t2.viewport), this.texture = t2.texture.clone(), this.texture.image = __spreadValues({}, this.texture.image), this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
St.prototype.isWebGLRenderTarget = true;
(class extends St {
  constructor(t2, e2, n2) {
    super(t2, e2);
    const i2 = this.texture;
    this.texture = [];
    for (let t3 = 0; t3 < n2; t3++)
      this.texture[t3] = i2.clone();
  }
  setSize(t2, e2, n2 = 1) {
    if (this.width !== t2 || this.height !== e2 || this.depth !== n2) {
      this.width = t2, this.height = e2, this.depth = n2;
      for (let i2 = 0, r2 = this.texture.length; i2 < r2; i2++)
        this.texture[i2].image.width = t2, this.texture[i2].image.height = e2, this.texture[i2].image.depth = n2;
      this.dispose();
    }
    return this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2), this;
  }
  copy(t2) {
    this.dispose(), this.width = t2.width, this.height = t2.height, this.depth = t2.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this.texture.length = 0;
    for (let e2 = 0, n2 = t2.texture.length; e2 < n2; e2++)
      this.texture[e2] = t2.texture[e2].clone();
    return this;
  }
}).prototype.isWebGLMultipleRenderTargets = true;
class Tt extends St {
  constructor(t2, e2, n2 = {}) {
    super(t2, e2, n2), this.samples = 4, this.ignoreDepthForMultisampleCopy = n2.ignoreDepth === void 0 || n2.ignoreDepth, this.useRenderToTexture = n2.useRenderToTexture !== void 0 && n2.useRenderToTexture, this.useRenderbuffer = this.useRenderToTexture === false;
  }
  copy(t2) {
    return super.copy.call(this, t2), this.samples = t2.samples, this.useRenderToTexture = t2.useRenderToTexture, this.useRenderbuffer = t2.useRenderbuffer, this;
  }
}
Tt.prototype.isWebGLMultisampleRenderTarget = true;
class Et {
  constructor(t2 = 0, e2 = 0, n2 = 0, i2 = 1) {
    this._x = t2, this._y = e2, this._z = n2, this._w = i2;
  }
  static slerp(t2, e2, n2, i2) {
    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n2.slerpQuaternions(t2, e2, i2);
  }
  static slerpFlat(t2, e2, n2, i2, r2, s2, a2) {
    let o2 = n2[i2 + 0], l2 = n2[i2 + 1], c2 = n2[i2 + 2], h2 = n2[i2 + 3];
    const u2 = r2[s2 + 0], d2 = r2[s2 + 1], p2 = r2[s2 + 2], m2 = r2[s2 + 3];
    if (a2 === 0)
      return t2[e2 + 0] = o2, t2[e2 + 1] = l2, t2[e2 + 2] = c2, void (t2[e2 + 3] = h2);
    if (a2 === 1)
      return t2[e2 + 0] = u2, t2[e2 + 1] = d2, t2[e2 + 2] = p2, void (t2[e2 + 3] = m2);
    if (h2 !== m2 || o2 !== u2 || l2 !== d2 || c2 !== p2) {
      let t3 = 1 - a2;
      const e3 = o2 * u2 + l2 * d2 + c2 * p2 + h2 * m2, n3 = e3 >= 0 ? 1 : -1, i3 = 1 - e3 * e3;
      if (i3 > Number.EPSILON) {
        const r4 = Math.sqrt(i3), s3 = Math.atan2(r4, e3 * n3);
        t3 = Math.sin(t3 * s3) / r4, a2 = Math.sin(a2 * s3) / r4;
      }
      const r3 = a2 * n3;
      if (o2 = o2 * t3 + u2 * r3, l2 = l2 * t3 + d2 * r3, c2 = c2 * t3 + p2 * r3, h2 = h2 * t3 + m2 * r3, t3 === 1 - a2) {
        const t4 = 1 / Math.sqrt(o2 * o2 + l2 * l2 + c2 * c2 + h2 * h2);
        o2 *= t4, l2 *= t4, c2 *= t4, h2 *= t4;
      }
    }
    t2[e2] = o2, t2[e2 + 1] = l2, t2[e2 + 2] = c2, t2[e2 + 3] = h2;
  }
  static multiplyQuaternionsFlat(t2, e2, n2, i2, r2, s2) {
    const a2 = n2[i2], o2 = n2[i2 + 1], l2 = n2[i2 + 2], c2 = n2[i2 + 3], h2 = r2[s2], u2 = r2[s2 + 1], d2 = r2[s2 + 2], p2 = r2[s2 + 3];
    return t2[e2] = a2 * p2 + c2 * h2 + o2 * d2 - l2 * u2, t2[e2 + 1] = o2 * p2 + c2 * u2 + l2 * h2 - a2 * d2, t2[e2 + 2] = l2 * p2 + c2 * d2 + a2 * u2 - o2 * h2, t2[e2 + 3] = c2 * p2 - a2 * h2 - o2 * u2 - l2 * d2, t2;
  }
  get x() {
    return this._x;
  }
  set x(t2) {
    this._x = t2, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t2) {
    this._y = t2, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t2) {
    this._z = t2, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t2) {
    this._w = t2, this._onChangeCallback();
  }
  set(t2, e2, n2, i2) {
    return this._x = t2, this._y = e2, this._z = n2, this._w = i2, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t2) {
    return this._x = t2.x, this._y = t2.y, this._z = t2.z, this._w = t2.w, this._onChangeCallback(), this;
  }
  setFromEuler(t2, e2) {
    if (!t2 || !t2.isEuler)
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const n2 = t2._x, i2 = t2._y, r2 = t2._z, s2 = t2._order, a2 = Math.cos, o2 = Math.sin, l2 = a2(n2 / 2), c2 = a2(i2 / 2), h2 = a2(r2 / 2), u2 = o2(n2 / 2), d2 = o2(i2 / 2), p2 = o2(r2 / 2);
    switch (s2) {
      case "XYZ":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "YXZ":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      case "ZXY":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "ZYX":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      case "YZX":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "XZY":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s2);
    }
    return e2 !== false && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t2, e2) {
    const n2 = e2 / 2, i2 = Math.sin(n2);
    return this._x = t2.x * i2, this._y = t2.y * i2, this._z = t2.z * i2, this._w = Math.cos(n2), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t2) {
    const e2 = t2.elements, n2 = e2[0], i2 = e2[4], r2 = e2[8], s2 = e2[1], a2 = e2[5], o2 = e2[9], l2 = e2[2], c2 = e2[6], h2 = e2[10], u2 = n2 + a2 + h2;
    if (u2 > 0) {
      const t3 = 0.5 / Math.sqrt(u2 + 1);
      this._w = 0.25 / t3, this._x = (c2 - o2) * t3, this._y = (r2 - l2) * t3, this._z = (s2 - i2) * t3;
    } else if (n2 > a2 && n2 > h2) {
      const t3 = 2 * Math.sqrt(1 + n2 - a2 - h2);
      this._w = (c2 - o2) / t3, this._x = 0.25 * t3, this._y = (i2 + s2) / t3, this._z = (r2 + l2) / t3;
    } else if (a2 > h2) {
      const t3 = 2 * Math.sqrt(1 + a2 - n2 - h2);
      this._w = (r2 - l2) / t3, this._x = (i2 + s2) / t3, this._y = 0.25 * t3, this._z = (o2 + c2) / t3;
    } else {
      const t3 = 2 * Math.sqrt(1 + h2 - n2 - a2);
      this._w = (s2 - i2) / t3, this._x = (r2 + l2) / t3, this._y = (o2 + c2) / t3, this._z = 0.25 * t3;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t2, e2) {
    let n2 = t2.dot(e2) + 1;
    return n2 < Number.EPSILON ? (n2 = 0, Math.abs(t2.x) > Math.abs(t2.z) ? (this._x = -t2.y, this._y = t2.x, this._z = 0, this._w = n2) : (this._x = 0, this._y = -t2.z, this._z = t2.y, this._w = n2)) : (this._x = t2.y * e2.z - t2.z * e2.y, this._y = t2.z * e2.x - t2.x * e2.z, this._z = t2.x * e2.y - t2.y * e2.x, this._w = n2), this.normalize();
  }
  angleTo(t2) {
    return 2 * Math.acos(Math.abs(ot(this.dot(t2), -1, 1)));
  }
  rotateTowards(t2, e2) {
    const n2 = this.angleTo(t2);
    if (n2 === 0)
      return this;
    const i2 = Math.min(1, e2 / n2);
    return this.slerp(t2, i2), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t2) {
    return this._x * t2._x + this._y * t2._y + this._z * t2._z + this._w * t2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t2 = this.length();
    return t2 === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t2 = 1 / t2, this._x = this._x * t2, this._y = this._y * t2, this._z = this._z * t2, this._w = this._w * t2), this._onChangeCallback(), this;
  }
  multiply(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t2, e2)) : this.multiplyQuaternions(this, t2);
  }
  premultiply(t2) {
    return this.multiplyQuaternions(t2, this);
  }
  multiplyQuaternions(t2, e2) {
    const n2 = t2._x, i2 = t2._y, r2 = t2._z, s2 = t2._w, a2 = e2._x, o2 = e2._y, l2 = e2._z, c2 = e2._w;
    return this._x = n2 * c2 + s2 * a2 + i2 * l2 - r2 * o2, this._y = i2 * c2 + s2 * o2 + r2 * a2 - n2 * l2, this._z = r2 * c2 + s2 * l2 + n2 * o2 - i2 * a2, this._w = s2 * c2 - n2 * a2 - i2 * o2 - r2 * l2, this._onChangeCallback(), this;
  }
  slerp(t2, e2) {
    if (e2 === 0)
      return this;
    if (e2 === 1)
      return this.copy(t2);
    const n2 = this._x, i2 = this._y, r2 = this._z, s2 = this._w;
    let a2 = s2 * t2._w + n2 * t2._x + i2 * t2._y + r2 * t2._z;
    if (a2 < 0 ? (this._w = -t2._w, this._x = -t2._x, this._y = -t2._y, this._z = -t2._z, a2 = -a2) : this.copy(t2), a2 >= 1)
      return this._w = s2, this._x = n2, this._y = i2, this._z = r2, this;
    const o2 = 1 - a2 * a2;
    if (o2 <= Number.EPSILON) {
      const t3 = 1 - e2;
      return this._w = t3 * s2 + e2 * this._w, this._x = t3 * n2 + e2 * this._x, this._y = t3 * i2 + e2 * this._y, this._z = t3 * r2 + e2 * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l2 = Math.sqrt(o2), c2 = Math.atan2(l2, a2), h2 = Math.sin((1 - e2) * c2) / l2, u2 = Math.sin(e2 * c2) / l2;
    return this._w = s2 * h2 + this._w * u2, this._x = n2 * h2 + this._x * u2, this._y = i2 * h2 + this._y * u2, this._z = r2 * h2 + this._z * u2, this._onChangeCallback(), this;
  }
  slerpQuaternions(t2, e2, n2) {
    this.copy(t2).slerp(e2, n2);
  }
  random() {
    const t2 = Math.random(), e2 = Math.sqrt(1 - t2), n2 = Math.sqrt(t2), i2 = 2 * Math.PI * Math.random(), r2 = 2 * Math.PI * Math.random();
    return this.set(e2 * Math.cos(i2), n2 * Math.sin(r2), n2 * Math.cos(r2), e2 * Math.sin(i2));
  }
  equals(t2) {
    return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._w === this._w;
  }
  fromArray(t2, e2 = 0) {
    return this._x = t2[e2], this._y = t2[e2 + 1], this._z = t2[e2 + 2], this._w = t2[e2 + 3], this._onChangeCallback(), this;
  }
  toArray(t2 = [], e2 = 0) {
    return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._w, t2;
  }
  fromBufferAttribute(t2, e2) {
    return this._x = t2.getX(e2), this._y = t2.getY(e2), this._z = t2.getZ(e2), this._w = t2.getW(e2), this;
  }
  _onChange(t2) {
    return this._onChangeCallback = t2, this;
  }
  _onChangeCallback() {
  }
}
Et.prototype.isQuaternion = true;
class At {
  constructor(t2 = 0, e2 = 0, n2 = 0) {
    this.x = t2, this.y = e2, this.z = n2;
  }
  set(t2, e2, n2) {
    return n2 === void 0 && (n2 = this.z), this.x = t2, this.y = e2, this.z = n2, this;
  }
  setScalar(t2) {
    return this.x = t2, this.y = t2, this.z = t2, this;
  }
  setX(t2) {
    return this.x = t2, this;
  }
  setY(t2) {
    return this.y = t2, this;
  }
  setZ(t2) {
    return this.z = t2, this;
  }
  setComponent(t2, e2) {
    switch (t2) {
      case 0:
        this.x = e2;
        break;
      case 1:
        this.y = e2;
        break;
      case 2:
        this.z = e2;
        break;
      default:
        throw new Error("index is out of range: " + t2);
    }
    return this;
  }
  getComponent(t2) {
    switch (t2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t2) {
    return this.x = t2.x, this.y = t2.y, this.z = t2.z, this;
  }
  add(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this);
  }
  addScalar(t2) {
    return this.x += t2, this.y += t2, this.z += t2, this;
  }
  addVectors(t2, e2) {
    return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this;
  }
  addScaledVector(t2, e2) {
    return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this;
  }
  sub(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this);
  }
  subScalar(t2) {
    return this.x -= t2, this.y -= t2, this.z -= t2, this;
  }
  subVectors(t2, e2) {
    return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this;
  }
  multiply(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t2, e2)) : (this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this);
  }
  multiplyScalar(t2) {
    return this.x *= t2, this.y *= t2, this.z *= t2, this;
  }
  multiplyVectors(t2, e2) {
    return this.x = t2.x * e2.x, this.y = t2.y * e2.y, this.z = t2.z * e2.z, this;
  }
  applyEuler(t2) {
    return t2 && t2.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Lt.setFromEuler(t2));
  }
  applyAxisAngle(t2, e2) {
    return this.applyQuaternion(Lt.setFromAxisAngle(t2, e2));
  }
  applyMatrix3(t2) {
    const e2 = this.x, n2 = this.y, i2 = this.z, r2 = t2.elements;
    return this.x = r2[0] * e2 + r2[3] * n2 + r2[6] * i2, this.y = r2[1] * e2 + r2[4] * n2 + r2[7] * i2, this.z = r2[2] * e2 + r2[5] * n2 + r2[8] * i2, this;
  }
  applyNormalMatrix(t2) {
    return this.applyMatrix3(t2).normalize();
  }
  applyMatrix4(t2) {
    const e2 = this.x, n2 = this.y, i2 = this.z, r2 = t2.elements, s2 = 1 / (r2[3] * e2 + r2[7] * n2 + r2[11] * i2 + r2[15]);
    return this.x = (r2[0] * e2 + r2[4] * n2 + r2[8] * i2 + r2[12]) * s2, this.y = (r2[1] * e2 + r2[5] * n2 + r2[9] * i2 + r2[13]) * s2, this.z = (r2[2] * e2 + r2[6] * n2 + r2[10] * i2 + r2[14]) * s2, this;
  }
  applyQuaternion(t2) {
    const e2 = this.x, n2 = this.y, i2 = this.z, r2 = t2.x, s2 = t2.y, a2 = t2.z, o2 = t2.w, l2 = o2 * e2 + s2 * i2 - a2 * n2, c2 = o2 * n2 + a2 * e2 - r2 * i2, h2 = o2 * i2 + r2 * n2 - s2 * e2, u2 = -r2 * e2 - s2 * n2 - a2 * i2;
    return this.x = l2 * o2 + u2 * -r2 + c2 * -a2 - h2 * -s2, this.y = c2 * o2 + u2 * -s2 + h2 * -r2 - l2 * -a2, this.z = h2 * o2 + u2 * -a2 + l2 * -s2 - c2 * -r2, this;
  }
  project(t2) {
    return this.applyMatrix4(t2.matrixWorldInverse).applyMatrix4(t2.projectionMatrix);
  }
  unproject(t2) {
    return this.applyMatrix4(t2.projectionMatrixInverse).applyMatrix4(t2.matrixWorld);
  }
  transformDirection(t2) {
    const e2 = this.x, n2 = this.y, i2 = this.z, r2 = t2.elements;
    return this.x = r2[0] * e2 + r2[4] * n2 + r2[8] * i2, this.y = r2[1] * e2 + r2[5] * n2 + r2[9] * i2, this.z = r2[2] * e2 + r2[6] * n2 + r2[10] * i2, this.normalize();
  }
  divide(t2) {
    return this.x /= t2.x, this.y /= t2.y, this.z /= t2.z, this;
  }
  divideScalar(t2) {
    return this.multiplyScalar(1 / t2);
  }
  min(t2) {
    return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this;
  }
  max(t2) {
    return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this;
  }
  clamp(t2, e2) {
    return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this;
  }
  clampScalar(t2, e2) {
    return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this;
  }
  clampLength(t2, e2) {
    const n2 = this.length();
    return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t2) {
    return this.x * t2.x + this.y * t2.y + this.z * t2.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t2) {
    return this.normalize().multiplyScalar(t2);
  }
  lerp(t2, e2) {
    return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this;
  }
  lerpVectors(t2, e2, n2) {
    return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this.z = t2.z + (e2.z - t2.z) * n2, this;
  }
  cross(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t2, e2)) : this.crossVectors(this, t2);
  }
  crossVectors(t2, e2) {
    const n2 = t2.x, i2 = t2.y, r2 = t2.z, s2 = e2.x, a2 = e2.y, o2 = e2.z;
    return this.x = i2 * o2 - r2 * a2, this.y = r2 * s2 - n2 * o2, this.z = n2 * a2 - i2 * s2, this;
  }
  projectOnVector(t2) {
    const e2 = t2.lengthSq();
    if (e2 === 0)
      return this.set(0, 0, 0);
    const n2 = t2.dot(this) / e2;
    return this.copy(t2).multiplyScalar(n2);
  }
  projectOnPlane(t2) {
    return Rt.copy(this).projectOnVector(t2), this.sub(Rt);
  }
  reflect(t2) {
    return this.sub(Rt.copy(t2).multiplyScalar(2 * this.dot(t2)));
  }
  angleTo(t2) {
    const e2 = Math.sqrt(this.lengthSq() * t2.lengthSq());
    if (e2 === 0)
      return Math.PI / 2;
    const n2 = this.dot(t2) / e2;
    return Math.acos(ot(n2, -1, 1));
  }
  distanceTo(t2) {
    return Math.sqrt(this.distanceToSquared(t2));
  }
  distanceToSquared(t2) {
    const e2 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.z - t2.z;
    return e2 * e2 + n2 * n2 + i2 * i2;
  }
  manhattanDistanceTo(t2) {
    return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y) + Math.abs(this.z - t2.z);
  }
  setFromSpherical(t2) {
    return this.setFromSphericalCoords(t2.radius, t2.phi, t2.theta);
  }
  setFromSphericalCoords(t2, e2, n2) {
    const i2 = Math.sin(e2) * t2;
    return this.x = i2 * Math.sin(n2), this.y = Math.cos(e2) * t2, this.z = i2 * Math.cos(n2), this;
  }
  setFromCylindrical(t2) {
    return this.setFromCylindricalCoords(t2.radius, t2.theta, t2.y);
  }
  setFromCylindricalCoords(t2, e2, n2) {
    return this.x = t2 * Math.sin(e2), this.y = n2, this.z = t2 * Math.cos(e2), this;
  }
  setFromMatrixPosition(t2) {
    const e2 = t2.elements;
    return this.x = e2[12], this.y = e2[13], this.z = e2[14], this;
  }
  setFromMatrixScale(t2) {
    const e2 = this.setFromMatrixColumn(t2, 0).length(), n2 = this.setFromMatrixColumn(t2, 1).length(), i2 = this.setFromMatrixColumn(t2, 2).length();
    return this.x = e2, this.y = n2, this.z = i2, this;
  }
  setFromMatrixColumn(t2, e2) {
    return this.fromArray(t2.elements, 4 * e2);
  }
  setFromMatrix3Column(t2, e2) {
    return this.fromArray(t2.elements, 3 * e2);
  }
  equals(t2) {
    return t2.x === this.x && t2.y === this.y && t2.z === this.z;
  }
  fromArray(t2, e2 = 0) {
    return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this;
  }
  toArray(t2 = [], e2 = 0) {
    return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2;
  }
  fromBufferAttribute(t2, e2, n2) {
    return n2 !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t2 = 2 * (Math.random() - 0.5), e2 = Math.random() * Math.PI * 2, n2 = Math.sqrt(1 - t2 ** 2);
    return this.x = n2 * Math.cos(e2), this.y = n2 * Math.sin(e2), this.z = t2, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
At.prototype.isVector3 = true;
const Rt = new At(), Lt = new Et();
class Ct {
  constructor(t2 = new At(1 / 0, 1 / 0, 1 / 0), e2 = new At(-1 / 0, -1 / 0, -1 / 0)) {
    this.min = t2, this.max = e2;
  }
  set(t2, e2) {
    return this.min.copy(t2), this.max.copy(e2), this;
  }
  setFromArray(t2) {
    let e2 = 1 / 0, n2 = 1 / 0, i2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, a2 = -1 / 0;
    for (let o2 = 0, l2 = t2.length; o2 < l2; o2 += 3) {
      const l3 = t2[o2], c2 = t2[o2 + 1], h2 = t2[o2 + 2];
      l3 < e2 && (e2 = l3), c2 < n2 && (n2 = c2), h2 < i2 && (i2 = h2), l3 > r2 && (r2 = l3), c2 > s2 && (s2 = c2), h2 > a2 && (a2 = h2);
    }
    return this.min.set(e2, n2, i2), this.max.set(r2, s2, a2), this;
  }
  setFromBufferAttribute(t2) {
    let e2 = 1 / 0, n2 = 1 / 0, i2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, a2 = -1 / 0;
    for (let o2 = 0, l2 = t2.count; o2 < l2; o2++) {
      const l3 = t2.getX(o2), c2 = t2.getY(o2), h2 = t2.getZ(o2);
      l3 < e2 && (e2 = l3), c2 < n2 && (n2 = c2), h2 < i2 && (i2 = h2), l3 > r2 && (r2 = l3), c2 > s2 && (s2 = c2), h2 > a2 && (a2 = h2);
    }
    return this.min.set(e2, n2, i2), this.max.set(r2, s2, a2), this;
  }
  setFromPoints(t2) {
    this.makeEmpty();
    for (let e2 = 0, n2 = t2.length; e2 < n2; e2++)
      this.expandByPoint(t2[e2]);
    return this;
  }
  setFromCenterAndSize(t2, e2) {
    const n2 = It.copy(e2).multiplyScalar(0.5);
    return this.min.copy(t2).sub(n2), this.max.copy(t2).add(n2), this;
  }
  setFromObject(t2) {
    return this.makeEmpty(), this.expandByObject(t2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t2) {
    return this.min.copy(t2.min), this.max.copy(t2.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t2) {
    return this.isEmpty() ? t2.set(0, 0, 0) : t2.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t2) {
    return this.isEmpty() ? t2.set(0, 0, 0) : t2.subVectors(this.max, this.min);
  }
  expandByPoint(t2) {
    return this.min.min(t2), this.max.max(t2), this;
  }
  expandByVector(t2) {
    return this.min.sub(t2), this.max.add(t2), this;
  }
  expandByScalar(t2) {
    return this.min.addScalar(-t2), this.max.addScalar(t2), this;
  }
  expandByObject(t2) {
    t2.updateWorldMatrix(false, false);
    const e2 = t2.geometry;
    e2 !== void 0 && (e2.boundingBox === null && e2.computeBoundingBox(), Dt.copy(e2.boundingBox), Dt.applyMatrix4(t2.matrixWorld), this.union(Dt));
    const n2 = t2.children;
    for (let t3 = 0, e3 = n2.length; t3 < e3; t3++)
      this.expandByObject(n2[t3]);
    return this;
  }
  containsPoint(t2) {
    return !(t2.x < this.min.x || t2.x > this.max.x || t2.y < this.min.y || t2.y > this.max.y || t2.z < this.min.z || t2.z > this.max.z);
  }
  containsBox(t2) {
    return this.min.x <= t2.min.x && t2.max.x <= this.max.x && this.min.y <= t2.min.y && t2.max.y <= this.max.y && this.min.z <= t2.min.z && t2.max.z <= this.max.z;
  }
  getParameter(t2, e2) {
    return e2.set((t2.x - this.min.x) / (this.max.x - this.min.x), (t2.y - this.min.y) / (this.max.y - this.min.y), (t2.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(t2) {
    return !(t2.max.x < this.min.x || t2.min.x > this.max.x || t2.max.y < this.min.y || t2.min.y > this.max.y || t2.max.z < this.min.z || t2.min.z > this.max.z);
  }
  intersectsSphere(t2) {
    return this.clampPoint(t2.center, It), It.distanceToSquared(t2.center) <= t2.radius * t2.radius;
  }
  intersectsPlane(t2) {
    let e2, n2;
    return t2.normal.x > 0 ? (e2 = t2.normal.x * this.min.x, n2 = t2.normal.x * this.max.x) : (e2 = t2.normal.x * this.max.x, n2 = t2.normal.x * this.min.x), t2.normal.y > 0 ? (e2 += t2.normal.y * this.min.y, n2 += t2.normal.y * this.max.y) : (e2 += t2.normal.y * this.max.y, n2 += t2.normal.y * this.min.y), t2.normal.z > 0 ? (e2 += t2.normal.z * this.min.z, n2 += t2.normal.z * this.max.z) : (e2 += t2.normal.z * this.max.z, n2 += t2.normal.z * this.min.z), e2 <= -t2.constant && n2 >= -t2.constant;
  }
  intersectsTriangle(t2) {
    if (this.isEmpty())
      return false;
    this.getCenter(Bt), Ht.subVectors(this.max, Bt), Nt.subVectors(t2.a, Bt), Ft.subVectors(t2.b, Bt), Ot.subVectors(t2.c, Bt), Ut.subVectors(Ft, Nt), kt.subVectors(Ot, Ft), zt.subVectors(Nt, Ot);
    let e2 = [0, -Ut.z, Ut.y, 0, -kt.z, kt.y, 0, -zt.z, zt.y, Ut.z, 0, -Ut.x, kt.z, 0, -kt.x, zt.z, 0, -zt.x, -Ut.y, Ut.x, 0, -kt.y, kt.x, 0, -zt.y, zt.x, 0];
    return !!Wt(e2, Nt, Ft, Ot, Ht) && (e2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Wt(e2, Nt, Ft, Ot, Ht) && (Vt.crossVectors(Ut, kt), e2 = [Vt.x, Vt.y, Vt.z], Wt(e2, Nt, Ft, Ot, Ht)));
  }
  clampPoint(t2, e2) {
    return e2.copy(t2).clamp(this.min, this.max);
  }
  distanceToPoint(t2) {
    return It.copy(t2).clamp(this.min, this.max).sub(t2).length();
  }
  getBoundingSphere(t2) {
    return this.getCenter(t2.center), t2.radius = 0.5 * this.getSize(It).length(), t2;
  }
  intersect(t2) {
    return this.min.max(t2.min), this.max.min(t2.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t2) {
    return this.min.min(t2.min), this.max.max(t2.max), this;
  }
  applyMatrix4(t2) {
    return this.isEmpty() || (Pt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t2), Pt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t2), Pt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t2), Pt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t2), Pt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t2), Pt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t2), Pt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t2), Pt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t2), this.setFromPoints(Pt)), this;
  }
  translate(t2) {
    return this.min.add(t2), this.max.add(t2), this;
  }
  equals(t2) {
    return t2.min.equals(this.min) && t2.max.equals(this.max);
  }
}
Ct.prototype.isBox3 = true;
const Pt = [new At(), new At(), new At(), new At(), new At(), new At(), new At(), new At()], It = new At(), Dt = new Ct(), Nt = new At(), Ft = new At(), Ot = new At(), Ut = new At(), kt = new At(), zt = new At(), Bt = new At(), Ht = new At(), Vt = new At(), Gt = new At();
function Wt(t2, e2, n2, i2, r2) {
  for (let s2 = 0, a2 = t2.length - 3; s2 <= a2; s2 += 3) {
    Gt.fromArray(t2, s2);
    const a3 = r2.x * Math.abs(Gt.x) + r2.y * Math.abs(Gt.y) + r2.z * Math.abs(Gt.z), o2 = e2.dot(Gt), l2 = n2.dot(Gt), c2 = i2.dot(Gt);
    if (Math.max(-Math.max(o2, l2, c2), Math.min(o2, l2, c2)) > a3)
      return false;
  }
  return true;
}
const jt = new Ct(), qt = new At(), Xt = new At(), Yt = new At();
class Zt {
  constructor(t2 = new At(), e2 = -1) {
    this.center = t2, this.radius = e2;
  }
  set(t2, e2) {
    return this.center.copy(t2), this.radius = e2, this;
  }
  setFromPoints(t2, e2) {
    const n2 = this.center;
    e2 !== void 0 ? n2.copy(e2) : jt.setFromPoints(t2).getCenter(n2);
    let i2 = 0;
    for (let e3 = 0, r2 = t2.length; e3 < r2; e3++)
      i2 = Math.max(i2, n2.distanceToSquared(t2[e3]));
    return this.radius = Math.sqrt(i2), this;
  }
  copy(t2) {
    return this.center.copy(t2.center), this.radius = t2.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t2) {
    return t2.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t2) {
    return t2.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t2) {
    const e2 = this.radius + t2.radius;
    return t2.center.distanceToSquared(this.center) <= e2 * e2;
  }
  intersectsBox(t2) {
    return t2.intersectsSphere(this);
  }
  intersectsPlane(t2) {
    return Math.abs(t2.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t2, e2) {
    const n2 = this.center.distanceToSquared(t2);
    return e2.copy(t2), n2 > this.radius * this.radius && (e2.sub(this.center).normalize(), e2.multiplyScalar(this.radius).add(this.center)), e2;
  }
  getBoundingBox(t2) {
    return this.isEmpty() ? (t2.makeEmpty(), t2) : (t2.set(this.center, this.center), t2.expandByScalar(this.radius), t2);
  }
  applyMatrix4(t2) {
    return this.center.applyMatrix4(t2), this.radius = this.radius * t2.getMaxScaleOnAxis(), this;
  }
  translate(t2) {
    return this.center.add(t2), this;
  }
  expandByPoint(t2) {
    Yt.subVectors(t2, this.center);
    const e2 = Yt.lengthSq();
    if (e2 > this.radius * this.radius) {
      const t3 = Math.sqrt(e2), n2 = 0.5 * (t3 - this.radius);
      this.center.add(Yt.multiplyScalar(n2 / t3)), this.radius += n2;
    }
    return this;
  }
  union(t2) {
    return this.center.equals(t2.center) === true ? Xt.set(0, 0, 1).multiplyScalar(t2.radius) : Xt.subVectors(t2.center, this.center).normalize().multiplyScalar(t2.radius), this.expandByPoint(qt.copy(t2.center).add(Xt)), this.expandByPoint(qt.copy(t2.center).sub(Xt)), this;
  }
  equals(t2) {
    return t2.center.equals(this.center) && t2.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Jt = new At(), $t = new At(), Kt = new At(), Qt = new At(), te = new At(), ee = new At(), ne = new At();
class ie {
  constructor(t2 = new At(), e2 = new At(0, 0, -1)) {
    this.origin = t2, this.direction = e2;
  }
  set(t2, e2) {
    return this.origin.copy(t2), this.direction.copy(e2), this;
  }
  copy(t2) {
    return this.origin.copy(t2.origin), this.direction.copy(t2.direction), this;
  }
  at(t2, e2) {
    return e2.copy(this.direction).multiplyScalar(t2).add(this.origin);
  }
  lookAt(t2) {
    return this.direction.copy(t2).sub(this.origin).normalize(), this;
  }
  recast(t2) {
    return this.origin.copy(this.at(t2, Jt)), this;
  }
  closestPointToPoint(t2, e2) {
    e2.subVectors(t2, this.origin);
    const n2 = e2.dot(this.direction);
    return n2 < 0 ? e2.copy(this.origin) : e2.copy(this.direction).multiplyScalar(n2).add(this.origin);
  }
  distanceToPoint(t2) {
    return Math.sqrt(this.distanceSqToPoint(t2));
  }
  distanceSqToPoint(t2) {
    const e2 = Jt.subVectors(t2, this.origin).dot(this.direction);
    return e2 < 0 ? this.origin.distanceToSquared(t2) : (Jt.copy(this.direction).multiplyScalar(e2).add(this.origin), Jt.distanceToSquared(t2));
  }
  distanceSqToSegment(t2, e2, n2, i2) {
    $t.copy(t2).add(e2).multiplyScalar(0.5), Kt.copy(e2).sub(t2).normalize(), Qt.copy(this.origin).sub($t);
    const r2 = 0.5 * t2.distanceTo(e2), s2 = -this.direction.dot(Kt), a2 = Qt.dot(this.direction), o2 = -Qt.dot(Kt), l2 = Qt.lengthSq(), c2 = Math.abs(1 - s2 * s2);
    let h2, u2, d2, p2;
    if (c2 > 0)
      if (h2 = s2 * o2 - a2, u2 = s2 * a2 - o2, p2 = r2 * c2, h2 >= 0)
        if (u2 >= -p2)
          if (u2 <= p2) {
            const t3 = 1 / c2;
            h2 *= t3, u2 *= t3, d2 = h2 * (h2 + s2 * u2 + 2 * a2) + u2 * (s2 * h2 + u2 + 2 * o2) + l2;
          } else
            u2 = r2, h2 = Math.max(0, -(s2 * u2 + a2)), d2 = -h2 * h2 + u2 * (u2 + 2 * o2) + l2;
        else
          u2 = -r2, h2 = Math.max(0, -(s2 * u2 + a2)), d2 = -h2 * h2 + u2 * (u2 + 2 * o2) + l2;
      else
        u2 <= -p2 ? (h2 = Math.max(0, -(-s2 * r2 + a2)), u2 = h2 > 0 ? -r2 : Math.min(Math.max(-r2, -o2), r2), d2 = -h2 * h2 + u2 * (u2 + 2 * o2) + l2) : u2 <= p2 ? (h2 = 0, u2 = Math.min(Math.max(-r2, -o2), r2), d2 = u2 * (u2 + 2 * o2) + l2) : (h2 = Math.max(0, -(s2 * r2 + a2)), u2 = h2 > 0 ? r2 : Math.min(Math.max(-r2, -o2), r2), d2 = -h2 * h2 + u2 * (u2 + 2 * o2) + l2);
    else
      u2 = s2 > 0 ? -r2 : r2, h2 = Math.max(0, -(s2 * u2 + a2)), d2 = -h2 * h2 + u2 * (u2 + 2 * o2) + l2;
    return n2 && n2.copy(this.direction).multiplyScalar(h2).add(this.origin), i2 && i2.copy(Kt).multiplyScalar(u2).add($t), d2;
  }
  intersectSphere(t2, e2) {
    Jt.subVectors(t2.center, this.origin);
    const n2 = Jt.dot(this.direction), i2 = Jt.dot(Jt) - n2 * n2, r2 = t2.radius * t2.radius;
    if (i2 > r2)
      return null;
    const s2 = Math.sqrt(r2 - i2), a2 = n2 - s2, o2 = n2 + s2;
    return a2 < 0 && o2 < 0 ? null : a2 < 0 ? this.at(o2, e2) : this.at(a2, e2);
  }
  intersectsSphere(t2) {
    return this.distanceSqToPoint(t2.center) <= t2.radius * t2.radius;
  }
  distanceToPlane(t2) {
    const e2 = t2.normal.dot(this.direction);
    if (e2 === 0)
      return t2.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n2 = -(this.origin.dot(t2.normal) + t2.constant) / e2;
    return n2 >= 0 ? n2 : null;
  }
  intersectPlane(t2, e2) {
    const n2 = this.distanceToPlane(t2);
    return n2 === null ? null : this.at(n2, e2);
  }
  intersectsPlane(t2) {
    const e2 = t2.distanceToPoint(this.origin);
    if (e2 === 0)
      return true;
    return t2.normal.dot(this.direction) * e2 < 0;
  }
  intersectBox(t2, e2) {
    let n2, i2, r2, s2, a2, o2;
    const l2 = 1 / this.direction.x, c2 = 1 / this.direction.y, h2 = 1 / this.direction.z, u2 = this.origin;
    return l2 >= 0 ? (n2 = (t2.min.x - u2.x) * l2, i2 = (t2.max.x - u2.x) * l2) : (n2 = (t2.max.x - u2.x) * l2, i2 = (t2.min.x - u2.x) * l2), c2 >= 0 ? (r2 = (t2.min.y - u2.y) * c2, s2 = (t2.max.y - u2.y) * c2) : (r2 = (t2.max.y - u2.y) * c2, s2 = (t2.min.y - u2.y) * c2), n2 > s2 || r2 > i2 ? null : ((r2 > n2 || n2 != n2) && (n2 = r2), (s2 < i2 || i2 != i2) && (i2 = s2), h2 >= 0 ? (a2 = (t2.min.z - u2.z) * h2, o2 = (t2.max.z - u2.z) * h2) : (a2 = (t2.max.z - u2.z) * h2, o2 = (t2.min.z - u2.z) * h2), n2 > o2 || a2 > i2 ? null : ((a2 > n2 || n2 != n2) && (n2 = a2), (o2 < i2 || i2 != i2) && (i2 = o2), i2 < 0 ? null : this.at(n2 >= 0 ? n2 : i2, e2)));
  }
  intersectsBox(t2) {
    return this.intersectBox(t2, Jt) !== null;
  }
  intersectTriangle(t2, e2, n2, i2, r2) {
    te.subVectors(e2, t2), ee.subVectors(n2, t2), ne.crossVectors(te, ee);
    let s2, a2 = this.direction.dot(ne);
    if (a2 > 0) {
      if (i2)
        return null;
      s2 = 1;
    } else {
      if (!(a2 < 0))
        return null;
      s2 = -1, a2 = -a2;
    }
    Qt.subVectors(this.origin, t2);
    const o2 = s2 * this.direction.dot(ee.crossVectors(Qt, ee));
    if (o2 < 0)
      return null;
    const l2 = s2 * this.direction.dot(te.cross(Qt));
    if (l2 < 0)
      return null;
    if (o2 + l2 > a2)
      return null;
    const c2 = -s2 * Qt.dot(ne);
    return c2 < 0 ? null : this.at(c2 / a2, r2);
  }
  applyMatrix4(t2) {
    return this.origin.applyMatrix4(t2), this.direction.transformDirection(t2), this;
  }
  equals(t2) {
    return t2.origin.equals(this.origin) && t2.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class re {
  constructor() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  set(t2, e2, n2, i2, r2, s2, a2, o2, l2, c2, h2, u2, d2, p2, m2, f2) {
    const g2 = this.elements;
    return g2[0] = t2, g2[4] = e2, g2[8] = n2, g2[12] = i2, g2[1] = r2, g2[5] = s2, g2[9] = a2, g2[13] = o2, g2[2] = l2, g2[6] = c2, g2[10] = h2, g2[14] = u2, g2[3] = d2, g2[7] = p2, g2[11] = m2, g2[15] = f2, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new re().fromArray(this.elements);
  }
  copy(t2) {
    const e2 = this.elements, n2 = t2.elements;
    return e2[0] = n2[0], e2[1] = n2[1], e2[2] = n2[2], e2[3] = n2[3], e2[4] = n2[4], e2[5] = n2[5], e2[6] = n2[6], e2[7] = n2[7], e2[8] = n2[8], e2[9] = n2[9], e2[10] = n2[10], e2[11] = n2[11], e2[12] = n2[12], e2[13] = n2[13], e2[14] = n2[14], e2[15] = n2[15], this;
  }
  copyPosition(t2) {
    const e2 = this.elements, n2 = t2.elements;
    return e2[12] = n2[12], e2[13] = n2[13], e2[14] = n2[14], this;
  }
  setFromMatrix3(t2) {
    const e2 = t2.elements;
    return this.set(e2[0], e2[3], e2[6], 0, e2[1], e2[4], e2[7], 0, e2[2], e2[5], e2[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(t2, e2, n2) {
    return t2.setFromMatrixColumn(this, 0), e2.setFromMatrixColumn(this, 1), n2.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t2, e2, n2) {
    return this.set(t2.x, e2.x, n2.x, 0, t2.y, e2.y, n2.y, 0, t2.z, e2.z, n2.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(t2) {
    const e2 = this.elements, n2 = t2.elements, i2 = 1 / se.setFromMatrixColumn(t2, 0).length(), r2 = 1 / se.setFromMatrixColumn(t2, 1).length(), s2 = 1 / se.setFromMatrixColumn(t2, 2).length();
    return e2[0] = n2[0] * i2, e2[1] = n2[1] * i2, e2[2] = n2[2] * i2, e2[3] = 0, e2[4] = n2[4] * r2, e2[5] = n2[5] * r2, e2[6] = n2[6] * r2, e2[7] = 0, e2[8] = n2[8] * s2, e2[9] = n2[9] * s2, e2[10] = n2[10] * s2, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
  }
  makeRotationFromEuler(t2) {
    t2 && t2.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    const e2 = this.elements, n2 = t2.x, i2 = t2.y, r2 = t2.z, s2 = Math.cos(n2), a2 = Math.sin(n2), o2 = Math.cos(i2), l2 = Math.sin(i2), c2 = Math.cos(r2), h2 = Math.sin(r2);
    if (t2.order === "XYZ") {
      const t3 = s2 * c2, n3 = s2 * h2, i3 = a2 * c2, r3 = a2 * h2;
      e2[0] = o2 * c2, e2[4] = -o2 * h2, e2[8] = l2, e2[1] = n3 + i3 * l2, e2[5] = t3 - r3 * l2, e2[9] = -a2 * o2, e2[2] = r3 - t3 * l2, e2[6] = i3 + n3 * l2, e2[10] = s2 * o2;
    } else if (t2.order === "YXZ") {
      const t3 = o2 * c2, n3 = o2 * h2, i3 = l2 * c2, r3 = l2 * h2;
      e2[0] = t3 + r3 * a2, e2[4] = i3 * a2 - n3, e2[8] = s2 * l2, e2[1] = s2 * h2, e2[5] = s2 * c2, e2[9] = -a2, e2[2] = n3 * a2 - i3, e2[6] = r3 + t3 * a2, e2[10] = s2 * o2;
    } else if (t2.order === "ZXY") {
      const t3 = o2 * c2, n3 = o2 * h2, i3 = l2 * c2, r3 = l2 * h2;
      e2[0] = t3 - r3 * a2, e2[4] = -s2 * h2, e2[8] = i3 + n3 * a2, e2[1] = n3 + i3 * a2, e2[5] = s2 * c2, e2[9] = r3 - t3 * a2, e2[2] = -s2 * l2, e2[6] = a2, e2[10] = s2 * o2;
    } else if (t2.order === "ZYX") {
      const t3 = s2 * c2, n3 = s2 * h2, i3 = a2 * c2, r3 = a2 * h2;
      e2[0] = o2 * c2, e2[4] = i3 * l2 - n3, e2[8] = t3 * l2 + r3, e2[1] = o2 * h2, e2[5] = r3 * l2 + t3, e2[9] = n3 * l2 - i3, e2[2] = -l2, e2[6] = a2 * o2, e2[10] = s2 * o2;
    } else if (t2.order === "YZX") {
      const t3 = s2 * o2, n3 = s2 * l2, i3 = a2 * o2, r3 = a2 * l2;
      e2[0] = o2 * c2, e2[4] = r3 - t3 * h2, e2[8] = i3 * h2 + n3, e2[1] = h2, e2[5] = s2 * c2, e2[9] = -a2 * c2, e2[2] = -l2 * c2, e2[6] = n3 * h2 + i3, e2[10] = t3 - r3 * h2;
    } else if (t2.order === "XZY") {
      const t3 = s2 * o2, n3 = s2 * l2, i3 = a2 * o2, r3 = a2 * l2;
      e2[0] = o2 * c2, e2[4] = -h2, e2[8] = l2 * c2, e2[1] = t3 * h2 + r3, e2[5] = s2 * c2, e2[9] = n3 * h2 - i3, e2[2] = i3 * h2 - n3, e2[6] = a2 * c2, e2[10] = r3 * h2 + t3;
    }
    return e2[3] = 0, e2[7] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
  }
  makeRotationFromQuaternion(t2) {
    return this.compose(oe, t2, le);
  }
  lookAt(t2, e2, n2) {
    const i2 = this.elements;
    return ue.subVectors(t2, e2), ue.lengthSq() === 0 && (ue.z = 1), ue.normalize(), ce.crossVectors(n2, ue), ce.lengthSq() === 0 && (Math.abs(n2.z) === 1 ? ue.x += 1e-4 : ue.z += 1e-4, ue.normalize(), ce.crossVectors(n2, ue)), ce.normalize(), he.crossVectors(ue, ce), i2[0] = ce.x, i2[4] = he.x, i2[8] = ue.x, i2[1] = ce.y, i2[5] = he.y, i2[9] = ue.y, i2[2] = ce.z, i2[6] = he.z, i2[10] = ue.z, this;
  }
  multiply(t2, e2) {
    return e2 !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t2, e2)) : this.multiplyMatrices(this, t2);
  }
  premultiply(t2) {
    return this.multiplyMatrices(t2, this);
  }
  multiplyMatrices(t2, e2) {
    const n2 = t2.elements, i2 = e2.elements, r2 = this.elements, s2 = n2[0], a2 = n2[4], o2 = n2[8], l2 = n2[12], c2 = n2[1], h2 = n2[5], u2 = n2[9], d2 = n2[13], p2 = n2[2], m2 = n2[6], f2 = n2[10], g2 = n2[14], v2 = n2[3], y2 = n2[7], x2 = n2[11], b2 = n2[15], w2 = i2[0], _2 = i2[4], M2 = i2[8], S2 = i2[12], T2 = i2[1], E2 = i2[5], A2 = i2[9], R2 = i2[13], L2 = i2[2], C2 = i2[6], P2 = i2[10], I2 = i2[14], D2 = i2[3], N2 = i2[7], F2 = i2[11], O2 = i2[15];
    return r2[0] = s2 * w2 + a2 * T2 + o2 * L2 + l2 * D2, r2[4] = s2 * _2 + a2 * E2 + o2 * C2 + l2 * N2, r2[8] = s2 * M2 + a2 * A2 + o2 * P2 + l2 * F2, r2[12] = s2 * S2 + a2 * R2 + o2 * I2 + l2 * O2, r2[1] = c2 * w2 + h2 * T2 + u2 * L2 + d2 * D2, r2[5] = c2 * _2 + h2 * E2 + u2 * C2 + d2 * N2, r2[9] = c2 * M2 + h2 * A2 + u2 * P2 + d2 * F2, r2[13] = c2 * S2 + h2 * R2 + u2 * I2 + d2 * O2, r2[2] = p2 * w2 + m2 * T2 + f2 * L2 + g2 * D2, r2[6] = p2 * _2 + m2 * E2 + f2 * C2 + g2 * N2, r2[10] = p2 * M2 + m2 * A2 + f2 * P2 + g2 * F2, r2[14] = p2 * S2 + m2 * R2 + f2 * I2 + g2 * O2, r2[3] = v2 * w2 + y2 * T2 + x2 * L2 + b2 * D2, r2[7] = v2 * _2 + y2 * E2 + x2 * C2 + b2 * N2, r2[11] = v2 * M2 + y2 * A2 + x2 * P2 + b2 * F2, r2[15] = v2 * S2 + y2 * R2 + x2 * I2 + b2 * O2, this;
  }
  multiplyScalar(t2) {
    const e2 = this.elements;
    return e2[0] *= t2, e2[4] *= t2, e2[8] *= t2, e2[12] *= t2, e2[1] *= t2, e2[5] *= t2, e2[9] *= t2, e2[13] *= t2, e2[2] *= t2, e2[6] *= t2, e2[10] *= t2, e2[14] *= t2, e2[3] *= t2, e2[7] *= t2, e2[11] *= t2, e2[15] *= t2, this;
  }
  determinant() {
    const t2 = this.elements, e2 = t2[0], n2 = t2[4], i2 = t2[8], r2 = t2[12], s2 = t2[1], a2 = t2[5], o2 = t2[9], l2 = t2[13], c2 = t2[2], h2 = t2[6], u2 = t2[10], d2 = t2[14];
    return t2[3] * (+r2 * o2 * h2 - i2 * l2 * h2 - r2 * a2 * u2 + n2 * l2 * u2 + i2 * a2 * d2 - n2 * o2 * d2) + t2[7] * (+e2 * o2 * d2 - e2 * l2 * u2 + r2 * s2 * u2 - i2 * s2 * d2 + i2 * l2 * c2 - r2 * o2 * c2) + t2[11] * (+e2 * l2 * h2 - e2 * a2 * d2 - r2 * s2 * h2 + n2 * s2 * d2 + r2 * a2 * c2 - n2 * l2 * c2) + t2[15] * (-i2 * a2 * c2 - e2 * o2 * h2 + e2 * a2 * u2 + i2 * s2 * h2 - n2 * s2 * u2 + n2 * o2 * c2);
  }
  transpose() {
    const t2 = this.elements;
    let e2;
    return e2 = t2[1], t2[1] = t2[4], t2[4] = e2, e2 = t2[2], t2[2] = t2[8], t2[8] = e2, e2 = t2[6], t2[6] = t2[9], t2[9] = e2, e2 = t2[3], t2[3] = t2[12], t2[12] = e2, e2 = t2[7], t2[7] = t2[13], t2[13] = e2, e2 = t2[11], t2[11] = t2[14], t2[14] = e2, this;
  }
  setPosition(t2, e2, n2) {
    const i2 = this.elements;
    return t2.isVector3 ? (i2[12] = t2.x, i2[13] = t2.y, i2[14] = t2.z) : (i2[12] = t2, i2[13] = e2, i2[14] = n2), this;
  }
  invert() {
    const t2 = this.elements, e2 = t2[0], n2 = t2[1], i2 = t2[2], r2 = t2[3], s2 = t2[4], a2 = t2[5], o2 = t2[6], l2 = t2[7], c2 = t2[8], h2 = t2[9], u2 = t2[10], d2 = t2[11], p2 = t2[12], m2 = t2[13], f2 = t2[14], g2 = t2[15], v2 = h2 * f2 * l2 - m2 * u2 * l2 + m2 * o2 * d2 - a2 * f2 * d2 - h2 * o2 * g2 + a2 * u2 * g2, y2 = p2 * u2 * l2 - c2 * f2 * l2 - p2 * o2 * d2 + s2 * f2 * d2 + c2 * o2 * g2 - s2 * u2 * g2, x2 = c2 * m2 * l2 - p2 * h2 * l2 + p2 * a2 * d2 - s2 * m2 * d2 - c2 * a2 * g2 + s2 * h2 * g2, b2 = p2 * h2 * o2 - c2 * m2 * o2 - p2 * a2 * u2 + s2 * m2 * u2 + c2 * a2 * f2 - s2 * h2 * f2, w2 = e2 * v2 + n2 * y2 + i2 * x2 + r2 * b2;
    if (w2 === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _2 = 1 / w2;
    return t2[0] = v2 * _2, t2[1] = (m2 * u2 * r2 - h2 * f2 * r2 - m2 * i2 * d2 + n2 * f2 * d2 + h2 * i2 * g2 - n2 * u2 * g2) * _2, t2[2] = (a2 * f2 * r2 - m2 * o2 * r2 + m2 * i2 * l2 - n2 * f2 * l2 - a2 * i2 * g2 + n2 * o2 * g2) * _2, t2[3] = (h2 * o2 * r2 - a2 * u2 * r2 - h2 * i2 * l2 + n2 * u2 * l2 + a2 * i2 * d2 - n2 * o2 * d2) * _2, t2[4] = y2 * _2, t2[5] = (c2 * f2 * r2 - p2 * u2 * r2 + p2 * i2 * d2 - e2 * f2 * d2 - c2 * i2 * g2 + e2 * u2 * g2) * _2, t2[6] = (p2 * o2 * r2 - s2 * f2 * r2 - p2 * i2 * l2 + e2 * f2 * l2 + s2 * i2 * g2 - e2 * o2 * g2) * _2, t2[7] = (s2 * u2 * r2 - c2 * o2 * r2 + c2 * i2 * l2 - e2 * u2 * l2 - s2 * i2 * d2 + e2 * o2 * d2) * _2, t2[8] = x2 * _2, t2[9] = (p2 * h2 * r2 - c2 * m2 * r2 - p2 * n2 * d2 + e2 * m2 * d2 + c2 * n2 * g2 - e2 * h2 * g2) * _2, t2[10] = (s2 * m2 * r2 - p2 * a2 * r2 + p2 * n2 * l2 - e2 * m2 * l2 - s2 * n2 * g2 + e2 * a2 * g2) * _2, t2[11] = (c2 * a2 * r2 - s2 * h2 * r2 - c2 * n2 * l2 + e2 * h2 * l2 + s2 * n2 * d2 - e2 * a2 * d2) * _2, t2[12] = b2 * _2, t2[13] = (c2 * m2 * i2 - p2 * h2 * i2 + p2 * n2 * u2 - e2 * m2 * u2 - c2 * n2 * f2 + e2 * h2 * f2) * _2, t2[14] = (p2 * a2 * i2 - s2 * m2 * i2 - p2 * n2 * o2 + e2 * m2 * o2 + s2 * n2 * f2 - e2 * a2 * f2) * _2, t2[15] = (s2 * h2 * i2 - c2 * a2 * i2 + c2 * n2 * o2 - e2 * h2 * o2 - s2 * n2 * u2 + e2 * a2 * u2) * _2, this;
  }
  scale(t2) {
    const e2 = this.elements, n2 = t2.x, i2 = t2.y, r2 = t2.z;
    return e2[0] *= n2, e2[4] *= i2, e2[8] *= r2, e2[1] *= n2, e2[5] *= i2, e2[9] *= r2, e2[2] *= n2, e2[6] *= i2, e2[10] *= r2, e2[3] *= n2, e2[7] *= i2, e2[11] *= r2, this;
  }
  getMaxScaleOnAxis() {
    const t2 = this.elements, e2 = t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2], n2 = t2[4] * t2[4] + t2[5] * t2[5] + t2[6] * t2[6], i2 = t2[8] * t2[8] + t2[9] * t2[9] + t2[10] * t2[10];
    return Math.sqrt(Math.max(e2, n2, i2));
  }
  makeTranslation(t2, e2, n2) {
    return this.set(1, 0, 0, t2, 0, 1, 0, e2, 0, 0, 1, n2, 0, 0, 0, 1), this;
  }
  makeRotationX(t2) {
    const e2 = Math.cos(t2), n2 = Math.sin(t2);
    return this.set(1, 0, 0, 0, 0, e2, -n2, 0, 0, n2, e2, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t2) {
    const e2 = Math.cos(t2), n2 = Math.sin(t2);
    return this.set(e2, 0, n2, 0, 0, 1, 0, 0, -n2, 0, e2, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t2) {
    const e2 = Math.cos(t2), n2 = Math.sin(t2);
    return this.set(e2, -n2, 0, 0, n2, e2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t2, e2) {
    const n2 = Math.cos(e2), i2 = Math.sin(e2), r2 = 1 - n2, s2 = t2.x, a2 = t2.y, o2 = t2.z, l2 = r2 * s2, c2 = r2 * a2;
    return this.set(l2 * s2 + n2, l2 * a2 - i2 * o2, l2 * o2 + i2 * a2, 0, l2 * a2 + i2 * o2, c2 * a2 + n2, c2 * o2 - i2 * s2, 0, l2 * o2 - i2 * a2, c2 * o2 + i2 * s2, r2 * o2 * o2 + n2, 0, 0, 0, 0, 1), this;
  }
  makeScale(t2, e2, n2) {
    return this.set(t2, 0, 0, 0, 0, e2, 0, 0, 0, 0, n2, 0, 0, 0, 0, 1), this;
  }
  makeShear(t2, e2, n2, i2, r2, s2) {
    return this.set(1, n2, r2, 0, t2, 1, s2, 0, e2, i2, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t2, e2, n2) {
    const i2 = this.elements, r2 = e2._x, s2 = e2._y, a2 = e2._z, o2 = e2._w, l2 = r2 + r2, c2 = s2 + s2, h2 = a2 + a2, u2 = r2 * l2, d2 = r2 * c2, p2 = r2 * h2, m2 = s2 * c2, f2 = s2 * h2, g2 = a2 * h2, v2 = o2 * l2, y2 = o2 * c2, x2 = o2 * h2, b2 = n2.x, w2 = n2.y, _2 = n2.z;
    return i2[0] = (1 - (m2 + g2)) * b2, i2[1] = (d2 + x2) * b2, i2[2] = (p2 - y2) * b2, i2[3] = 0, i2[4] = (d2 - x2) * w2, i2[5] = (1 - (u2 + g2)) * w2, i2[6] = (f2 + v2) * w2, i2[7] = 0, i2[8] = (p2 + y2) * _2, i2[9] = (f2 - v2) * _2, i2[10] = (1 - (u2 + m2)) * _2, i2[11] = 0, i2[12] = t2.x, i2[13] = t2.y, i2[14] = t2.z, i2[15] = 1, this;
  }
  decompose(t2, e2, n2) {
    const i2 = this.elements;
    let r2 = se.set(i2[0], i2[1], i2[2]).length();
    const s2 = se.set(i2[4], i2[5], i2[6]).length(), a2 = se.set(i2[8], i2[9], i2[10]).length();
    this.determinant() < 0 && (r2 = -r2), t2.x = i2[12], t2.y = i2[13], t2.z = i2[14], ae.copy(this);
    const o2 = 1 / r2, l2 = 1 / s2, c2 = 1 / a2;
    return ae.elements[0] *= o2, ae.elements[1] *= o2, ae.elements[2] *= o2, ae.elements[4] *= l2, ae.elements[5] *= l2, ae.elements[6] *= l2, ae.elements[8] *= c2, ae.elements[9] *= c2, ae.elements[10] *= c2, e2.setFromRotationMatrix(ae), n2.x = r2, n2.y = s2, n2.z = a2, this;
  }
  makePerspective(t2, e2, n2, i2, r2, s2) {
    s2 === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    const a2 = this.elements, o2 = 2 * r2 / (e2 - t2), l2 = 2 * r2 / (n2 - i2), c2 = (e2 + t2) / (e2 - t2), h2 = (n2 + i2) / (n2 - i2), u2 = -(s2 + r2) / (s2 - r2), d2 = -2 * s2 * r2 / (s2 - r2);
    return a2[0] = o2, a2[4] = 0, a2[8] = c2, a2[12] = 0, a2[1] = 0, a2[5] = l2, a2[9] = h2, a2[13] = 0, a2[2] = 0, a2[6] = 0, a2[10] = u2, a2[14] = d2, a2[3] = 0, a2[7] = 0, a2[11] = -1, a2[15] = 0, this;
  }
  makeOrthographic(t2, e2, n2, i2, r2, s2) {
    const a2 = this.elements, o2 = 1 / (e2 - t2), l2 = 1 / (n2 - i2), c2 = 1 / (s2 - r2), h2 = (e2 + t2) * o2, u2 = (n2 + i2) * l2, d2 = (s2 + r2) * c2;
    return a2[0] = 2 * o2, a2[4] = 0, a2[8] = 0, a2[12] = -h2, a2[1] = 0, a2[5] = 2 * l2, a2[9] = 0, a2[13] = -u2, a2[2] = 0, a2[6] = 0, a2[10] = -2 * c2, a2[14] = -d2, a2[3] = 0, a2[7] = 0, a2[11] = 0, a2[15] = 1, this;
  }
  equals(t2) {
    const e2 = this.elements, n2 = t2.elements;
    for (let t3 = 0; t3 < 16; t3++)
      if (e2[t3] !== n2[t3])
        return false;
    return true;
  }
  fromArray(t2, e2 = 0) {
    for (let n2 = 0; n2 < 16; n2++)
      this.elements[n2] = t2[n2 + e2];
    return this;
  }
  toArray(t2 = [], e2 = 0) {
    const n2 = this.elements;
    return t2[e2] = n2[0], t2[e2 + 1] = n2[1], t2[e2 + 2] = n2[2], t2[e2 + 3] = n2[3], t2[e2 + 4] = n2[4], t2[e2 + 5] = n2[5], t2[e2 + 6] = n2[6], t2[e2 + 7] = n2[7], t2[e2 + 8] = n2[8], t2[e2 + 9] = n2[9], t2[e2 + 10] = n2[10], t2[e2 + 11] = n2[11], t2[e2 + 12] = n2[12], t2[e2 + 13] = n2[13], t2[e2 + 14] = n2[14], t2[e2 + 15] = n2[15], t2;
  }
}
re.prototype.isMatrix4 = true;
const se = new At(), ae = new re(), oe = new At(0, 0, 0), le = new At(1, 1, 1), ce = new At(), he = new At(), ue = new At(), de = new re(), pe = new Et();
class me {
  constructor(t2 = 0, e2 = 0, n2 = 0, i2 = me.DefaultOrder) {
    this._x = t2, this._y = e2, this._z = n2, this._order = i2;
  }
  get x() {
    return this._x;
  }
  set x(t2) {
    this._x = t2, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t2) {
    this._y = t2, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t2) {
    this._z = t2, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t2) {
    this._order = t2, this._onChangeCallback();
  }
  set(t2, e2, n2, i2 = this._order) {
    return this._x = t2, this._y = e2, this._z = n2, this._order = i2, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t2) {
    return this._x = t2._x, this._y = t2._y, this._z = t2._z, this._order = t2._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t2, e2 = this._order, n2 = true) {
    const i2 = t2.elements, r2 = i2[0], s2 = i2[4], a2 = i2[8], o2 = i2[1], l2 = i2[5], c2 = i2[9], h2 = i2[2], u2 = i2[6], d2 = i2[10];
    switch (e2) {
      case "XYZ":
        this._y = Math.asin(ot(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-c2, d2), this._z = Math.atan2(-s2, r2)) : (this._x = Math.atan2(u2, l2), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-ot(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._y = Math.atan2(a2, d2), this._z = Math.atan2(o2, l2)) : (this._y = Math.atan2(-h2, r2), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(ot(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._y = Math.atan2(-h2, d2), this._z = Math.atan2(-s2, l2)) : (this._y = 0, this._z = Math.atan2(o2, r2));
        break;
      case "ZYX":
        this._y = Math.asin(-ot(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._x = Math.atan2(u2, d2), this._z = Math.atan2(o2, r2)) : (this._x = 0, this._z = Math.atan2(-s2, l2));
        break;
      case "YZX":
        this._z = Math.asin(ot(o2, -1, 1)), Math.abs(o2) < 0.9999999 ? (this._x = Math.atan2(-c2, l2), this._y = Math.atan2(-h2, r2)) : (this._x = 0, this._y = Math.atan2(a2, d2));
        break;
      case "XZY":
        this._z = Math.asin(-ot(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(u2, l2), this._y = Math.atan2(a2, r2)) : (this._x = Math.atan2(-c2, d2), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e2);
    }
    return this._order = e2, n2 === true && this._onChangeCallback(), this;
  }
  setFromQuaternion(t2, e2, n2) {
    return de.makeRotationFromQuaternion(t2), this.setFromRotationMatrix(de, e2, n2);
  }
  setFromVector3(t2, e2 = this._order) {
    return this.set(t2.x, t2.y, t2.z, e2);
  }
  reorder(t2) {
    return pe.setFromEuler(this), this.setFromQuaternion(pe, t2);
  }
  equals(t2) {
    return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._order === this._order;
  }
  fromArray(t2) {
    return this._x = t2[0], this._y = t2[1], this._z = t2[2], t2[3] !== void 0 && (this._order = t2[3]), this._onChangeCallback(), this;
  }
  toArray(t2 = [], e2 = 0) {
    return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._order, t2;
  }
  toVector3(t2) {
    return t2 ? t2.set(this._x, this._y, this._z) : new At(this._x, this._y, this._z);
  }
  _onChange(t2) {
    return this._onChangeCallback = t2, this;
  }
  _onChangeCallback() {
  }
}
me.prototype.isEuler = true, me.DefaultOrder = "XYZ", me.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class fe {
  constructor() {
    this.mask = 1;
  }
  set(t2) {
    this.mask = (1 << t2 | 0) >>> 0;
  }
  enable(t2) {
    this.mask |= 1 << t2 | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t2) {
    this.mask ^= 1 << t2 | 0;
  }
  disable(t2) {
    this.mask &= ~(1 << t2 | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t2) {
    return (this.mask & t2.mask) != 0;
  }
  isEnabled(t2) {
    return (this.mask & (1 << t2 | 0)) != 0;
  }
}
let ge = 0;
const ve = new At(), ye = new Et(), xe = new re(), be = new At(), we = new At(), _e = new At(), Me = new Et(), Se = new At(1, 0, 0), Te = new At(0, 1, 0), Ee = new At(0, 0, 1), Ae = { type: "added" }, Re = { type: "removed" };
class Le extends et {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: ge++ }), this.uuid = at(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Le.DefaultUp.clone();
    const t2 = new At(), e2 = new me(), n2 = new Et(), i2 = new At(1, 1, 1);
    e2._onChange(function() {
      n2.setFromEuler(e2, false);
    }), n2._onChange(function() {
      e2.setFromQuaternion(n2, void 0, false);
    }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t2 }, rotation: { configurable: true, enumerable: true, value: e2 }, quaternion: { configurable: true, enumerable: true, value: n2 }, scale: { configurable: true, enumerable: true, value: i2 }, modelViewMatrix: { value: new re() }, normalMatrix: { value: new ft() } }), this.matrix = new re(), this.matrixWorld = new re(), this.matrixAutoUpdate = Le.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new fe(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t2) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t2), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t2) {
    return this.quaternion.premultiply(t2), this;
  }
  setRotationFromAxisAngle(t2, e2) {
    this.quaternion.setFromAxisAngle(t2, e2);
  }
  setRotationFromEuler(t2) {
    this.quaternion.setFromEuler(t2, true);
  }
  setRotationFromMatrix(t2) {
    this.quaternion.setFromRotationMatrix(t2);
  }
  setRotationFromQuaternion(t2) {
    this.quaternion.copy(t2);
  }
  rotateOnAxis(t2, e2) {
    return ye.setFromAxisAngle(t2, e2), this.quaternion.multiply(ye), this;
  }
  rotateOnWorldAxis(t2, e2) {
    return ye.setFromAxisAngle(t2, e2), this.quaternion.premultiply(ye), this;
  }
  rotateX(t2) {
    return this.rotateOnAxis(Se, t2);
  }
  rotateY(t2) {
    return this.rotateOnAxis(Te, t2);
  }
  rotateZ(t2) {
    return this.rotateOnAxis(Ee, t2);
  }
  translateOnAxis(t2, e2) {
    return ve.copy(t2).applyQuaternion(this.quaternion), this.position.add(ve.multiplyScalar(e2)), this;
  }
  translateX(t2) {
    return this.translateOnAxis(Se, t2);
  }
  translateY(t2) {
    return this.translateOnAxis(Te, t2);
  }
  translateZ(t2) {
    return this.translateOnAxis(Ee, t2);
  }
  localToWorld(t2) {
    return t2.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t2) {
    return t2.applyMatrix4(xe.copy(this.matrixWorld).invert());
  }
  lookAt(t2, e2, n2) {
    t2.isVector3 ? be.copy(t2) : be.set(t2, e2, n2);
    const i2 = this.parent;
    this.updateWorldMatrix(true, false), we.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? xe.lookAt(we, be, this.up) : xe.lookAt(be, we, this.up), this.quaternion.setFromRotationMatrix(xe), i2 && (xe.extractRotation(i2.matrixWorld), ye.setFromRotationMatrix(xe), this.quaternion.premultiply(ye.invert()));
  }
  add(t2) {
    if (arguments.length > 1) {
      for (let t3 = 0; t3 < arguments.length; t3++)
        this.add(arguments[t3]);
      return this;
    }
    return t2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t2), this) : (t2 && t2.isObject3D ? (t2.parent !== null && t2.parent.remove(t2), t2.parent = this, this.children.push(t2), t2.dispatchEvent(Ae)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t2), this);
  }
  remove(t2) {
    if (arguments.length > 1) {
      for (let t3 = 0; t3 < arguments.length; t3++)
        this.remove(arguments[t3]);
      return this;
    }
    const e2 = this.children.indexOf(t2);
    return e2 !== -1 && (t2.parent = null, this.children.splice(e2, 1), t2.dispatchEvent(Re)), this;
  }
  removeFromParent() {
    const t2 = this.parent;
    return t2 !== null && t2.remove(this), this;
  }
  clear() {
    for (let t2 = 0; t2 < this.children.length; t2++) {
      const e2 = this.children[t2];
      e2.parent = null, e2.dispatchEvent(Re);
    }
    return this.children.length = 0, this;
  }
  attach(t2) {
    return this.updateWorldMatrix(true, false), xe.copy(this.matrixWorld).invert(), t2.parent !== null && (t2.parent.updateWorldMatrix(true, false), xe.multiply(t2.parent.matrixWorld)), t2.applyMatrix4(xe), this.add(t2), t2.updateWorldMatrix(false, true), this;
  }
  getObjectById(t2) {
    return this.getObjectByProperty("id", t2);
  }
  getObjectByName(t2) {
    return this.getObjectByProperty("name", t2);
  }
  getObjectByProperty(t2, e2) {
    if (this[t2] === e2)
      return this;
    for (let n2 = 0, i2 = this.children.length; n2 < i2; n2++) {
      const i3 = this.children[n2].getObjectByProperty(t2, e2);
      if (i3 !== void 0)
        return i3;
    }
  }
  getWorldPosition(t2) {
    return this.updateWorldMatrix(true, false), t2.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t2) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(we, t2, _e), t2;
  }
  getWorldScale(t2) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(we, Me, t2), t2;
  }
  getWorldDirection(t2) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return t2.set(e2[8], e2[9], e2[10]).normalize();
  }
  raycast() {
  }
  traverse(t2) {
    t2(this);
    const e2 = this.children;
    for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
      e2[n2].traverse(t2);
  }
  traverseVisible(t2) {
    if (this.visible === false)
      return;
    t2(this);
    const e2 = this.children;
    for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
      e2[n2].traverseVisible(t2);
  }
  traverseAncestors(t2) {
    const e2 = this.parent;
    e2 !== null && (t2(e2), e2.traverseAncestors(t2));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(t2) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t2) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t2 = true);
    const e2 = this.children;
    for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
      e2[n2].updateMatrixWorld(t2);
  }
  updateWorldMatrix(t2, e2) {
    const n2 = this.parent;
    if (t2 === true && n2 !== null && n2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e2 === true) {
      const t3 = this.children;
      for (let e3 = 0, n3 = t3.length; e3 < n3; e3++)
        t3[e3].updateWorldMatrix(false, true);
    }
  }
  toJSON(t2) {
    const e2 = t2 === void 0 || typeof t2 == "string", n2 = {};
    e2 && (t2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
    const i2 = {};
    function r2(e3, n3) {
      return e3[n3.uuid] === void 0 && (e3[n3.uuid] = n3.toJSON(t2)), n3.uuid;
    }
    if (i2.uuid = this.uuid, i2.type = this.type, this.name !== "" && (i2.name = this.name), this.castShadow === true && (i2.castShadow = true), this.receiveShadow === true && (i2.receiveShadow = true), this.visible === false && (i2.visible = false), this.frustumCulled === false && (i2.frustumCulled = false), this.renderOrder !== 0 && (i2.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (i2.userData = this.userData), i2.layers = this.layers.mask, i2.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (i2.matrixAutoUpdate = false), this.isInstancedMesh && (i2.type = "InstancedMesh", i2.count = this.count, i2.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i2.instanceColor = this.instanceColor.toJSON())), this.isScene)
      this.background && (this.background.isColor ? i2.background = this.background.toJSON() : this.background.isTexture && (i2.background = this.background.toJSON(t2).uuid)), this.environment && this.environment.isTexture && (i2.environment = this.environment.toJSON(t2).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i2.geometry = r2(t2.geometries, this.geometry);
      const e3 = this.geometry.parameters;
      if (e3 !== void 0 && e3.shapes !== void 0) {
        const n3 = e3.shapes;
        if (Array.isArray(n3))
          for (let e4 = 0, i3 = n3.length; e4 < i3; e4++) {
            const i4 = n3[e4];
            r2(t2.shapes, i4);
          }
        else
          r2(t2.shapes, n3);
      }
    }
    if (this.isSkinnedMesh && (i2.bindMode = this.bindMode, i2.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r2(t2.skeletons, this.skeleton), i2.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const e3 = [];
        for (let n3 = 0, i3 = this.material.length; n3 < i3; n3++)
          e3.push(r2(t2.materials, this.material[n3]));
        i2.material = e3;
      } else
        i2.material = r2(t2.materials, this.material);
    if (this.children.length > 0) {
      i2.children = [];
      for (let e3 = 0; e3 < this.children.length; e3++)
        i2.children.push(this.children[e3].toJSON(t2).object);
    }
    if (this.animations.length > 0) {
      i2.animations = [];
      for (let e3 = 0; e3 < this.animations.length; e3++) {
        const n3 = this.animations[e3];
        i2.animations.push(r2(t2.animations, n3));
      }
    }
    if (e2) {
      const e3 = s2(t2.geometries), i3 = s2(t2.materials), r3 = s2(t2.textures), a2 = s2(t2.images), o2 = s2(t2.shapes), l2 = s2(t2.skeletons), c2 = s2(t2.animations);
      e3.length > 0 && (n2.geometries = e3), i3.length > 0 && (n2.materials = i3), r3.length > 0 && (n2.textures = r3), a2.length > 0 && (n2.images = a2), o2.length > 0 && (n2.shapes = o2), l2.length > 0 && (n2.skeletons = l2), c2.length > 0 && (n2.animations = c2);
    }
    return n2.object = i2, n2;
    function s2(t3) {
      const e3 = [];
      for (const n3 in t3) {
        const i3 = t3[n3];
        delete i3.metadata, e3.push(i3);
      }
      return e3;
    }
  }
  clone(t2) {
    return new this.constructor().copy(this, t2);
  }
  copy(t2, e2 = true) {
    if (this.name = t2.name, this.up.copy(t2.up), this.position.copy(t2.position), this.rotation.order = t2.rotation.order, this.quaternion.copy(t2.quaternion), this.scale.copy(t2.scale), this.matrix.copy(t2.matrix), this.matrixWorld.copy(t2.matrixWorld), this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t2.matrixWorldNeedsUpdate, this.layers.mask = t2.layers.mask, this.visible = t2.visible, this.castShadow = t2.castShadow, this.receiveShadow = t2.receiveShadow, this.frustumCulled = t2.frustumCulled, this.renderOrder = t2.renderOrder, this.userData = JSON.parse(JSON.stringify(t2.userData)), e2 === true)
      for (let e3 = 0; e3 < t2.children.length; e3++) {
        const n2 = t2.children[e3];
        this.add(n2.clone());
      }
    return this;
  }
}
Le.DefaultUp = new At(0, 1, 0), Le.DefaultMatrixAutoUpdate = true, Le.prototype.isObject3D = true;
const Ce = new At(), Pe = new At(), Ie = new At(), De = new At(), Ne = new At(), Fe = new At(), Oe = new At(), Ue = new At(), ke = new At(), ze = new At();
class Be {
  constructor(t2 = new At(), e2 = new At(), n2 = new At()) {
    this.a = t2, this.b = e2, this.c = n2;
  }
  static getNormal(t2, e2, n2, i2) {
    i2.subVectors(n2, e2), Ce.subVectors(t2, e2), i2.cross(Ce);
    const r2 = i2.lengthSq();
    return r2 > 0 ? i2.multiplyScalar(1 / Math.sqrt(r2)) : i2.set(0, 0, 0);
  }
  static getBarycoord(t2, e2, n2, i2, r2) {
    Ce.subVectors(i2, e2), Pe.subVectors(n2, e2), Ie.subVectors(t2, e2);
    const s2 = Ce.dot(Ce), a2 = Ce.dot(Pe), o2 = Ce.dot(Ie), l2 = Pe.dot(Pe), c2 = Pe.dot(Ie), h2 = s2 * l2 - a2 * a2;
    if (h2 === 0)
      return r2.set(-2, -1, -1);
    const u2 = 1 / h2, d2 = (l2 * o2 - a2 * c2) * u2, p2 = (s2 * c2 - a2 * o2) * u2;
    return r2.set(1 - d2 - p2, p2, d2);
  }
  static containsPoint(t2, e2, n2, i2) {
    return this.getBarycoord(t2, e2, n2, i2, De), De.x >= 0 && De.y >= 0 && De.x + De.y <= 1;
  }
  static getUV(t2, e2, n2, i2, r2, s2, a2, o2) {
    return this.getBarycoord(t2, e2, n2, i2, De), o2.set(0, 0), o2.addScaledVector(r2, De.x), o2.addScaledVector(s2, De.y), o2.addScaledVector(a2, De.z), o2;
  }
  static isFrontFacing(t2, e2, n2, i2) {
    return Ce.subVectors(n2, e2), Pe.subVectors(t2, e2), Ce.cross(Pe).dot(i2) < 0;
  }
  set(t2, e2, n2) {
    return this.a.copy(t2), this.b.copy(e2), this.c.copy(n2), this;
  }
  setFromPointsAndIndices(t2, e2, n2, i2) {
    return this.a.copy(t2[e2]), this.b.copy(t2[n2]), this.c.copy(t2[i2]), this;
  }
  setFromAttributeAndIndices(t2, e2, n2, i2) {
    return this.a.fromBufferAttribute(t2, e2), this.b.fromBufferAttribute(t2, n2), this.c.fromBufferAttribute(t2, i2), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t2) {
    return this.a.copy(t2.a), this.b.copy(t2.b), this.c.copy(t2.c), this;
  }
  getArea() {
    return Ce.subVectors(this.c, this.b), Pe.subVectors(this.a, this.b), 0.5 * Ce.cross(Pe).length();
  }
  getMidpoint(t2) {
    return t2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t2) {
    return Be.getNormal(this.a, this.b, this.c, t2);
  }
  getPlane(t2) {
    return t2.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t2, e2) {
    return Be.getBarycoord(t2, this.a, this.b, this.c, e2);
  }
  getUV(t2, e2, n2, i2, r2) {
    return Be.getUV(t2, this.a, this.b, this.c, e2, n2, i2, r2);
  }
  containsPoint(t2) {
    return Be.containsPoint(t2, this.a, this.b, this.c);
  }
  isFrontFacing(t2) {
    return Be.isFrontFacing(this.a, this.b, this.c, t2);
  }
  intersectsBox(t2) {
    return t2.intersectsTriangle(this);
  }
  closestPointToPoint(t2, e2) {
    const n2 = this.a, i2 = this.b, r2 = this.c;
    let s2, a2;
    Ne.subVectors(i2, n2), Fe.subVectors(r2, n2), Ue.subVectors(t2, n2);
    const o2 = Ne.dot(Ue), l2 = Fe.dot(Ue);
    if (o2 <= 0 && l2 <= 0)
      return e2.copy(n2);
    ke.subVectors(t2, i2);
    const c2 = Ne.dot(ke), h2 = Fe.dot(ke);
    if (c2 >= 0 && h2 <= c2)
      return e2.copy(i2);
    const u2 = o2 * h2 - c2 * l2;
    if (u2 <= 0 && o2 >= 0 && c2 <= 0)
      return s2 = o2 / (o2 - c2), e2.copy(n2).addScaledVector(Ne, s2);
    ze.subVectors(t2, r2);
    const d2 = Ne.dot(ze), p2 = Fe.dot(ze);
    if (p2 >= 0 && d2 <= p2)
      return e2.copy(r2);
    const m2 = d2 * l2 - o2 * p2;
    if (m2 <= 0 && l2 >= 0 && p2 <= 0)
      return a2 = l2 / (l2 - p2), e2.copy(n2).addScaledVector(Fe, a2);
    const f2 = c2 * p2 - d2 * h2;
    if (f2 <= 0 && h2 - c2 >= 0 && d2 - p2 >= 0)
      return Oe.subVectors(r2, i2), a2 = (h2 - c2) / (h2 - c2 + (d2 - p2)), e2.copy(i2).addScaledVector(Oe, a2);
    const g2 = 1 / (f2 + m2 + u2);
    return s2 = m2 * g2, a2 = u2 * g2, e2.copy(n2).addScaledVector(Ne, s2).addScaledVector(Fe, a2);
  }
  equals(t2) {
    return t2.a.equals(this.a) && t2.b.equals(this.b) && t2.c.equals(this.c);
  }
}
let He = 0;
class Ve extends et {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: He++ }), this.uuid = at(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.format = 1023, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t2) {
    this._alphaTest > 0 != t2 > 0 && this.version++, this._alphaTest = t2;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t2) {
    if (t2 !== void 0)
      for (const e2 in t2) {
        const n2 = t2[e2];
        if (n2 === void 0) {
          console.warn("THREE.Material: '" + e2 + "' parameter is undefined.");
          continue;
        }
        if (e2 === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n2 === 1;
          continue;
        }
        const i2 = this[e2];
        i2 !== void 0 ? i2 && i2.isColor ? i2.set(n2) : i2 && i2.isVector3 && n2 && n2.isVector3 ? i2.copy(n2) : this[e2] = n2 : console.warn("THREE." + this.type + ": '" + e2 + "' is not a property of this material.");
      }
  }
  toJSON(t2) {
    const e2 = t2 === void 0 || typeof t2 == "string";
    e2 && (t2 = { textures: {}, images: {} });
    const n2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
    function i2(t3) {
      const e3 = [];
      for (const n3 in t3) {
        const i3 = t3[n3];
        delete i3.metadata, e3.push(i3);
      }
      return e3;
    }
    if (n2.uuid = this.uuid, n2.type = this.type, this.name !== "" && (n2.name = this.name), this.color && this.color.isColor && (n2.color = this.color.getHex()), this.roughness !== void 0 && (n2.roughness = this.roughness), this.metalness !== void 0 && (n2.metalness = this.metalness), this.sheen !== void 0 && (n2.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n2.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n2.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n2.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n2.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n2.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n2.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n2.shininess = this.shininess), this.clearcoat !== void 0 && (n2.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n2.clearcoatMap = this.clearcoatMap.toJSON(t2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t2).uuid, n2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n2.map = this.map.toJSON(t2).uuid), this.matcap && this.matcap.isTexture && (n2.matcap = this.matcap.toJSON(t2).uuid), this.alphaMap && this.alphaMap.isTexture && (n2.alphaMap = this.alphaMap.toJSON(t2).uuid), this.lightMap && this.lightMap.isTexture && (n2.lightMap = this.lightMap.toJSON(t2).uuid, n2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n2.aoMap = this.aoMap.toJSON(t2).uuid, n2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n2.bumpMap = this.bumpMap.toJSON(t2).uuid, n2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n2.normalMap = this.normalMap.toJSON(t2).uuid, n2.normalMapType = this.normalMapType, n2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n2.displacementMap = this.displacementMap.toJSON(t2).uuid, n2.displacementScale = this.displacementScale, n2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n2.roughnessMap = this.roughnessMap.toJSON(t2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n2.metalnessMap = this.metalnessMap.toJSON(t2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n2.emissiveMap = this.emissiveMap.toJSON(t2).uuid), this.specularMap && this.specularMap.isTexture && (n2.specularMap = this.specularMap.toJSON(t2).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n2.specularIntensityMap = this.specularIntensityMap.toJSON(t2).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n2.specularColorMap = this.specularColorMap.toJSON(t2).uuid), this.envMap && this.envMap.isTexture && (n2.envMap = this.envMap.toJSON(t2).uuid, this.combine !== void 0 && (n2.combine = this.combine)), this.envMapIntensity !== void 0 && (n2.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n2.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n2.gradientMap = this.gradientMap.toJSON(t2).uuid), this.transmission !== void 0 && (n2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n2.transmissionMap = this.transmissionMap.toJSON(t2).uuid), this.thickness !== void 0 && (n2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n2.thicknessMap = this.thicknessMap.toJSON(t2).uuid), this.attenuationDistance !== void 0 && (n2.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n2.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n2.size = this.size), this.shadowSide !== null && (n2.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n2.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n2.blending = this.blending), this.side !== 0 && (n2.side = this.side), this.vertexColors && (n2.vertexColors = true), this.opacity < 1 && (n2.opacity = this.opacity), this.format !== 1023 && (n2.format = this.format), this.transparent === true && (n2.transparent = this.transparent), n2.depthFunc = this.depthFunc, n2.depthTest = this.depthTest, n2.depthWrite = this.depthWrite, n2.colorWrite = this.colorWrite, n2.stencilWrite = this.stencilWrite, n2.stencilWriteMask = this.stencilWriteMask, n2.stencilFunc = this.stencilFunc, n2.stencilRef = this.stencilRef, n2.stencilFuncMask = this.stencilFuncMask, n2.stencilFail = this.stencilFail, n2.stencilZFail = this.stencilZFail, n2.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (n2.rotation = this.rotation), this.polygonOffset === true && (n2.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n2.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n2.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (n2.linewidth = this.linewidth), this.dashSize !== void 0 && (n2.dashSize = this.dashSize), this.gapSize !== void 0 && (n2.gapSize = this.gapSize), this.scale !== void 0 && (n2.scale = this.scale), this.dithering === true && (n2.dithering = true), this.alphaTest > 0 && (n2.alphaTest = this.alphaTest), this.alphaToCoverage === true && (n2.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === true && (n2.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === true && (n2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n2.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n2.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n2.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (n2.flatShading = this.flatShading), this.visible === false && (n2.visible = false), this.toneMapped === false && (n2.toneMapped = false), JSON.stringify(this.userData) !== "{}" && (n2.userData = this.userData), e2) {
      const e3 = i2(t2.textures), r2 = i2(t2.images);
      e3.length > 0 && (n2.textures = e3), r2.length > 0 && (n2.images = r2);
    }
    return n2;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t2) {
    this.name = t2.name, this.fog = t2.fog, this.blending = t2.blending, this.side = t2.side, this.vertexColors = t2.vertexColors, this.opacity = t2.opacity, this.format = t2.format, this.transparent = t2.transparent, this.blendSrc = t2.blendSrc, this.blendDst = t2.blendDst, this.blendEquation = t2.blendEquation, this.blendSrcAlpha = t2.blendSrcAlpha, this.blendDstAlpha = t2.blendDstAlpha, this.blendEquationAlpha = t2.blendEquationAlpha, this.depthFunc = t2.depthFunc, this.depthTest = t2.depthTest, this.depthWrite = t2.depthWrite, this.stencilWriteMask = t2.stencilWriteMask, this.stencilFunc = t2.stencilFunc, this.stencilRef = t2.stencilRef, this.stencilFuncMask = t2.stencilFuncMask, this.stencilFail = t2.stencilFail, this.stencilZFail = t2.stencilZFail, this.stencilZPass = t2.stencilZPass, this.stencilWrite = t2.stencilWrite;
    const e2 = t2.clippingPlanes;
    let n2 = null;
    if (e2 !== null) {
      const t3 = e2.length;
      n2 = new Array(t3);
      for (let i2 = 0; i2 !== t3; ++i2)
        n2[i2] = e2[i2].clone();
    }
    return this.clippingPlanes = n2, this.clipIntersection = t2.clipIntersection, this.clipShadows = t2.clipShadows, this.shadowSide = t2.shadowSide, this.colorWrite = t2.colorWrite, this.precision = t2.precision, this.polygonOffset = t2.polygonOffset, this.polygonOffsetFactor = t2.polygonOffsetFactor, this.polygonOffsetUnits = t2.polygonOffsetUnits, this.dithering = t2.dithering, this.alphaTest = t2.alphaTest, this.alphaToCoverage = t2.alphaToCoverage, this.premultipliedAlpha = t2.premultipliedAlpha, this.visible = t2.visible, this.toneMapped = t2.toneMapped, this.userData = JSON.parse(JSON.stringify(t2.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t2) {
    t2 === true && this.version++;
  }
}
Ve.prototype.isMaterial = true;
const Ge = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, We = { h: 0, s: 0, l: 0 }, je = { h: 0, s: 0, l: 0 };
function qe(t2, e2, n2) {
  return n2 < 0 && (n2 += 1), n2 > 1 && (n2 -= 1), n2 < 1 / 6 ? t2 + 6 * (e2 - t2) * n2 : n2 < 0.5 ? e2 : n2 < 2 / 3 ? t2 + 6 * (e2 - t2) * (2 / 3 - n2) : t2;
}
function Xe(t2) {
  return t2 < 0.04045 ? 0.0773993808 * t2 : Math.pow(0.9478672986 * t2 + 0.0521327014, 2.4);
}
function Ye(t2) {
  return t2 < 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 0.41666) - 0.055;
}
class Ze {
  constructor(t2, e2, n2) {
    return e2 === void 0 && n2 === void 0 ? this.set(t2) : this.setRGB(t2, e2, n2);
  }
  set(t2) {
    return t2 && t2.isColor ? this.copy(t2) : typeof t2 == "number" ? this.setHex(t2) : typeof t2 == "string" && this.setStyle(t2), this;
  }
  setScalar(t2) {
    return this.r = t2, this.g = t2, this.b = t2, this;
  }
  setHex(t2) {
    return t2 = Math.floor(t2), this.r = (t2 >> 16 & 255) / 255, this.g = (t2 >> 8 & 255) / 255, this.b = (255 & t2) / 255, this;
  }
  setRGB(t2, e2, n2) {
    return this.r = t2, this.g = e2, this.b = n2, this;
  }
  setHSL(t2, e2, n2) {
    if (t2 = lt(t2, 1), e2 = ot(e2, 0, 1), n2 = ot(n2, 0, 1), e2 === 0)
      this.r = this.g = this.b = n2;
    else {
      const i2 = n2 <= 0.5 ? n2 * (1 + e2) : n2 + e2 - n2 * e2, r2 = 2 * n2 - i2;
      this.r = qe(r2, i2, t2 + 1 / 3), this.g = qe(r2, i2, t2), this.b = qe(r2, i2, t2 - 1 / 3);
    }
    return this;
  }
  setStyle(t2) {
    function e2(e3) {
      e3 !== void 0 && parseFloat(e3) < 1 && console.warn("THREE.Color: Alpha component of " + t2 + " will be ignored.");
    }
    let n2;
    if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t2)) {
      let t3;
      const i2 = n2[1], r2 = n2[2];
      switch (i2) {
        case "rgb":
        case "rgba":
          if (t3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2))
            return this.r = Math.min(255, parseInt(t3[1], 10)) / 255, this.g = Math.min(255, parseInt(t3[2], 10)) / 255, this.b = Math.min(255, parseInt(t3[3], 10)) / 255, e2(t3[4]), this;
          if (t3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2))
            return this.r = Math.min(100, parseInt(t3[1], 10)) / 100, this.g = Math.min(100, parseInt(t3[2], 10)) / 100, this.b = Math.min(100, parseInt(t3[3], 10)) / 100, e2(t3[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (t3 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) {
            const n3 = parseFloat(t3[1]) / 360, i3 = parseInt(t3[2], 10) / 100, r3 = parseInt(t3[3], 10) / 100;
            return e2(t3[4]), this.setHSL(n3, i3, r3);
          }
      }
    } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(t2)) {
      const t3 = n2[1], e3 = t3.length;
      if (e3 === 3)
        return this.r = parseInt(t3.charAt(0) + t3.charAt(0), 16) / 255, this.g = parseInt(t3.charAt(1) + t3.charAt(1), 16) / 255, this.b = parseInt(t3.charAt(2) + t3.charAt(2), 16) / 255, this;
      if (e3 === 6)
        return this.r = parseInt(t3.charAt(0) + t3.charAt(1), 16) / 255, this.g = parseInt(t3.charAt(2) + t3.charAt(3), 16) / 255, this.b = parseInt(t3.charAt(4) + t3.charAt(5), 16) / 255, this;
    }
    return t2 && t2.length > 0 ? this.setColorName(t2) : this;
  }
  setColorName(t2) {
    const e2 = Ge[t2.toLowerCase()];
    return e2 !== void 0 ? this.setHex(e2) : console.warn("THREE.Color: Unknown color " + t2), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t2) {
    return this.r = t2.r, this.g = t2.g, this.b = t2.b, this;
  }
  copySRGBToLinear(t2) {
    return this.r = Xe(t2.r), this.g = Xe(t2.g), this.b = Xe(t2.b), this;
  }
  copyLinearToSRGB(t2) {
    return this.r = Ye(t2.r), this.g = Ye(t2.g), this.b = Ye(t2.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(t2) {
    const e2 = this.r, n2 = this.g, i2 = this.b, r2 = Math.max(e2, n2, i2), s2 = Math.min(e2, n2, i2);
    let a2, o2;
    const l2 = (s2 + r2) / 2;
    if (s2 === r2)
      a2 = 0, o2 = 0;
    else {
      const t3 = r2 - s2;
      switch (o2 = l2 <= 0.5 ? t3 / (r2 + s2) : t3 / (2 - r2 - s2), r2) {
        case e2:
          a2 = (n2 - i2) / t3 + (n2 < i2 ? 6 : 0);
          break;
        case n2:
          a2 = (i2 - e2) / t3 + 2;
          break;
        case i2:
          a2 = (e2 - n2) / t3 + 4;
      }
      a2 /= 6;
    }
    return t2.h = a2, t2.s = o2, t2.l = l2, t2;
  }
  getStyle() {
    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
  }
  offsetHSL(t2, e2, n2) {
    return this.getHSL(We), We.h += t2, We.s += e2, We.l += n2, this.setHSL(We.h, We.s, We.l), this;
  }
  add(t2) {
    return this.r += t2.r, this.g += t2.g, this.b += t2.b, this;
  }
  addColors(t2, e2) {
    return this.r = t2.r + e2.r, this.g = t2.g + e2.g, this.b = t2.b + e2.b, this;
  }
  addScalar(t2) {
    return this.r += t2, this.g += t2, this.b += t2, this;
  }
  sub(t2) {
    return this.r = Math.max(0, this.r - t2.r), this.g = Math.max(0, this.g - t2.g), this.b = Math.max(0, this.b - t2.b), this;
  }
  multiply(t2) {
    return this.r *= t2.r, this.g *= t2.g, this.b *= t2.b, this;
  }
  multiplyScalar(t2) {
    return this.r *= t2, this.g *= t2, this.b *= t2, this;
  }
  lerp(t2, e2) {
    return this.r += (t2.r - this.r) * e2, this.g += (t2.g - this.g) * e2, this.b += (t2.b - this.b) * e2, this;
  }
  lerpColors(t2, e2, n2) {
    return this.r = t2.r + (e2.r - t2.r) * n2, this.g = t2.g + (e2.g - t2.g) * n2, this.b = t2.b + (e2.b - t2.b) * n2, this;
  }
  lerpHSL(t2, e2) {
    this.getHSL(We), t2.getHSL(je);
    const n2 = ct(We.h, je.h, e2), i2 = ct(We.s, je.s, e2), r2 = ct(We.l, je.l, e2);
    return this.setHSL(n2, i2, r2), this;
  }
  equals(t2) {
    return t2.r === this.r && t2.g === this.g && t2.b === this.b;
  }
  fromArray(t2, e2 = 0) {
    return this.r = t2[e2], this.g = t2[e2 + 1], this.b = t2[e2 + 2], this;
  }
  toArray(t2 = [], e2 = 0) {
    return t2[e2] = this.r, t2[e2 + 1] = this.g, t2[e2 + 2] = this.b, t2;
  }
  fromBufferAttribute(t2, e2) {
    return this.r = t2.getX(e2), this.g = t2.getY(e2), this.b = t2.getZ(e2), t2.normalized === true && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
}
Ze.NAMES = Ge, Ze.prototype.isColor = true, Ze.prototype.r = 1, Ze.prototype.g = 1, Ze.prototype.b = 1;
class Je extends Ve {
  constructor(t2) {
    super(), this.type = "MeshBasicMaterial", this.color = new Ze(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this;
  }
}
Je.prototype.isMeshBasicMaterial = true;
const $e = new At(), Ke = new mt();
class Qe {
  constructor(t2, e2, n2) {
    if (Array.isArray(t2))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.name = "", this.array = t2, this.itemSize = e2, this.count = t2 !== void 0 ? t2.length / e2 : 0, this.normalized = n2 === true, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t2) {
    t2 === true && this.version++;
  }
  setUsage(t2) {
    return this.usage = t2, this;
  }
  copy(t2) {
    return this.name = t2.name, this.array = new t2.array.constructor(t2.array), this.itemSize = t2.itemSize, this.count = t2.count, this.normalized = t2.normalized, this.usage = t2.usage, this;
  }
  copyAt(t2, e2, n2) {
    t2 *= this.itemSize, n2 *= e2.itemSize;
    for (let i2 = 0, r2 = this.itemSize; i2 < r2; i2++)
      this.array[t2 + i2] = e2.array[n2 + i2];
    return this;
  }
  copyArray(t2) {
    return this.array.set(t2), this;
  }
  copyColorsArray(t2) {
    const e2 = this.array;
    let n2 = 0;
    for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
      let r3 = t2[i2];
      r3 === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2), r3 = new Ze()), e2[n2++] = r3.r, e2[n2++] = r3.g, e2[n2++] = r3.b;
    }
    return this;
  }
  copyVector2sArray(t2) {
    const e2 = this.array;
    let n2 = 0;
    for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
      let r3 = t2[i2];
      r3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2), r3 = new mt()), e2[n2++] = r3.x, e2[n2++] = r3.y;
    }
    return this;
  }
  copyVector3sArray(t2) {
    const e2 = this.array;
    let n2 = 0;
    for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
      let r3 = t2[i2];
      r3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2), r3 = new At()), e2[n2++] = r3.x, e2[n2++] = r3.y, e2[n2++] = r3.z;
    }
    return this;
  }
  copyVector4sArray(t2) {
    const e2 = this.array;
    let n2 = 0;
    for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
      let r3 = t2[i2];
      r3 === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2), r3 = new Mt()), e2[n2++] = r3.x, e2[n2++] = r3.y, e2[n2++] = r3.z, e2[n2++] = r3.w;
    }
    return this;
  }
  applyMatrix3(t2) {
    if (this.itemSize === 2)
      for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
        Ke.fromBufferAttribute(this, e2), Ke.applyMatrix3(t2), this.setXY(e2, Ke.x, Ke.y);
    else if (this.itemSize === 3)
      for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
        $e.fromBufferAttribute(this, e2), $e.applyMatrix3(t2), this.setXYZ(e2, $e.x, $e.y, $e.z);
    return this;
  }
  applyMatrix4(t2) {
    for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
      $e.x = this.getX(e2), $e.y = this.getY(e2), $e.z = this.getZ(e2), $e.applyMatrix4(t2), this.setXYZ(e2, $e.x, $e.y, $e.z);
    return this;
  }
  applyNormalMatrix(t2) {
    for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
      $e.x = this.getX(e2), $e.y = this.getY(e2), $e.z = this.getZ(e2), $e.applyNormalMatrix(t2), this.setXYZ(e2, $e.x, $e.y, $e.z);
    return this;
  }
  transformDirection(t2) {
    for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
      $e.x = this.getX(e2), $e.y = this.getY(e2), $e.z = this.getZ(e2), $e.transformDirection(t2), this.setXYZ(e2, $e.x, $e.y, $e.z);
    return this;
  }
  set(t2, e2 = 0) {
    return this.array.set(t2, e2), this;
  }
  getX(t2) {
    return this.array[t2 * this.itemSize];
  }
  setX(t2, e2) {
    return this.array[t2 * this.itemSize] = e2, this;
  }
  getY(t2) {
    return this.array[t2 * this.itemSize + 1];
  }
  setY(t2, e2) {
    return this.array[t2 * this.itemSize + 1] = e2, this;
  }
  getZ(t2) {
    return this.array[t2 * this.itemSize + 2];
  }
  setZ(t2, e2) {
    return this.array[t2 * this.itemSize + 2] = e2, this;
  }
  getW(t2) {
    return this.array[t2 * this.itemSize + 3];
  }
  setW(t2, e2) {
    return this.array[t2 * this.itemSize + 3] = e2, this;
  }
  setXY(t2, e2, n2) {
    return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this;
  }
  setXYZ(t2, e2, n2, i2) {
    return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this.array[t2 + 2] = i2, this;
  }
  setXYZW(t2, e2, n2, i2, r2) {
    return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this.array[t2 + 2] = i2, this.array[t2 + 3] = r2, this;
  }
  onUpload(t2) {
    return this.onUploadCallback = t2, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
    return this.name !== "" && (t2.name = this.name), this.usage !== 35044 && (t2.usage = this.usage), this.updateRange.offset === 0 && this.updateRange.count === -1 || (t2.updateRange = this.updateRange), t2;
  }
}
Qe.prototype.isBufferAttribute = true;
class tn extends Qe {
  constructor(t2, e2, n2) {
    super(new Uint16Array(t2), e2, n2);
  }
}
class en extends Qe {
  constructor(t2, e2, n2) {
    super(new Uint32Array(t2), e2, n2);
  }
}
(class extends Qe {
  constructor(t2, e2, n2) {
    super(new Uint16Array(t2), e2, n2);
  }
}).prototype.isFloat16BufferAttribute = true;
class nn extends Qe {
  constructor(t2, e2, n2) {
    super(new Float32Array(t2), e2, n2);
  }
}
let rn = 0;
const sn = new re(), an = new Le(), on = new At(), ln = new Ct(), cn = new Ct(), hn = new At();
class un extends et {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: rn++ }), this.uuid = at(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t2) {
    return Array.isArray(t2) ? this.index = new (gt(t2) > 65535 ? en : tn)(t2, 1) : this.index = t2, this;
  }
  getAttribute(t2) {
    return this.attributes[t2];
  }
  setAttribute(t2, e2) {
    return this.attributes[t2] = e2, this;
  }
  deleteAttribute(t2) {
    return delete this.attributes[t2], this;
  }
  hasAttribute(t2) {
    return this.attributes[t2] !== void 0;
  }
  addGroup(t2, e2, n2 = 0) {
    this.groups.push({ start: t2, count: e2, materialIndex: n2 });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t2, e2) {
    this.drawRange.start = t2, this.drawRange.count = e2;
  }
  applyMatrix4(t2) {
    const e2 = this.attributes.position;
    e2 !== void 0 && (e2.applyMatrix4(t2), e2.needsUpdate = true);
    const n2 = this.attributes.normal;
    if (n2 !== void 0) {
      const e3 = new ft().getNormalMatrix(t2);
      n2.applyNormalMatrix(e3), n2.needsUpdate = true;
    }
    const i2 = this.attributes.tangent;
    return i2 !== void 0 && (i2.transformDirection(t2), i2.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t2) {
    return sn.makeRotationFromQuaternion(t2), this.applyMatrix4(sn), this;
  }
  rotateX(t2) {
    return sn.makeRotationX(t2), this.applyMatrix4(sn), this;
  }
  rotateY(t2) {
    return sn.makeRotationY(t2), this.applyMatrix4(sn), this;
  }
  rotateZ(t2) {
    return sn.makeRotationZ(t2), this.applyMatrix4(sn), this;
  }
  translate(t2, e2, n2) {
    return sn.makeTranslation(t2, e2, n2), this.applyMatrix4(sn), this;
  }
  scale(t2, e2, n2) {
    return sn.makeScale(t2, e2, n2), this.applyMatrix4(sn), this;
  }
  lookAt(t2) {
    return an.lookAt(t2), an.updateMatrix(), this.applyMatrix4(an.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(on).negate(), this.translate(on.x, on.y, on.z), this;
  }
  setFromPoints(t2) {
    const e2 = [];
    for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) {
      const i3 = t2[n2];
      e2.push(i3.x, i3.y, i3.z || 0);
    }
    return this.setAttribute("position", new nn(e2, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ct());
    const t2 = this.attributes.position, e2 = this.morphAttributes.position;
    if (t2 && t2.isGLBufferAttribute)
      return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new At(-1 / 0, -1 / 0, -1 / 0), new At(1 / 0, 1 / 0, 1 / 0));
    if (t2 !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t2), e2)
        for (let t3 = 0, n2 = e2.length; t3 < n2; t3++) {
          const n3 = e2[t3];
          ln.setFromBufferAttribute(n3), this.morphTargetsRelative ? (hn.addVectors(this.boundingBox.min, ln.min), this.boundingBox.expandByPoint(hn), hn.addVectors(this.boundingBox.max, ln.max), this.boundingBox.expandByPoint(hn)) : (this.boundingBox.expandByPoint(ln.min), this.boundingBox.expandByPoint(ln.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Zt());
    const t2 = this.attributes.position, e2 = this.morphAttributes.position;
    if (t2 && t2.isGLBufferAttribute)
      return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new At(), 1 / 0);
    if (t2) {
      const n2 = this.boundingSphere.center;
      if (ln.setFromBufferAttribute(t2), e2)
        for (let t3 = 0, n3 = e2.length; t3 < n3; t3++) {
          const n4 = e2[t3];
          cn.setFromBufferAttribute(n4), this.morphTargetsRelative ? (hn.addVectors(ln.min, cn.min), ln.expandByPoint(hn), hn.addVectors(ln.max, cn.max), ln.expandByPoint(hn)) : (ln.expandByPoint(cn.min), ln.expandByPoint(cn.max));
        }
      ln.getCenter(n2);
      let i2 = 0;
      for (let e3 = 0, r2 = t2.count; e3 < r2; e3++)
        hn.fromBufferAttribute(t2, e3), i2 = Math.max(i2, n2.distanceToSquared(hn));
      if (e2)
        for (let r2 = 0, s2 = e2.length; r2 < s2; r2++) {
          const s3 = e2[r2], a2 = this.morphTargetsRelative;
          for (let e3 = 0, r3 = s3.count; e3 < r3; e3++)
            hn.fromBufferAttribute(s3, e3), a2 && (on.fromBufferAttribute(t2, e3), hn.add(on)), i2 = Math.max(i2, n2.distanceToSquared(hn));
        }
      this.boundingSphere.radius = Math.sqrt(i2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const t2 = this.index, e2 = this.attributes;
    if (t2 === null || e2.position === void 0 || e2.normal === void 0 || e2.uv === void 0)
      return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
    const n2 = t2.array, i2 = e2.position.array, r2 = e2.normal.array, s2 = e2.uv.array, a2 = i2.length / 3;
    e2.tangent === void 0 && this.setAttribute("tangent", new Qe(new Float32Array(4 * a2), 4));
    const o2 = e2.tangent.array, l2 = [], c2 = [];
    for (let t3 = 0; t3 < a2; t3++)
      l2[t3] = new At(), c2[t3] = new At();
    const h2 = new At(), u2 = new At(), d2 = new At(), p2 = new mt(), m2 = new mt(), f2 = new mt(), g2 = new At(), v2 = new At();
    function y2(t3, e3, n3) {
      h2.fromArray(i2, 3 * t3), u2.fromArray(i2, 3 * e3), d2.fromArray(i2, 3 * n3), p2.fromArray(s2, 2 * t3), m2.fromArray(s2, 2 * e3), f2.fromArray(s2, 2 * n3), u2.sub(h2), d2.sub(h2), m2.sub(p2), f2.sub(p2);
      const r3 = 1 / (m2.x * f2.y - f2.x * m2.y);
      isFinite(r3) && (g2.copy(u2).multiplyScalar(f2.y).addScaledVector(d2, -m2.y).multiplyScalar(r3), v2.copy(d2).multiplyScalar(m2.x).addScaledVector(u2, -f2.x).multiplyScalar(r3), l2[t3].add(g2), l2[e3].add(g2), l2[n3].add(g2), c2[t3].add(v2), c2[e3].add(v2), c2[n3].add(v2));
    }
    let x2 = this.groups;
    x2.length === 0 && (x2 = [{ start: 0, count: n2.length }]);
    for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
      const e4 = x2[t3], i3 = e4.start;
      for (let t4 = i3, r3 = i3 + e4.count; t4 < r3; t4 += 3)
        y2(n2[t4 + 0], n2[t4 + 1], n2[t4 + 2]);
    }
    const b2 = new At(), w2 = new At(), _2 = new At(), M2 = new At();
    function S2(t3) {
      _2.fromArray(r2, 3 * t3), M2.copy(_2);
      const e3 = l2[t3];
      b2.copy(e3), b2.sub(_2.multiplyScalar(_2.dot(e3))).normalize(), w2.crossVectors(M2, e3);
      const n3 = w2.dot(c2[t3]) < 0 ? -1 : 1;
      o2[4 * t3] = b2.x, o2[4 * t3 + 1] = b2.y, o2[4 * t3 + 2] = b2.z, o2[4 * t3 + 3] = n3;
    }
    for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
      const e4 = x2[t3], i3 = e4.start;
      for (let t4 = i3, r3 = i3 + e4.count; t4 < r3; t4 += 3)
        S2(n2[t4 + 0]), S2(n2[t4 + 1]), S2(n2[t4 + 2]);
    }
  }
  computeVertexNormals() {
    const t2 = this.index, e2 = this.getAttribute("position");
    if (e2 !== void 0) {
      let n2 = this.getAttribute("normal");
      if (n2 === void 0)
        n2 = new Qe(new Float32Array(3 * e2.count), 3), this.setAttribute("normal", n2);
      else
        for (let t3 = 0, e3 = n2.count; t3 < e3; t3++)
          n2.setXYZ(t3, 0, 0, 0);
      const i2 = new At(), r2 = new At(), s2 = new At(), a2 = new At(), o2 = new At(), l2 = new At(), c2 = new At(), h2 = new At();
      if (t2)
        for (let u2 = 0, d2 = t2.count; u2 < d2; u2 += 3) {
          const d3 = t2.getX(u2 + 0), p2 = t2.getX(u2 + 1), m2 = t2.getX(u2 + 2);
          i2.fromBufferAttribute(e2, d3), r2.fromBufferAttribute(e2, p2), s2.fromBufferAttribute(e2, m2), c2.subVectors(s2, r2), h2.subVectors(i2, r2), c2.cross(h2), a2.fromBufferAttribute(n2, d3), o2.fromBufferAttribute(n2, p2), l2.fromBufferAttribute(n2, m2), a2.add(c2), o2.add(c2), l2.add(c2), n2.setXYZ(d3, a2.x, a2.y, a2.z), n2.setXYZ(p2, o2.x, o2.y, o2.z), n2.setXYZ(m2, l2.x, l2.y, l2.z);
        }
      else
        for (let t3 = 0, a3 = e2.count; t3 < a3; t3 += 3)
          i2.fromBufferAttribute(e2, t3 + 0), r2.fromBufferAttribute(e2, t3 + 1), s2.fromBufferAttribute(e2, t3 + 2), c2.subVectors(s2, r2), h2.subVectors(i2, r2), c2.cross(h2), n2.setXYZ(t3 + 0, c2.x, c2.y, c2.z), n2.setXYZ(t3 + 1, c2.x, c2.y, c2.z), n2.setXYZ(t3 + 2, c2.x, c2.y, c2.z);
      this.normalizeNormals(), n2.needsUpdate = true;
    }
  }
  merge(t2, e2) {
    if (!t2 || !t2.isBufferGeometry)
      return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t2);
    e2 === void 0 && (e2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
    const n2 = this.attributes;
    for (const i2 in n2) {
      if (t2.attributes[i2] === void 0)
        continue;
      const r2 = n2[i2].array, s2 = t2.attributes[i2], a2 = s2.array, o2 = s2.itemSize * e2, l2 = Math.min(a2.length, r2.length - o2);
      for (let t3 = 0, e3 = o2; t3 < l2; t3++, e3++)
        r2[e3] = a2[t3];
    }
    return this;
  }
  normalizeNormals() {
    const t2 = this.attributes.normal;
    for (let e2 = 0, n2 = t2.count; e2 < n2; e2++)
      hn.fromBufferAttribute(t2, e2), hn.normalize(), t2.setXYZ(e2, hn.x, hn.y, hn.z);
  }
  toNonIndexed() {
    function t2(t3, e3) {
      const n3 = t3.array, i3 = t3.itemSize, r3 = t3.normalized, s3 = new n3.constructor(e3.length * i3);
      let a2 = 0, o2 = 0;
      for (let r4 = 0, l2 = e3.length; r4 < l2; r4++) {
        a2 = t3.isInterleavedBufferAttribute ? e3[r4] * t3.data.stride + t3.offset : e3[r4] * i3;
        for (let t4 = 0; t4 < i3; t4++)
          s3[o2++] = n3[a2++];
      }
      return new Qe(s3, i3, r3);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const e2 = new un(), n2 = this.index.array, i2 = this.attributes;
    for (const r3 in i2) {
      const s3 = t2(i2[r3], n2);
      e2.setAttribute(r3, s3);
    }
    const r2 = this.morphAttributes;
    for (const i3 in r2) {
      const s3 = [], a2 = r2[i3];
      for (let e3 = 0, i4 = a2.length; e3 < i4; e3++) {
        const i5 = t2(a2[e3], n2);
        s3.push(i5);
      }
      e2.morphAttributes[i3] = s3;
    }
    e2.morphTargetsRelative = this.morphTargetsRelative;
    const s2 = this.groups;
    for (let t3 = 0, n3 = s2.length; t3 < n3; t3++) {
      const n4 = s2[t3];
      e2.addGroup(n4.start, n4.count, n4.materialIndex);
    }
    return e2;
  }
  toJSON() {
    const t2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (t2.uuid = this.uuid, t2.type = this.type, this.name !== "" && (t2.name = this.name), Object.keys(this.userData).length > 0 && (t2.userData = this.userData), this.parameters !== void 0) {
      const e3 = this.parameters;
      for (const n3 in e3)
        e3[n3] !== void 0 && (t2[n3] = e3[n3]);
      return t2;
    }
    t2.data = { attributes: {} };
    const e2 = this.index;
    e2 !== null && (t2.data.index = { type: e2.array.constructor.name, array: Array.prototype.slice.call(e2.array) });
    const n2 = this.attributes;
    for (const e3 in n2) {
      const i3 = n2[e3];
      t2.data.attributes[e3] = i3.toJSON(t2.data);
    }
    const i2 = {};
    let r2 = false;
    for (const e3 in this.morphAttributes) {
      const n3 = this.morphAttributes[e3], s3 = [];
      for (let e4 = 0, i3 = n3.length; e4 < i3; e4++) {
        const i4 = n3[e4];
        s3.push(i4.toJSON(t2.data));
      }
      s3.length > 0 && (i2[e3] = s3, r2 = true);
    }
    r2 && (t2.data.morphAttributes = i2, t2.data.morphTargetsRelative = this.morphTargetsRelative);
    const s2 = this.groups;
    s2.length > 0 && (t2.data.groups = JSON.parse(JSON.stringify(s2)));
    const a2 = this.boundingSphere;
    return a2 !== null && (t2.data.boundingSphere = { center: a2.center.toArray(), radius: a2.radius }), t2;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t2) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e2 = {};
    this.name = t2.name;
    const n2 = t2.index;
    n2 !== null && this.setIndex(n2.clone(e2));
    const i2 = t2.attributes;
    for (const t3 in i2) {
      const n3 = i2[t3];
      this.setAttribute(t3, n3.clone(e2));
    }
    const r2 = t2.morphAttributes;
    for (const t3 in r2) {
      const n3 = [], i3 = r2[t3];
      for (let t4 = 0, r3 = i3.length; t4 < r3; t4++)
        n3.push(i3[t4].clone(e2));
      this.morphAttributes[t3] = n3;
    }
    this.morphTargetsRelative = t2.morphTargetsRelative;
    const s2 = t2.groups;
    for (let t3 = 0, e3 = s2.length; t3 < e3; t3++) {
      const e4 = s2[t3];
      this.addGroup(e4.start, e4.count, e4.materialIndex);
    }
    const a2 = t2.boundingBox;
    a2 !== null && (this.boundingBox = a2.clone());
    const o2 = t2.boundingSphere;
    return o2 !== null && (this.boundingSphere = o2.clone()), this.drawRange.start = t2.drawRange.start, this.drawRange.count = t2.drawRange.count, this.userData = t2.userData, t2.parameters !== void 0 && (this.parameters = Object.assign({}, t2.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
un.prototype.isBufferGeometry = true;
const dn = new re(), pn = new ie(), mn = new Zt(), fn = new At(), gn = new At(), vn = new At(), yn = new At(), xn = new At(), bn = new At(), wn = new At(), _n = new At(), Mn = new At(), Sn = new mt(), Tn = new mt(), En = new mt(), An = new At(), Rn = new At();
class Ln extends Le {
  constructor(t2 = new un(), e2 = new Je()) {
    super(), this.type = "Mesh", this.geometry = t2, this.material = e2, this.updateMorphTargets();
  }
  copy(t2) {
    return super.copy(t2), t2.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t2.morphTargetInfluences.slice()), t2.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t2.morphTargetDictionary)), this.material = t2.material, this.geometry = t2.geometry, this;
  }
  updateMorphTargets() {
    const t2 = this.geometry;
    if (t2.isBufferGeometry) {
      const e2 = t2.morphAttributes, n2 = Object.keys(e2);
      if (n2.length > 0) {
        const t3 = e2[n2[0]];
        if (t3 !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
            const n4 = t3[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
          }
        }
      }
    } else {
      const e2 = t2.morphTargets;
      e2 !== void 0 && e2.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  raycast(t2, e2) {
    const n2 = this.geometry, i2 = this.material, r2 = this.matrixWorld;
    if (i2 === void 0)
      return;
    if (n2.boundingSphere === null && n2.computeBoundingSphere(), mn.copy(n2.boundingSphere), mn.applyMatrix4(r2), t2.ray.intersectsSphere(mn) === false)
      return;
    if (dn.copy(r2).invert(), pn.copy(t2.ray).applyMatrix4(dn), n2.boundingBox !== null && pn.intersectsBox(n2.boundingBox) === false)
      return;
    let s2;
    if (n2.isBufferGeometry) {
      const r3 = n2.index, a2 = n2.attributes.position, o2 = n2.morphAttributes.position, l2 = n2.morphTargetsRelative, c2 = n2.attributes.uv, h2 = n2.attributes.uv2, u2 = n2.groups, d2 = n2.drawRange;
      if (r3 !== null)
        if (Array.isArray(i2))
          for (let n3 = 0, p2 = u2.length; n3 < p2; n3++) {
            const p3 = u2[n3], m2 = i2[p3.materialIndex];
            for (let n4 = Math.max(p3.start, d2.start), i3 = Math.min(r3.count, Math.min(p3.start + p3.count, d2.start + d2.count)); n4 < i3; n4 += 3) {
              const i4 = r3.getX(n4), u3 = r3.getX(n4 + 1), d3 = r3.getX(n4 + 2);
              s2 = Cn(this, m2, t2, pn, a2, o2, l2, c2, h2, i4, u3, d3), s2 && (s2.faceIndex = Math.floor(n4 / 3), s2.face.materialIndex = p3.materialIndex, e2.push(s2));
            }
          }
        else {
          for (let n3 = Math.max(0, d2.start), u3 = Math.min(r3.count, d2.start + d2.count); n3 < u3; n3 += 3) {
            const u4 = r3.getX(n3), d3 = r3.getX(n3 + 1), p2 = r3.getX(n3 + 2);
            s2 = Cn(this, i2, t2, pn, a2, o2, l2, c2, h2, u4, d3, p2), s2 && (s2.faceIndex = Math.floor(n3 / 3), e2.push(s2));
          }
        }
      else if (a2 !== void 0)
        if (Array.isArray(i2))
          for (let n3 = 0, r4 = u2.length; n3 < r4; n3++) {
            const r5 = u2[n3], p2 = i2[r5.materialIndex];
            for (let n4 = Math.max(r5.start, d2.start), i3 = Math.min(a2.count, Math.min(r5.start + r5.count, d2.start + d2.count)); n4 < i3; n4 += 3) {
              s2 = Cn(this, p2, t2, pn, a2, o2, l2, c2, h2, n4, n4 + 1, n4 + 2), s2 && (s2.faceIndex = Math.floor(n4 / 3), s2.face.materialIndex = r5.materialIndex, e2.push(s2));
            }
          }
        else {
          for (let n3 = Math.max(0, d2.start), r4 = Math.min(a2.count, d2.start + d2.count); n3 < r4; n3 += 3) {
            s2 = Cn(this, i2, t2, pn, a2, o2, l2, c2, h2, n3, n3 + 1, n3 + 2), s2 && (s2.faceIndex = Math.floor(n3 / 3), e2.push(s2));
          }
        }
    } else
      n2.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
}
function Cn(t2, e2, n2, i2, r2, s2, a2, o2, l2, c2, h2, u2) {
  fn.fromBufferAttribute(r2, c2), gn.fromBufferAttribute(r2, h2), vn.fromBufferAttribute(r2, u2);
  const d2 = t2.morphTargetInfluences;
  if (s2 && d2) {
    wn.set(0, 0, 0), _n.set(0, 0, 0), Mn.set(0, 0, 0);
    for (let t3 = 0, e3 = s2.length; t3 < e3; t3++) {
      const e4 = d2[t3], n3 = s2[t3];
      e4 !== 0 && (yn.fromBufferAttribute(n3, c2), xn.fromBufferAttribute(n3, h2), bn.fromBufferAttribute(n3, u2), a2 ? (wn.addScaledVector(yn, e4), _n.addScaledVector(xn, e4), Mn.addScaledVector(bn, e4)) : (wn.addScaledVector(yn.sub(fn), e4), _n.addScaledVector(xn.sub(gn), e4), Mn.addScaledVector(bn.sub(vn), e4)));
    }
    fn.add(wn), gn.add(_n), vn.add(Mn);
  }
  t2.isSkinnedMesh && (t2.boneTransform(c2, fn), t2.boneTransform(h2, gn), t2.boneTransform(u2, vn));
  const p2 = function(t3, e3, n3, i3, r3, s3, a3, o3) {
    let l3;
    if (l3 = e3.side === 1 ? i3.intersectTriangle(a3, s3, r3, true, o3) : i3.intersectTriangle(r3, s3, a3, e3.side !== 2, o3), l3 === null)
      return null;
    Rn.copy(o3), Rn.applyMatrix4(t3.matrixWorld);
    const c3 = n3.ray.origin.distanceTo(Rn);
    return c3 < n3.near || c3 > n3.far ? null : { distance: c3, point: Rn.clone(), object: t3 };
  }(t2, e2, n2, i2, fn, gn, vn, An);
  if (p2) {
    o2 && (Sn.fromBufferAttribute(o2, c2), Tn.fromBufferAttribute(o2, h2), En.fromBufferAttribute(o2, u2), p2.uv = Be.getUV(An, fn, gn, vn, Sn, Tn, En, new mt())), l2 && (Sn.fromBufferAttribute(l2, c2), Tn.fromBufferAttribute(l2, h2), En.fromBufferAttribute(l2, u2), p2.uv2 = Be.getUV(An, fn, gn, vn, Sn, Tn, En, new mt()));
    const t3 = { a: c2, b: h2, c: u2, normal: new At(), materialIndex: 0 };
    Be.getNormal(fn, gn, vn, t3.normal), p2.face = t3;
  }
  return p2;
}
Ln.prototype.isMesh = true;
class Pn extends un {
  constructor(t2 = 1, e2 = 1, n2 = 1, i2 = 1, r2 = 1, s2 = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: t2, height: e2, depth: n2, widthSegments: i2, heightSegments: r2, depthSegments: s2 };
    const a2 = this;
    i2 = Math.floor(i2), r2 = Math.floor(r2), s2 = Math.floor(s2);
    const o2 = [], l2 = [], c2 = [], h2 = [];
    let u2 = 0, d2 = 0;
    function p2(t3, e3, n3, i3, r3, s3, p3, m2, f2, g2, v2) {
      const y2 = s3 / f2, x2 = p3 / g2, b2 = s3 / 2, w2 = p3 / 2, _2 = m2 / 2, M2 = f2 + 1, S2 = g2 + 1;
      let T2 = 0, E2 = 0;
      const A2 = new At();
      for (let s4 = 0; s4 < S2; s4++) {
        const a3 = s4 * x2 - w2;
        for (let o3 = 0; o3 < M2; o3++) {
          const u3 = o3 * y2 - b2;
          A2[t3] = u3 * i3, A2[e3] = a3 * r3, A2[n3] = _2, l2.push(A2.x, A2.y, A2.z), A2[t3] = 0, A2[e3] = 0, A2[n3] = m2 > 0 ? 1 : -1, c2.push(A2.x, A2.y, A2.z), h2.push(o3 / f2), h2.push(1 - s4 / g2), T2 += 1;
        }
      }
      for (let t4 = 0; t4 < g2; t4++)
        for (let e4 = 0; e4 < f2; e4++) {
          const n4 = u2 + e4 + M2 * t4, i4 = u2 + e4 + M2 * (t4 + 1), r4 = u2 + (e4 + 1) + M2 * (t4 + 1), s4 = u2 + (e4 + 1) + M2 * t4;
          o2.push(n4, i4, s4), o2.push(i4, r4, s4), E2 += 6;
        }
      a2.addGroup(d2, E2, v2), d2 += E2, u2 += T2;
    }
    p2("z", "y", "x", -1, -1, n2, e2, t2, s2, r2, 0), p2("z", "y", "x", 1, -1, n2, e2, -t2, s2, r2, 1), p2("x", "z", "y", 1, 1, t2, n2, e2, i2, s2, 2), p2("x", "z", "y", 1, -1, t2, n2, -e2, i2, s2, 3), p2("x", "y", "z", 1, -1, t2, e2, n2, i2, r2, 4), p2("x", "y", "z", -1, -1, t2, e2, -n2, i2, r2, 5), this.setIndex(o2), this.setAttribute("position", new nn(l2, 3)), this.setAttribute("normal", new nn(c2, 3)), this.setAttribute("uv", new nn(h2, 2));
  }
  static fromJSON(t2) {
    return new Pn(t2.width, t2.height, t2.depth, t2.widthSegments, t2.heightSegments, t2.depthSegments);
  }
}
function In(t2) {
  const e2 = {};
  for (const n2 in t2) {
    e2[n2] = {};
    for (const i2 in t2[n2]) {
      const r2 = t2[n2][i2];
      r2 && (r2.isColor || r2.isMatrix3 || r2.isMatrix4 || r2.isVector2 || r2.isVector3 || r2.isVector4 || r2.isTexture || r2.isQuaternion) ? e2[n2][i2] = r2.clone() : Array.isArray(r2) ? e2[n2][i2] = r2.slice() : e2[n2][i2] = r2;
    }
  }
  return e2;
}
function Dn(t2) {
  const e2 = {};
  for (let n2 = 0; n2 < t2.length; n2++) {
    const i2 = In(t2[n2]);
    for (const t3 in i2)
      e2[t3] = i2[t3];
  }
  return e2;
}
const Nn = { clone: In, merge: Dn };
class Fn extends Ve {
  constructor(t2) {
    super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t2 !== void 0 && (t2.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t2));
  }
  copy(t2) {
    return super.copy(t2), this.fragmentShader = t2.fragmentShader, this.vertexShader = t2.vertexShader, this.uniforms = In(t2.uniforms), this.defines = Object.assign({}, t2.defines), this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.lights = t2.lights, this.clipping = t2.clipping, this.extensions = Object.assign({}, t2.extensions), this.glslVersion = t2.glslVersion, this;
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    e2.glslVersion = this.glslVersion, e2.uniforms = {};
    for (const n3 in this.uniforms) {
      const i2 = this.uniforms[n3].value;
      i2 && i2.isTexture ? e2.uniforms[n3] = { type: "t", value: i2.toJSON(t2).uuid } : i2 && i2.isColor ? e2.uniforms[n3] = { type: "c", value: i2.getHex() } : i2 && i2.isVector2 ? e2.uniforms[n3] = { type: "v2", value: i2.toArray() } : i2 && i2.isVector3 ? e2.uniforms[n3] = { type: "v3", value: i2.toArray() } : i2 && i2.isVector4 ? e2.uniforms[n3] = { type: "v4", value: i2.toArray() } : i2 && i2.isMatrix3 ? e2.uniforms[n3] = { type: "m3", value: i2.toArray() } : i2 && i2.isMatrix4 ? e2.uniforms[n3] = { type: "m4", value: i2.toArray() } : e2.uniforms[n3] = { value: i2 };
    }
    Object.keys(this.defines).length > 0 && (e2.defines = this.defines), e2.vertexShader = this.vertexShader, e2.fragmentShader = this.fragmentShader;
    const n2 = {};
    for (const t3 in this.extensions)
      this.extensions[t3] === true && (n2[t3] = true);
    return Object.keys(n2).length > 0 && (e2.extensions = n2), e2;
  }
}
Fn.prototype.isShaderMaterial = true;
class On extends Le {
  constructor() {
    super(), this.type = "Camera", this.matrixWorldInverse = new re(), this.projectionMatrix = new re(), this.projectionMatrixInverse = new re();
  }
  copy(t2, e2) {
    return super.copy(t2, e2), this.matrixWorldInverse.copy(t2.matrixWorldInverse), this.projectionMatrix.copy(t2.projectionMatrix), this.projectionMatrixInverse.copy(t2.projectionMatrixInverse), this;
  }
  getWorldDirection(t2) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return t2.set(-e2[8], -e2[9], -e2[10]).normalize();
  }
  updateMatrixWorld(t2) {
    super.updateMatrixWorld(t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t2, e2) {
    super.updateWorldMatrix(t2, e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
On.prototype.isCamera = true;
class Un extends On {
  constructor(t2 = 50, e2 = 1, n2 = 0.1, i2 = 2e3) {
    super(), this.type = "PerspectiveCamera", this.fov = t2, this.zoom = 1, this.near = n2, this.far = i2, this.focus = 10, this.aspect = e2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(t2, e2) {
    return super.copy(t2, e2), this.fov = t2.fov, this.zoom = t2.zoom, this.near = t2.near, this.far = t2.far, this.focus = t2.focus, this.aspect = t2.aspect, this.view = t2.view === null ? null : Object.assign({}, t2.view), this.filmGauge = t2.filmGauge, this.filmOffset = t2.filmOffset, this;
  }
  setFocalLength(t2) {
    const e2 = 0.5 * this.getFilmHeight() / t2;
    this.fov = 2 * st * Math.atan(e2), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const t2 = Math.tan(0.5 * rt * this.fov);
    return 0.5 * this.getFilmHeight() / t2;
  }
  getEffectiveFOV() {
    return 2 * st * Math.atan(Math.tan(0.5 * rt * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(t2, e2, n2, i2, r2, s2) {
    this.aspect = t2 / e2, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = n2, this.view.offsetY = i2, this.view.width = r2, this.view.height = s2, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t2 = this.near;
    let e2 = t2 * Math.tan(0.5 * rt * this.fov) / this.zoom, n2 = 2 * e2, i2 = this.aspect * n2, r2 = -0.5 * i2;
    const s2 = this.view;
    if (this.view !== null && this.view.enabled) {
      const t3 = s2.fullWidth, a3 = s2.fullHeight;
      r2 += s2.offsetX * i2 / t3, e2 -= s2.offsetY * n2 / a3, i2 *= s2.width / t3, n2 *= s2.height / a3;
    }
    const a2 = this.filmOffset;
    a2 !== 0 && (r2 += t2 * a2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r2, r2 + i2, e2, e2 - n2, t2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    return e2.object.fov = this.fov, e2.object.zoom = this.zoom, e2.object.near = this.near, e2.object.far = this.far, e2.object.focus = this.focus, e2.object.aspect = this.aspect, this.view !== null && (e2.object.view = Object.assign({}, this.view)), e2.object.filmGauge = this.filmGauge, e2.object.filmOffset = this.filmOffset, e2;
  }
}
Un.prototype.isPerspectiveCamera = true;
class kn extends Le {
  constructor(t2, e2, n2) {
    if (super(), this.type = "CubeCamera", n2.isWebGLCubeRenderTarget !== true)
      return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    this.renderTarget = n2;
    const i2 = new Un(90, 1, t2, e2);
    i2.layers = this.layers, i2.up.set(0, -1, 0), i2.lookAt(new At(1, 0, 0)), this.add(i2);
    const r2 = new Un(90, 1, t2, e2);
    r2.layers = this.layers, r2.up.set(0, -1, 0), r2.lookAt(new At(-1, 0, 0)), this.add(r2);
    const s2 = new Un(90, 1, t2, e2);
    s2.layers = this.layers, s2.up.set(0, 0, 1), s2.lookAt(new At(0, 1, 0)), this.add(s2);
    const a2 = new Un(90, 1, t2, e2);
    a2.layers = this.layers, a2.up.set(0, 0, -1), a2.lookAt(new At(0, -1, 0)), this.add(a2);
    const o2 = new Un(90, 1, t2, e2);
    o2.layers = this.layers, o2.up.set(0, -1, 0), o2.lookAt(new At(0, 0, 1)), this.add(o2);
    const l2 = new Un(90, 1, t2, e2);
    l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new At(0, 0, -1)), this.add(l2);
  }
  update(t2, e2) {
    this.parent === null && this.updateMatrixWorld();
    const n2 = this.renderTarget, [i2, r2, s2, a2, o2, l2] = this.children, c2 = t2.xr.enabled, h2 = t2.getRenderTarget();
    t2.xr.enabled = false;
    const u2 = n2.texture.generateMipmaps;
    n2.texture.generateMipmaps = false, t2.setRenderTarget(n2, 0), t2.render(e2, i2), t2.setRenderTarget(n2, 1), t2.render(e2, r2), t2.setRenderTarget(n2, 2), t2.render(e2, s2), t2.setRenderTarget(n2, 3), t2.render(e2, a2), t2.setRenderTarget(n2, 4), t2.render(e2, o2), n2.texture.generateMipmaps = u2, t2.setRenderTarget(n2, 5), t2.render(e2, l2), t2.setRenderTarget(h2), t2.xr.enabled = c2;
  }
}
class zn extends wt {
  constructor(t2, e2, n2, i2, r2, s2, a2, o2, l2, c2) {
    super(t2 = t2 !== void 0 ? t2 : [], e2 = e2 !== void 0 ? e2 : 301, n2, i2, r2, s2, a2, o2, l2, c2), this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(t2) {
    this.image = t2;
  }
}
zn.prototype.isCubeTexture = true;
class Bn extends St {
  constructor(t2, e2, n2) {
    Number.isInteger(e2) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e2 = n2), super(t2, t2, e2), e2 = e2 || {}, this.texture = new zn(void 0, e2.mapping, e2.wrapS, e2.wrapT, e2.magFilter, e2.minFilter, e2.format, e2.type, e2.anisotropy, e2.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = e2.generateMipmaps !== void 0 && e2.generateMipmaps, this.texture.minFilter = e2.minFilter !== void 0 ? e2.minFilter : 1006, this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(t2, e2) {
    this.texture.type = e2.type, this.texture.format = 1023, this.texture.encoding = e2.encoding, this.texture.generateMipmaps = e2.generateMipmaps, this.texture.minFilter = e2.minFilter, this.texture.magFilter = e2.magFilter;
    const n2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, i2 = new Pn(5, 5, 5), r2 = new Fn({ name: "CubemapFromEquirect", uniforms: In(n2.uniforms), vertexShader: n2.vertexShader, fragmentShader: n2.fragmentShader, side: 1, blending: 0 });
    r2.uniforms.tEquirect.value = e2;
    const s2 = new Ln(i2, r2), a2 = e2.minFilter;
    e2.minFilter === 1008 && (e2.minFilter = 1006);
    return new kn(1, 10, this).update(t2, s2), e2.minFilter = a2, s2.geometry.dispose(), s2.material.dispose(), this;
  }
  clear(t2, e2, n2, i2) {
    const r2 = t2.getRenderTarget();
    for (let r3 = 0; r3 < 6; r3++)
      t2.setRenderTarget(this, r3), t2.clear(e2, n2, i2);
    t2.setRenderTarget(r2);
  }
}
Bn.prototype.isWebGLCubeRenderTarget = true;
const Hn = new At(), Vn = new At(), Gn = new ft();
class Wn {
  constructor(t2 = new At(1, 0, 0), e2 = 0) {
    this.normal = t2, this.constant = e2;
  }
  set(t2, e2) {
    return this.normal.copy(t2), this.constant = e2, this;
  }
  setComponents(t2, e2, n2, i2) {
    return this.normal.set(t2, e2, n2), this.constant = i2, this;
  }
  setFromNormalAndCoplanarPoint(t2, e2) {
    return this.normal.copy(t2), this.constant = -e2.dot(this.normal), this;
  }
  setFromCoplanarPoints(t2, e2, n2) {
    const i2 = Hn.subVectors(n2, e2).cross(Vn.subVectors(t2, e2)).normalize();
    return this.setFromNormalAndCoplanarPoint(i2, t2), this;
  }
  copy(t2) {
    return this.normal.copy(t2.normal), this.constant = t2.constant, this;
  }
  normalize() {
    const t2 = 1 / this.normal.length();
    return this.normal.multiplyScalar(t2), this.constant *= t2, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(t2) {
    return this.normal.dot(t2) + this.constant;
  }
  distanceToSphere(t2) {
    return this.distanceToPoint(t2.center) - t2.radius;
  }
  projectPoint(t2, e2) {
    return e2.copy(this.normal).multiplyScalar(-this.distanceToPoint(t2)).add(t2);
  }
  intersectLine(t2, e2) {
    const n2 = t2.delta(Hn), i2 = this.normal.dot(n2);
    if (i2 === 0)
      return this.distanceToPoint(t2.start) === 0 ? e2.copy(t2.start) : null;
    const r2 = -(t2.start.dot(this.normal) + this.constant) / i2;
    return r2 < 0 || r2 > 1 ? null : e2.copy(n2).multiplyScalar(r2).add(t2.start);
  }
  intersectsLine(t2) {
    const e2 = this.distanceToPoint(t2.start), n2 = this.distanceToPoint(t2.end);
    return e2 < 0 && n2 > 0 || n2 < 0 && e2 > 0;
  }
  intersectsBox(t2) {
    return t2.intersectsPlane(this);
  }
  intersectsSphere(t2) {
    return t2.intersectsPlane(this);
  }
  coplanarPoint(t2) {
    return t2.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t2, e2) {
    const n2 = e2 || Gn.getNormalMatrix(t2), i2 = this.coplanarPoint(Hn).applyMatrix4(t2), r2 = this.normal.applyMatrix3(n2).normalize();
    return this.constant = -i2.dot(r2), this;
  }
  translate(t2) {
    return this.constant -= t2.dot(this.normal), this;
  }
  equals(t2) {
    return t2.normal.equals(this.normal) && t2.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Wn.prototype.isPlane = true;
const jn = new Zt(), qn = new At();
class Xn {
  constructor(t2 = new Wn(), e2 = new Wn(), n2 = new Wn(), i2 = new Wn(), r2 = new Wn(), s2 = new Wn()) {
    this.planes = [t2, e2, n2, i2, r2, s2];
  }
  set(t2, e2, n2, i2, r2, s2) {
    const a2 = this.planes;
    return a2[0].copy(t2), a2[1].copy(e2), a2[2].copy(n2), a2[3].copy(i2), a2[4].copy(r2), a2[5].copy(s2), this;
  }
  copy(t2) {
    const e2 = this.planes;
    for (let n2 = 0; n2 < 6; n2++)
      e2[n2].copy(t2.planes[n2]);
    return this;
  }
  setFromProjectionMatrix(t2) {
    const e2 = this.planes, n2 = t2.elements, i2 = n2[0], r2 = n2[1], s2 = n2[2], a2 = n2[3], o2 = n2[4], l2 = n2[5], c2 = n2[6], h2 = n2[7], u2 = n2[8], d2 = n2[9], p2 = n2[10], m2 = n2[11], f2 = n2[12], g2 = n2[13], v2 = n2[14], y2 = n2[15];
    return e2[0].setComponents(a2 - i2, h2 - o2, m2 - u2, y2 - f2).normalize(), e2[1].setComponents(a2 + i2, h2 + o2, m2 + u2, y2 + f2).normalize(), e2[2].setComponents(a2 + r2, h2 + l2, m2 + d2, y2 + g2).normalize(), e2[3].setComponents(a2 - r2, h2 - l2, m2 - d2, y2 - g2).normalize(), e2[4].setComponents(a2 - s2, h2 - c2, m2 - p2, y2 - v2).normalize(), e2[5].setComponents(a2 + s2, h2 + c2, m2 + p2, y2 + v2).normalize(), this;
  }
  intersectsObject(t2) {
    const e2 = t2.geometry;
    return e2.boundingSphere === null && e2.computeBoundingSphere(), jn.copy(e2.boundingSphere).applyMatrix4(t2.matrixWorld), this.intersectsSphere(jn);
  }
  intersectsSprite(t2) {
    return jn.center.set(0, 0, 0), jn.radius = 0.7071067811865476, jn.applyMatrix4(t2.matrixWorld), this.intersectsSphere(jn);
  }
  intersectsSphere(t2) {
    const e2 = this.planes, n2 = t2.center, i2 = -t2.radius;
    for (let t3 = 0; t3 < 6; t3++) {
      if (e2[t3].distanceToPoint(n2) < i2)
        return false;
    }
    return true;
  }
  intersectsBox(t2) {
    const e2 = this.planes;
    for (let n2 = 0; n2 < 6; n2++) {
      const i2 = e2[n2];
      if (qn.x = i2.normal.x > 0 ? t2.max.x : t2.min.x, qn.y = i2.normal.y > 0 ? t2.max.y : t2.min.y, qn.z = i2.normal.z > 0 ? t2.max.z : t2.min.z, i2.distanceToPoint(qn) < 0)
        return false;
    }
    return true;
  }
  containsPoint(t2) {
    const e2 = this.planes;
    for (let n2 = 0; n2 < 6; n2++)
      if (e2[n2].distanceToPoint(t2) < 0)
        return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Yn() {
  let t2 = null, e2 = false, n2 = null, i2 = null;
  function r2(e3, s2) {
    n2(e3, s2), i2 = t2.requestAnimationFrame(r2);
  }
  return { start: function() {
    e2 !== true && n2 !== null && (i2 = t2.requestAnimationFrame(r2), e2 = true);
  }, stop: function() {
    t2.cancelAnimationFrame(i2), e2 = false;
  }, setAnimationLoop: function(t3) {
    n2 = t3;
  }, setContext: function(e3) {
    t2 = e3;
  } };
}
function Zn(t2, e2) {
  const n2 = e2.isWebGL2, i2 = /* @__PURE__ */ new WeakMap();
  return { get: function(t3) {
    return t3.isInterleavedBufferAttribute && (t3 = t3.data), i2.get(t3);
  }, remove: function(e3) {
    e3.isInterleavedBufferAttribute && (e3 = e3.data);
    const n3 = i2.get(e3);
    n3 && (t2.deleteBuffer(n3.buffer), i2.delete(e3));
  }, update: function(e3, r2) {
    if (e3.isGLBufferAttribute) {
      const t3 = i2.get(e3);
      return void ((!t3 || t3.version < e3.version) && i2.set(e3, { buffer: e3.buffer, type: e3.type, bytesPerElement: e3.elementSize, version: e3.version }));
    }
    e3.isInterleavedBufferAttribute && (e3 = e3.data);
    const s2 = i2.get(e3);
    s2 === void 0 ? i2.set(e3, function(e4, i3) {
      const r3 = e4.array, s3 = e4.usage, a2 = t2.createBuffer();
      t2.bindBuffer(i3, a2), t2.bufferData(i3, r3, s3), e4.onUploadCallback();
      let o2 = 5126;
      return r3 instanceof Float32Array ? o2 = 5126 : r3 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r3 instanceof Uint16Array ? e4.isFloat16BufferAttribute ? n2 ? o2 = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o2 = 5123 : r3 instanceof Int16Array ? o2 = 5122 : r3 instanceof Uint32Array ? o2 = 5125 : r3 instanceof Int32Array ? o2 = 5124 : r3 instanceof Int8Array ? o2 = 5120 : (r3 instanceof Uint8Array || r3 instanceof Uint8ClampedArray) && (o2 = 5121), { buffer: a2, type: o2, bytesPerElement: r3.BYTES_PER_ELEMENT, version: e4.version };
    }(e3, r2)) : s2.version < e3.version && (!function(e4, i3, r3) {
      const s3 = i3.array, a2 = i3.updateRange;
      t2.bindBuffer(r3, e4), a2.count === -1 ? t2.bufferSubData(r3, 0, s3) : (n2 ? t2.bufferSubData(r3, a2.offset * s3.BYTES_PER_ELEMENT, s3, a2.offset, a2.count) : t2.bufferSubData(r3, a2.offset * s3.BYTES_PER_ELEMENT, s3.subarray(a2.offset, a2.offset + a2.count)), a2.count = -1);
    }(s2.buffer, e3, r2), s2.version = e3.version);
  } };
}
class Jn extends un {
  constructor(t2 = 1, e2 = 1, n2 = 1, i2 = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: t2, height: e2, widthSegments: n2, heightSegments: i2 };
    const r2 = t2 / 2, s2 = e2 / 2, a2 = Math.floor(n2), o2 = Math.floor(i2), l2 = a2 + 1, c2 = o2 + 1, h2 = t2 / a2, u2 = e2 / o2, d2 = [], p2 = [], m2 = [], f2 = [];
    for (let t3 = 0; t3 < c2; t3++) {
      const e3 = t3 * u2 - s2;
      for (let n3 = 0; n3 < l2; n3++) {
        const i3 = n3 * h2 - r2;
        p2.push(i3, -e3, 0), m2.push(0, 0, 1), f2.push(n3 / a2), f2.push(1 - t3 / o2);
      }
    }
    for (let t3 = 0; t3 < o2; t3++)
      for (let e3 = 0; e3 < a2; e3++) {
        const n3 = e3 + l2 * t3, i3 = e3 + l2 * (t3 + 1), r3 = e3 + 1 + l2 * (t3 + 1), s3 = e3 + 1 + l2 * t3;
        d2.push(n3, i3, s3), d2.push(i3, r3, s3);
      }
    this.setIndex(d2), this.setAttribute("position", new nn(p2, 3)), this.setAttribute("normal", new nn(m2, 3)), this.setAttribute("uv", new nn(f2, 2));
  }
  static fromJSON(t2) {
    return new Jn(t2.width, t2.height, t2.widthSegments, t2.heightSegments);
  }
}
const $n = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		return texture2D( envMap, uv ).rgb;\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}" }, Kn = { common: { diffuse: { value: new Ze(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ft() }, uv2Transform: { value: new ft() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new mt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ze(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Ze(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new ft() } }, sprite: { diffuse: { value: new Ze(16777215) }, opacity: { value: 1 }, center: { value: new mt(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new ft() } } }, Qn = { basic: { uniforms: Dn([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.fog]), vertexShader: $n.meshbasic_vert, fragmentShader: $n.meshbasic_frag }, lambert: { uniforms: Dn([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.fog, Kn.lights, { emissive: { value: new Ze(0) } }]), vertexShader: $n.meshlambert_vert, fragmentShader: $n.meshlambert_frag }, phong: { uniforms: Dn([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.fog, Kn.lights, { emissive: { value: new Ze(0) }, specular: { value: new Ze(1118481) }, shininess: { value: 30 } }]), vertexShader: $n.meshphong_vert, fragmentShader: $n.meshphong_frag }, standard: { uniforms: Dn([Kn.common, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.roughnessmap, Kn.metalnessmap, Kn.fog, Kn.lights, { emissive: { value: new Ze(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: $n.meshphysical_vert, fragmentShader: $n.meshphysical_frag }, toon: { uniforms: Dn([Kn.common, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.gradientmap, Kn.fog, Kn.lights, { emissive: { value: new Ze(0) } }]), vertexShader: $n.meshtoon_vert, fragmentShader: $n.meshtoon_frag }, matcap: { uniforms: Dn([Kn.common, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.fog, { matcap: { value: null } }]), vertexShader: $n.meshmatcap_vert, fragmentShader: $n.meshmatcap_frag }, points: { uniforms: Dn([Kn.points, Kn.fog]), vertexShader: $n.points_vert, fragmentShader: $n.points_frag }, dashed: { uniforms: Dn([Kn.common, Kn.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: $n.linedashed_vert, fragmentShader: $n.linedashed_frag }, depth: { uniforms: Dn([Kn.common, Kn.displacementmap]), vertexShader: $n.depth_vert, fragmentShader: $n.depth_frag }, normal: { uniforms: Dn([Kn.common, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, { opacity: { value: 1 } }]), vertexShader: $n.meshnormal_vert, fragmentShader: $n.meshnormal_frag }, sprite: { uniforms: Dn([Kn.sprite, Kn.fog]), vertexShader: $n.sprite_vert, fragmentShader: $n.sprite_frag }, background: { uniforms: { uvTransform: { value: new ft() }, t2D: { value: null } }, vertexShader: $n.background_vert, fragmentShader: $n.background_frag }, cube: { uniforms: Dn([Kn.envmap, { opacity: { value: 1 } }]), vertexShader: $n.cube_vert, fragmentShader: $n.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: $n.equirect_vert, fragmentShader: $n.equirect_frag }, distanceRGBA: { uniforms: Dn([Kn.common, Kn.displacementmap, { referencePosition: { value: new At() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: $n.distanceRGBA_vert, fragmentShader: $n.distanceRGBA_frag }, shadow: { uniforms: Dn([Kn.lights, Kn.fog, { color: { value: new Ze(0) }, opacity: { value: 1 } }]), vertexShader: $n.shadow_vert, fragmentShader: $n.shadow_frag } };
function ti(t2, e2, n2, i2, r2) {
  const s2 = new Ze(0);
  let a2, o2, l2 = 0, c2 = null, h2 = 0, u2 = null;
  function d2(t3, e3) {
    n2.buffers.color.setClear(t3.r, t3.g, t3.b, e3, r2);
  }
  return { getClearColor: function() {
    return s2;
  }, setClearColor: function(t3, e3 = 1) {
    s2.set(t3), l2 = e3, d2(s2, l2);
  }, getClearAlpha: function() {
    return l2;
  }, setClearAlpha: function(t3) {
    l2 = t3, d2(s2, l2);
  }, render: function(n3, r3) {
    let p2 = false, m2 = r3.isScene === true ? r3.background : null;
    m2 && m2.isTexture && (m2 = e2.get(m2));
    const f2 = t2.xr, g2 = f2.getSession && f2.getSession();
    g2 && g2.environmentBlendMode === "additive" && (m2 = null), m2 === null ? d2(s2, l2) : m2 && m2.isColor && (d2(m2, 1), p2 = true), (t2.autoClear || p2) && t2.clear(t2.autoClearColor, t2.autoClearDepth, t2.autoClearStencil), m2 && (m2.isCubeTexture || m2.mapping === 306) ? (o2 === void 0 && (o2 = new Ln(new Pn(1, 1, 1), new Fn({ name: "BackgroundCubeMaterial", uniforms: In(Qn.cube.uniforms), vertexShader: Qn.cube.vertexShader, fragmentShader: Qn.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), o2.geometry.deleteAttribute("normal"), o2.geometry.deleteAttribute("uv"), o2.onBeforeRender = function(t3, e3, n4) {
      this.matrixWorld.copyPosition(n4.matrixWorld);
    }, Object.defineProperty(o2.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), i2.update(o2)), o2.material.uniforms.envMap.value = m2, o2.material.uniforms.flipEnvMap.value = m2.isCubeTexture && m2.isRenderTargetTexture === false ? -1 : 1, c2 === m2 && h2 === m2.version && u2 === t2.toneMapping || (o2.material.needsUpdate = true, c2 = m2, h2 = m2.version, u2 = t2.toneMapping), n3.unshift(o2, o2.geometry, o2.material, 0, 0, null)) : m2 && m2.isTexture && (a2 === void 0 && (a2 = new Ln(new Jn(2, 2), new Fn({ name: "BackgroundMaterial", uniforms: In(Qn.background.uniforms), vertexShader: Qn.background.vertexShader, fragmentShader: Qn.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), a2.geometry.deleteAttribute("normal"), Object.defineProperty(a2.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), i2.update(a2)), a2.material.uniforms.t2D.value = m2, m2.matrixAutoUpdate === true && m2.updateMatrix(), a2.material.uniforms.uvTransform.value.copy(m2.matrix), c2 === m2 && h2 === m2.version && u2 === t2.toneMapping || (a2.material.needsUpdate = true, c2 = m2, h2 = m2.version, u2 = t2.toneMapping), n3.unshift(a2, a2.geometry, a2.material, 0, 0, null));
  } };
}
function ei(t2, e2, n2, i2) {
  const r2 = t2.getParameter(34921), s2 = i2.isWebGL2 ? null : e2.get("OES_vertex_array_object"), a2 = i2.isWebGL2 || s2 !== null, o2 = {}, l2 = d2(null);
  let c2 = l2;
  function h2(e3) {
    return i2.isWebGL2 ? t2.bindVertexArray(e3) : s2.bindVertexArrayOES(e3);
  }
  function u2(e3) {
    return i2.isWebGL2 ? t2.deleteVertexArray(e3) : s2.deleteVertexArrayOES(e3);
  }
  function d2(t3) {
    const e3 = [], n3 = [], i3 = [];
    for (let t4 = 0; t4 < r2; t4++)
      e3[t4] = 0, n3[t4] = 0, i3[t4] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: e3, enabledAttributes: n3, attributeDivisors: i3, object: t3, attributes: {}, index: null };
  }
  function p2() {
    const t3 = c2.newAttributes;
    for (let e3 = 0, n3 = t3.length; e3 < n3; e3++)
      t3[e3] = 0;
  }
  function m2(t3) {
    f2(t3, 0);
  }
  function f2(n3, r3) {
    const s3 = c2.newAttributes, a3 = c2.enabledAttributes, o3 = c2.attributeDivisors;
    if (s3[n3] = 1, a3[n3] === 0 && (t2.enableVertexAttribArray(n3), a3[n3] = 1), o3[n3] !== r3) {
      (i2.isWebGL2 ? t2 : e2.get("ANGLE_instanced_arrays"))[i2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n3, r3), o3[n3] = r3;
    }
  }
  function g2() {
    const e3 = c2.newAttributes, n3 = c2.enabledAttributes;
    for (let i3 = 0, r3 = n3.length; i3 < r3; i3++)
      n3[i3] !== e3[i3] && (t2.disableVertexAttribArray(i3), n3[i3] = 0);
  }
  function v2(e3, n3, r3, s3, a3, o3) {
    i2.isWebGL2 !== true || r3 !== 5124 && r3 !== 5125 ? t2.vertexAttribPointer(e3, n3, r3, s3, a3, o3) : t2.vertexAttribIPointer(e3, n3, r3, a3, o3);
  }
  function y2() {
    x2(), c2 !== l2 && (c2 = l2, h2(c2.object));
  }
  function x2() {
    l2.geometry = null, l2.program = null, l2.wireframe = false;
  }
  return { setup: function(r3, l3, u3, y3, x3) {
    let b2 = false;
    if (a2) {
      const e3 = function(e4, n3, r4) {
        const a3 = r4.wireframe === true;
        let l4 = o2[e4.id];
        l4 === void 0 && (l4 = {}, o2[e4.id] = l4);
        let c3 = l4[n3.id];
        c3 === void 0 && (c3 = {}, l4[n3.id] = c3);
        let h3 = c3[a3];
        h3 === void 0 && (h3 = d2(i2.isWebGL2 ? t2.createVertexArray() : s2.createVertexArrayOES()), c3[a3] = h3);
        return h3;
      }(y3, u3, l3);
      c2 !== e3 && (c2 = e3, h2(c2.object)), b2 = function(t3, e4) {
        const n3 = c2.attributes, i3 = t3.attributes;
        let r4 = 0;
        for (const t4 in i3) {
          const e5 = n3[t4], s3 = i3[t4];
          if (e5 === void 0)
            return true;
          if (e5.attribute !== s3)
            return true;
          if (e5.data !== s3.data)
            return true;
          r4++;
        }
        return c2.attributesNum !== r4 || c2.index !== e4;
      }(y3, x3), b2 && function(t3, e4) {
        const n3 = {}, i3 = t3.attributes;
        let r4 = 0;
        for (const t4 in i3) {
          const e5 = i3[t4], s3 = {};
          s3.attribute = e5, e5.data && (s3.data = e5.data), n3[t4] = s3, r4++;
        }
        c2.attributes = n3, c2.attributesNum = r4, c2.index = e4;
      }(y3, x3);
    } else {
      const t3 = l3.wireframe === true;
      c2.geometry === y3.id && c2.program === u3.id && c2.wireframe === t3 || (c2.geometry = y3.id, c2.program = u3.id, c2.wireframe = t3, b2 = true);
    }
    r3.isInstancedMesh === true && (b2 = true), x3 !== null && n2.update(x3, 34963), b2 && (!function(r4, s3, a3, o3) {
      if (i2.isWebGL2 === false && (r4.isInstancedMesh || o3.isInstancedBufferGeometry) && e2.get("ANGLE_instanced_arrays") === null)
        return;
      p2();
      const l4 = o3.attributes, c3 = a3.getAttributes(), h3 = s3.defaultAttributeValues;
      for (const e3 in c3) {
        const i3 = c3[e3];
        if (i3.location >= 0) {
          let s4 = l4[e3];
          if (s4 === void 0 && (e3 === "instanceMatrix" && r4.instanceMatrix && (s4 = r4.instanceMatrix), e3 === "instanceColor" && r4.instanceColor && (s4 = r4.instanceColor)), s4 !== void 0) {
            const e4 = s4.normalized, a4 = s4.itemSize, l5 = n2.get(s4);
            if (l5 === void 0)
              continue;
            const c4 = l5.buffer, h4 = l5.type, u4 = l5.bytesPerElement;
            if (s4.isInterleavedBufferAttribute) {
              const n3 = s4.data, l6 = n3.stride, d3 = s4.offset;
              if (n3 && n3.isInstancedInterleavedBuffer) {
                for (let t3 = 0; t3 < i3.locationSize; t3++)
                  f2(i3.location + t3, n3.meshPerAttribute);
                r4.isInstancedMesh !== true && o3._maxInstanceCount === void 0 && (o3._maxInstanceCount = n3.meshPerAttribute * n3.count);
              } else
                for (let t3 = 0; t3 < i3.locationSize; t3++)
                  m2(i3.location + t3);
              t2.bindBuffer(34962, c4);
              for (let t3 = 0; t3 < i3.locationSize; t3++)
                v2(i3.location + t3, a4 / i3.locationSize, h4, e4, l6 * u4, (d3 + a4 / i3.locationSize * t3) * u4);
            } else {
              if (s4.isInstancedBufferAttribute) {
                for (let t3 = 0; t3 < i3.locationSize; t3++)
                  f2(i3.location + t3, s4.meshPerAttribute);
                r4.isInstancedMesh !== true && o3._maxInstanceCount === void 0 && (o3._maxInstanceCount = s4.meshPerAttribute * s4.count);
              } else
                for (let t3 = 0; t3 < i3.locationSize; t3++)
                  m2(i3.location + t3);
              t2.bindBuffer(34962, c4);
              for (let t3 = 0; t3 < i3.locationSize; t3++)
                v2(i3.location + t3, a4 / i3.locationSize, h4, e4, a4 * u4, a4 / i3.locationSize * t3 * u4);
            }
          } else if (h3 !== void 0) {
            const n3 = h3[e3];
            if (n3 !== void 0)
              switch (n3.length) {
                case 2:
                  t2.vertexAttrib2fv(i3.location, n3);
                  break;
                case 3:
                  t2.vertexAttrib3fv(i3.location, n3);
                  break;
                case 4:
                  t2.vertexAttrib4fv(i3.location, n3);
                  break;
                default:
                  t2.vertexAttrib1fv(i3.location, n3);
              }
          }
        }
      }
      g2();
    }(r3, l3, u3, y3), x3 !== null && t2.bindBuffer(34963, n2.get(x3).buffer));
  }, reset: y2, resetDefaultState: x2, dispose: function() {
    y2();
    for (const t3 in o2) {
      const e3 = o2[t3];
      for (const t4 in e3) {
        const n3 = e3[t4];
        for (const t5 in n3)
          u2(n3[t5].object), delete n3[t5];
        delete e3[t4];
      }
      delete o2[t3];
    }
  }, releaseStatesOfGeometry: function(t3) {
    if (o2[t3.id] === void 0)
      return;
    const e3 = o2[t3.id];
    for (const t4 in e3) {
      const n3 = e3[t4];
      for (const t5 in n3)
        u2(n3[t5].object), delete n3[t5];
      delete e3[t4];
    }
    delete o2[t3.id];
  }, releaseStatesOfProgram: function(t3) {
    for (const e3 in o2) {
      const n3 = o2[e3];
      if (n3[t3.id] === void 0)
        continue;
      const i3 = n3[t3.id];
      for (const t4 in i3)
        u2(i3[t4].object), delete i3[t4];
      delete n3[t3.id];
    }
  }, initAttributes: p2, enableAttribute: m2, disableUnusedAttributes: g2 };
}
function ni(t2, e2, n2, i2) {
  const r2 = i2.isWebGL2;
  let s2;
  this.setMode = function(t3) {
    s2 = t3;
  }, this.render = function(e3, i3) {
    t2.drawArrays(s2, e3, i3), n2.update(i3, s2, 1);
  }, this.renderInstances = function(i3, a2, o2) {
    if (o2 === 0)
      return;
    let l2, c2;
    if (r2)
      l2 = t2, c2 = "drawArraysInstanced";
    else if (l2 = e2.get("ANGLE_instanced_arrays"), c2 = "drawArraysInstancedANGLE", l2 === null)
      return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    l2[c2](s2, i3, a2, o2), n2.update(a2, s2, o2);
  };
}
function ii(t2, e2, n2) {
  let i2;
  function r2(e3) {
    if (e3 === "highp") {
      if (t2.getShaderPrecisionFormat(35633, 36338).precision > 0 && t2.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      e3 = "mediump";
    }
    return e3 === "mediump" && t2.getShaderPrecisionFormat(35633, 36337).precision > 0 && t2.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const s2 = typeof WebGL2RenderingContext != "undefined" && t2 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && t2 instanceof WebGL2ComputeRenderingContext;
  let a2 = n2.precision !== void 0 ? n2.precision : "highp";
  const o2 = r2(a2);
  o2 !== a2 && (console.warn("THREE.WebGLRenderer:", a2, "not supported, using", o2, "instead."), a2 = o2);
  const l2 = s2 || e2.has("WEBGL_draw_buffers"), c2 = n2.logarithmicDepthBuffer === true, h2 = t2.getParameter(34930), u2 = t2.getParameter(35660), d2 = t2.getParameter(3379), p2 = t2.getParameter(34076), m2 = t2.getParameter(34921), f2 = t2.getParameter(36347), g2 = t2.getParameter(36348), v2 = t2.getParameter(36349), y2 = u2 > 0, x2 = s2 || e2.has("OES_texture_float");
  return { isWebGL2: s2, drawBuffers: l2, getMaxAnisotropy: function() {
    if (i2 !== void 0)
      return i2;
    if (e2.has("EXT_texture_filter_anisotropic") === true) {
      const n3 = e2.get("EXT_texture_filter_anisotropic");
      i2 = t2.getParameter(n3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i2 = 0;
    return i2;
  }, getMaxPrecision: r2, precision: a2, logarithmicDepthBuffer: c2, maxTextures: h2, maxVertexTextures: u2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: m2, maxVertexUniforms: f2, maxVaryings: g2, maxFragmentUniforms: v2, vertexTextures: y2, floatFragmentTextures: x2, floatVertexTextures: y2 && x2, maxSamples: s2 ? t2.getParameter(36183) : 0 };
}
function ri(t2) {
  const e2 = this;
  let n2 = null, i2 = 0, r2 = false, s2 = false;
  const a2 = new Wn(), o2 = new ft(), l2 = { value: null, needsUpdate: false };
  function c2() {
    l2.value !== n2 && (l2.value = n2, l2.needsUpdate = i2 > 0), e2.numPlanes = i2, e2.numIntersection = 0;
  }
  function h2(t3, n3, i3, r3) {
    const s3 = t3 !== null ? t3.length : 0;
    let c3 = null;
    if (s3 !== 0) {
      if (c3 = l2.value, r3 !== true || c3 === null) {
        const e3 = i3 + 4 * s3, r4 = n3.matrixWorldInverse;
        o2.getNormalMatrix(r4), (c3 === null || c3.length < e3) && (c3 = new Float32Array(e3));
        for (let e4 = 0, n4 = i3; e4 !== s3; ++e4, n4 += 4)
          a2.copy(t3[e4]).applyMatrix4(r4, o2), a2.normal.toArray(c3, n4), c3[n4 + 3] = a2.constant;
      }
      l2.value = c3, l2.needsUpdate = true;
    }
    return e2.numPlanes = s3, e2.numIntersection = 0, c3;
  }
  this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t3, e3, s3) {
    const a3 = t3.length !== 0 || e3 || i2 !== 0 || r2;
    return r2 = e3, n2 = h2(t3, s3, 0), i2 = t3.length, a3;
  }, this.beginShadows = function() {
    s2 = true, h2(null);
  }, this.endShadows = function() {
    s2 = false, c2();
  }, this.setState = function(e3, a3, o3) {
    const u2 = e3.clippingPlanes, d2 = e3.clipIntersection, p2 = e3.clipShadows, m2 = t2.get(e3);
    if (!r2 || u2 === null || u2.length === 0 || s2 && !p2)
      s2 ? h2(null) : c2();
    else {
      const t3 = s2 ? 0 : i2, e4 = 4 * t3;
      let r3 = m2.clippingState || null;
      l2.value = r3, r3 = h2(u2, a3, e4, o3);
      for (let t4 = 0; t4 !== e4; ++t4)
        r3[t4] = n2[t4];
      m2.clippingState = r3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += t3;
    }
  };
}
function si(t2) {
  let e2 = /* @__PURE__ */ new WeakMap();
  function n2(t3, e3) {
    return e3 === 303 ? t3.mapping = 301 : e3 === 304 && (t3.mapping = 302), t3;
  }
  function i2(t3) {
    const n3 = t3.target;
    n3.removeEventListener("dispose", i2);
    const r2 = e2.get(n3);
    r2 !== void 0 && (e2.delete(n3), r2.dispose());
  }
  return { get: function(r2) {
    if (r2 && r2.isTexture && r2.isRenderTargetTexture === false) {
      const s2 = r2.mapping;
      if (s2 === 303 || s2 === 304) {
        if (e2.has(r2)) {
          return n2(e2.get(r2).texture, r2.mapping);
        }
        {
          const s3 = r2.image;
          if (s3 && s3.height > 0) {
            const a2 = t2.getRenderTarget(), o2 = new Bn(s3.height / 2);
            return o2.fromEquirectangularTexture(t2, r2), e2.set(r2, o2), t2.setRenderTarget(a2), r2.addEventListener("dispose", i2), n2(o2.texture, r2.mapping);
          }
          return null;
        }
      }
    }
    return r2;
  }, dispose: function() {
    e2 = /* @__PURE__ */ new WeakMap();
  } };
}
Qn.physical = { uniforms: Dn([Qn.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new mt(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Ze(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 0 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new mt() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Ze(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularColor: { value: new Ze(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: $n.meshphysical_vert, fragmentShader: $n.meshphysical_frag };
class ai extends On {
  constructor(t2 = -1, e2 = 1, n2 = 1, i2 = -1, r2 = 0.1, s2 = 2e3) {
    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t2, this.right = e2, this.top = n2, this.bottom = i2, this.near = r2, this.far = s2, this.updateProjectionMatrix();
  }
  copy(t2, e2) {
    return super.copy(t2, e2), this.left = t2.left, this.right = t2.right, this.top = t2.top, this.bottom = t2.bottom, this.near = t2.near, this.far = t2.far, this.zoom = t2.zoom, this.view = t2.view === null ? null : Object.assign({}, t2.view), this;
  }
  setViewOffset(t2, e2, n2, i2, r2, s2) {
    this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = n2, this.view.offsetY = i2, this.view.width = r2, this.view.height = s2, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t2 = (this.right - this.left) / (2 * this.zoom), e2 = (this.top - this.bottom) / (2 * this.zoom), n2 = (this.right + this.left) / 2, i2 = (this.top + this.bottom) / 2;
    let r2 = n2 - t2, s2 = n2 + t2, a2 = i2 + e2, o2 = i2 - e2;
    if (this.view !== null && this.view.enabled) {
      const t3 = (this.right - this.left) / this.view.fullWidth / this.zoom, e3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r2 += t3 * this.view.offsetX, s2 = r2 + t3 * this.view.width, a2 -= e3 * this.view.offsetY, o2 = a2 - e3 * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r2, s2, a2, o2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    return e2.object.zoom = this.zoom, e2.object.left = this.left, e2.object.right = this.right, e2.object.top = this.top, e2.object.bottom = this.bottom, e2.object.near = this.near, e2.object.far = this.far, this.view !== null && (e2.object.view = Object.assign({}, this.view)), e2;
  }
}
ai.prototype.isOrthographicCamera = true;
class oi extends Fn {
  constructor(t2) {
    super(t2), this.type = "RawShaderMaterial";
  }
}
oi.prototype.isRawShaderMaterial = true;
const li = Math.pow(2, 8), ci = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], hi = 5 + ci.length, ui = { 3e3: 0, 3001: 1 }, di = new ai(), { _lodPlanes: pi, _sizeLods: mi, _sigmas: fi } = _i(), gi = new Ze();
let vi = null;
const yi = (1 + Math.sqrt(5)) / 2, xi = 1 / yi, bi = [new At(1, 1, 1), new At(-1, 1, 1), new At(1, 1, -1), new At(-1, 1, -1), new At(0, yi, xi), new At(0, yi, -xi), new At(xi, 0, yi), new At(-xi, 0, yi), new At(yi, xi, 0), new At(-yi, xi, 0)];
class wi {
  constructor(t2) {
    this._renderer = t2, this._pingPongRenderTarget = null, this._blurMaterial = function(t3) {
      const e2 = new Float32Array(t3), n2 = new At(0, 1, 0);
      return new oi({ name: "SphericalGaussianBlur", defines: { n: t3 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e2 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n2 } }, vertexShader: Ai(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Ri()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: 0, depthTest: false, depthWrite: false });
    }(20), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(t2, e2 = 0, n2 = 0.1, i2 = 100) {
    vi = this._renderer.getRenderTarget();
    const r2 = this._allocateTargets();
    return this._sceneToCubeUV(t2, n2, i2, r2), e2 > 0 && this._blur(r2, 0, 0, e2), this._applyPMREM(r2), this._cleanup(r2), r2;
  }
  fromEquirectangular(t2) {
    return this._fromTexture(t2);
  }
  fromCubemap(t2) {
    return this._fromTexture(t2);
  }
  compileCubemapShader() {
    this._cubemapShader === null && (this._cubemapShader = Ei(), this._compileMaterial(this._cubemapShader));
  }
  compileEquirectangularShader() {
    this._equirectShader === null && (this._equirectShader = Ti(), this._compileMaterial(this._equirectShader));
  }
  dispose() {
    this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
    for (let t2 = 0; t2 < pi.length; t2++)
      pi[t2].dispose();
  }
  _cleanup(t2) {
    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(vi), t2.scissorTest = false, Si(t2, 0, 0, t2.width, t2.height);
  }
  _fromTexture(t2) {
    vi = this._renderer.getRenderTarget();
    const e2 = this._allocateTargets(t2);
    return this._textureToCubeUV(t2, e2), this._applyPMREM(e2), this._cleanup(e2), e2;
  }
  _allocateTargets(t2) {
    const e2 = { magFilter: 1006, minFilter: 1006, generateMipmaps: false, type: 1016, format: 1023, encoding: 3e3, depthBuffer: false }, n2 = Mi(e2);
    return n2.depthBuffer = !t2, this._pingPongRenderTarget = Mi(e2), n2;
  }
  _compileMaterial(t2) {
    const e2 = new Ln(pi[0], t2);
    this._renderer.compile(e2, di);
  }
  _sceneToCubeUV(t2, e2, n2, i2) {
    const r2 = new Un(90, 1, e2, n2), s2 = [1, -1, 1, 1, 1, 1], a2 = [1, 1, 1, -1, -1, -1], o2 = this._renderer, l2 = o2.autoClear, c2 = o2.toneMapping;
    o2.getClearColor(gi), o2.toneMapping = 0, o2.autoClear = false;
    const h2 = new Je({ name: "PMREM.Background", side: 1, depthWrite: false, depthTest: false }), u2 = new Ln(new Pn(), h2);
    let d2 = false;
    const p2 = t2.background;
    p2 ? p2.isColor && (h2.color.copy(p2), t2.background = null, d2 = true) : (h2.color.copy(gi), d2 = true);
    for (let e3 = 0; e3 < 6; e3++) {
      const n3 = e3 % 3;
      n3 == 0 ? (r2.up.set(0, s2[e3], 0), r2.lookAt(a2[e3], 0, 0)) : n3 == 1 ? (r2.up.set(0, 0, s2[e3]), r2.lookAt(0, a2[e3], 0)) : (r2.up.set(0, s2[e3], 0), r2.lookAt(0, 0, a2[e3])), Si(i2, n3 * li, e3 > 2 ? li : 0, li, li), o2.setRenderTarget(i2), d2 && o2.render(u2, r2), o2.render(t2, r2);
    }
    u2.geometry.dispose(), u2.material.dispose(), o2.toneMapping = c2, o2.autoClear = l2, t2.background = p2;
  }
  _setEncoding(t2, e2) {
    this._renderer.capabilities.isWebGL2 === true && e2.format === 1023 && e2.type === 1009 && e2.encoding === 3001 ? t2.value = ui[3e3] : t2.value = ui[e2.encoding];
  }
  _textureToCubeUV(t2, e2) {
    const n2 = this._renderer, i2 = t2.mapping === 301 || t2.mapping === 302;
    i2 ? this._cubemapShader == null && (this._cubemapShader = Ei()) : this._equirectShader == null && (this._equirectShader = Ti());
    const r2 = i2 ? this._cubemapShader : this._equirectShader, s2 = new Ln(pi[0], r2), a2 = r2.uniforms;
    a2.envMap.value = t2, i2 || a2.texelSize.value.set(1 / t2.image.width, 1 / t2.image.height), this._setEncoding(a2.inputEncoding, t2), Si(e2, 0, 0, 3 * li, 2 * li), n2.setRenderTarget(e2), n2.render(s2, di);
  }
  _applyPMREM(t2) {
    const e2 = this._renderer, n2 = e2.autoClear;
    e2.autoClear = false;
    for (let e3 = 1; e3 < hi; e3++) {
      const n3 = Math.sqrt(fi[e3] * fi[e3] - fi[e3 - 1] * fi[e3 - 1]), i2 = bi[(e3 - 1) % bi.length];
      this._blur(t2, e3 - 1, e3, n3, i2);
    }
    e2.autoClear = n2;
  }
  _blur(t2, e2, n2, i2, r2) {
    const s2 = this._pingPongRenderTarget;
    this._halfBlur(t2, s2, e2, n2, i2, "latitudinal", r2), this._halfBlur(s2, t2, n2, n2, i2, "longitudinal", r2);
  }
  _halfBlur(t2, e2, n2, i2, r2, s2, a2) {
    const o2 = this._renderer, l2 = this._blurMaterial;
    s2 !== "latitudinal" && s2 !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const c2 = new Ln(pi[i2], l2), h2 = l2.uniforms, u2 = mi[n2] - 1, d2 = isFinite(r2) ? Math.PI / (2 * u2) : 2 * Math.PI / 39, p2 = r2 / d2, m2 = isFinite(r2) ? 1 + Math.floor(3 * p2) : 20;
    m2 > 20 && console.warn(`sigmaRadians, ${r2}, is too large and will clip, as it requested ${m2} samples when the maximum is set to 20`);
    const f2 = [];
    let g2 = 0;
    for (let t3 = 0; t3 < 20; ++t3) {
      const e3 = t3 / p2, n3 = Math.exp(-e3 * e3 / 2);
      f2.push(n3), t3 == 0 ? g2 += n3 : t3 < m2 && (g2 += 2 * n3);
    }
    for (let t3 = 0; t3 < f2.length; t3++)
      f2[t3] = f2[t3] / g2;
    h2.envMap.value = t2.texture, h2.samples.value = m2, h2.weights.value = f2, h2.latitudinal.value = s2 === "latitudinal", a2 && (h2.poleAxis.value = a2), h2.dTheta.value = d2, h2.mipInt.value = 8 - n2;
    const v2 = mi[i2];
    Si(e2, 3 * Math.max(0, li - 2 * v2), (i2 === 0 ? 0 : 2 * li) + 2 * v2 * (i2 > 4 ? i2 - 8 + 4 : 0), 3 * v2, 2 * v2), o2.setRenderTarget(e2), o2.render(c2, di);
  }
}
function _i() {
  const t2 = [], e2 = [], n2 = [];
  let i2 = 8;
  for (let r2 = 0; r2 < hi; r2++) {
    const s2 = Math.pow(2, i2);
    e2.push(s2);
    let a2 = 1 / s2;
    r2 > 4 ? a2 = ci[r2 - 8 + 4 - 1] : r2 == 0 && (a2 = 0), n2.push(a2);
    const o2 = 1 / (s2 - 1), l2 = -o2 / 2, c2 = 1 + o2 / 2, h2 = [l2, l2, c2, l2, c2, c2, l2, l2, c2, c2, l2, c2], u2 = 6, d2 = 6, p2 = 3, m2 = 2, f2 = 1, g2 = new Float32Array(p2 * d2 * u2), v2 = new Float32Array(m2 * d2 * u2), y2 = new Float32Array(f2 * d2 * u2);
    for (let t3 = 0; t3 < u2; t3++) {
      const e3 = t3 % 3 * 2 / 3 - 1, n3 = t3 > 2 ? 0 : -1, i3 = [e3, n3, 0, e3 + 2 / 3, n3, 0, e3 + 2 / 3, n3 + 1, 0, e3, n3, 0, e3 + 2 / 3, n3 + 1, 0, e3, n3 + 1, 0];
      g2.set(i3, p2 * d2 * t3), v2.set(h2, m2 * d2 * t3);
      const r3 = [t3, t3, t3, t3, t3, t3];
      y2.set(r3, f2 * d2 * t3);
    }
    const x2 = new un();
    x2.setAttribute("position", new Qe(g2, p2)), x2.setAttribute("uv", new Qe(v2, m2)), x2.setAttribute("faceIndex", new Qe(y2, f2)), t2.push(x2), i2 > 4 && i2--;
  }
  return { _lodPlanes: t2, _sizeLods: e2, _sigmas: n2 };
}
function Mi(t2) {
  const e2 = new St(3 * li, 3 * li, t2);
  return e2.texture.mapping = 306, e2.texture.name = "PMREM.cubeUv", e2.scissorTest = true, e2;
}
function Si(t2, e2, n2, i2, r2) {
  t2.viewport.set(e2, n2, i2, r2), t2.scissor.set(e2, n2, i2, r2);
}
function Ti() {
  const t2 = new mt(1, 1);
  return new oi({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: t2 }, inputEncoding: { value: ui[3e3] } }, vertexShader: Ai(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Ri()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

			}
		`, blending: 0, depthTest: false, depthWrite: false });
}
function Ei() {
  return new oi({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: ui[3e3] } }, vertexShader: Ai(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Ri()}

			void main() {

				gl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );

			}
		`, blending: 0, depthTest: false, depthWrite: false });
}
function Ai() {
  return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
}
function Ri() {
  return "\n\n		uniform int inputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else {\n\n				return sRGBToLinear( value );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	";
}
function Li(t2) {
  let e2 = /* @__PURE__ */ new WeakMap(), n2 = null;
  function i2(t3) {
    const n3 = t3.target;
    n3.removeEventListener("dispose", i2);
    const r2 = e2.get(n3);
    r2 !== void 0 && (e2.delete(n3), r2.dispose());
  }
  return { get: function(r2) {
    if (r2 && r2.isTexture && r2.isRenderTargetTexture === false) {
      const s2 = r2.mapping, a2 = s2 === 303 || s2 === 304, o2 = s2 === 301 || s2 === 302;
      if (a2 || o2) {
        if (e2.has(r2))
          return e2.get(r2).texture;
        {
          const s3 = r2.image;
          if (a2 && s3 && s3.height > 0 || o2 && s3 && function(t3) {
            let e3 = 0;
            const n3 = 6;
            for (let i3 = 0; i3 < n3; i3++)
              t3[i3] !== void 0 && e3++;
            return e3 === n3;
          }(s3)) {
            const s4 = t2.getRenderTarget();
            n2 === null && (n2 = new wi(t2));
            const o3 = a2 ? n2.fromEquirectangular(r2) : n2.fromCubemap(r2);
            return e2.set(r2, o3), t2.setRenderTarget(s4), r2.addEventListener("dispose", i2), o3.texture;
          }
          return null;
        }
      }
    }
    return r2;
  }, dispose: function() {
    e2 = /* @__PURE__ */ new WeakMap(), n2 !== null && (n2.dispose(), n2 = null);
  } };
}
function Ci(t2) {
  const e2 = {};
  function n2(n3) {
    if (e2[n3] !== void 0)
      return e2[n3];
    let i2;
    switch (n3) {
      case "WEBGL_depth_texture":
        i2 = t2.getExtension("WEBGL_depth_texture") || t2.getExtension("MOZ_WEBGL_depth_texture") || t2.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i2 = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i2 = t2.getExtension("WEBGL_compressed_texture_s3tc") || t2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i2 = t2.getExtension("WEBGL_compressed_texture_pvrtc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i2 = t2.getExtension(n3);
    }
    return e2[n3] = i2, i2;
  }
  return { has: function(t3) {
    return n2(t3) !== null;
  }, init: function(t3) {
    t3.isWebGL2 ? n2("EXT_color_buffer_float") : (n2("WEBGL_depth_texture"), n2("OES_texture_float"), n2("OES_texture_half_float"), n2("OES_texture_half_float_linear"), n2("OES_standard_derivatives"), n2("OES_element_index_uint"), n2("OES_vertex_array_object"), n2("ANGLE_instanced_arrays")), n2("OES_texture_float_linear"), n2("EXT_color_buffer_half_float"), n2("WEBGL_multisampled_render_to_texture");
  }, get: function(t3) {
    const e3 = n2(t3);
    return e3 === null && console.warn("THREE.WebGLRenderer: " + t3 + " extension not supported."), e3;
  } };
}
function Pi(t2, e2, n2, i2) {
  const r2 = {}, s2 = /* @__PURE__ */ new WeakMap();
  function a2(t3) {
    const o3 = t3.target;
    o3.index !== null && e2.remove(o3.index);
    for (const t4 in o3.attributes)
      e2.remove(o3.attributes[t4]);
    o3.removeEventListener("dispose", a2), delete r2[o3.id];
    const l2 = s2.get(o3);
    l2 && (e2.remove(l2), s2.delete(o3)), i2.releaseStatesOfGeometry(o3), o3.isInstancedBufferGeometry === true && delete o3._maxInstanceCount, n2.memory.geometries--;
  }
  function o2(t3) {
    const n3 = [], i3 = t3.index, r3 = t3.attributes.position;
    let a3 = 0;
    if (i3 !== null) {
      const t4 = i3.array;
      a3 = i3.version;
      for (let e3 = 0, i4 = t4.length; e3 < i4; e3 += 3) {
        const i5 = t4[e3 + 0], r4 = t4[e3 + 1], s3 = t4[e3 + 2];
        n3.push(i5, r4, r4, s3, s3, i5);
      }
    } else {
      const t4 = r3.array;
      a3 = r3.version;
      for (let e3 = 0, i4 = t4.length / 3 - 1; e3 < i4; e3 += 3) {
        const t5 = e3 + 0, i5 = e3 + 1, r4 = e3 + 2;
        n3.push(t5, i5, i5, r4, r4, t5);
      }
    }
    const o3 = new (gt(n3) > 65535 ? en : tn)(n3, 1);
    o3.version = a3;
    const l2 = s2.get(t3);
    l2 && e2.remove(l2), s2.set(t3, o3);
  }
  return { get: function(t3, e3) {
    return r2[e3.id] === true || (e3.addEventListener("dispose", a2), r2[e3.id] = true, n2.memory.geometries++), e3;
  }, update: function(t3) {
    const n3 = t3.attributes;
    for (const t4 in n3)
      e2.update(n3[t4], 34962);
    const i3 = t3.morphAttributes;
    for (const t4 in i3) {
      const n4 = i3[t4];
      for (let t5 = 0, i4 = n4.length; t5 < i4; t5++)
        e2.update(n4[t5], 34962);
    }
  }, getWireframeAttribute: function(t3) {
    const e3 = s2.get(t3);
    if (e3) {
      const n3 = t3.index;
      n3 !== null && e3.version < n3.version && o2(t3);
    } else
      o2(t3);
    return s2.get(t3);
  } };
}
function Ii(t2, e2, n2, i2) {
  const r2 = i2.isWebGL2;
  let s2, a2, o2;
  this.setMode = function(t3) {
    s2 = t3;
  }, this.setIndex = function(t3) {
    a2 = t3.type, o2 = t3.bytesPerElement;
  }, this.render = function(e3, i3) {
    t2.drawElements(s2, i3, a2, e3 * o2), n2.update(i3, s2, 1);
  }, this.renderInstances = function(i3, l2, c2) {
    if (c2 === 0)
      return;
    let h2, u2;
    if (r2)
      h2 = t2, u2 = "drawElementsInstanced";
    else if (h2 = e2.get("ANGLE_instanced_arrays"), u2 = "drawElementsInstancedANGLE", h2 === null)
      return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    h2[u2](s2, l2, a2, i3 * o2, c2), n2.update(l2, s2, c2);
  };
}
function Di(t2) {
  const e2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return { memory: { geometries: 0, textures: 0 }, render: e2, programs: null, autoReset: true, reset: function() {
    e2.frame++, e2.calls = 0, e2.triangles = 0, e2.points = 0, e2.lines = 0;
  }, update: function(t3, n2, i2) {
    switch (e2.calls++, n2) {
      case 4:
        e2.triangles += i2 * (t3 / 3);
        break;
      case 1:
        e2.lines += i2 * (t3 / 2);
        break;
      case 3:
        e2.lines += i2 * (t3 - 1);
        break;
      case 2:
        e2.lines += i2 * t3;
        break;
      case 0:
        e2.points += i2 * t3;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", n2);
    }
  } };
}
class Ni extends wt {
  constructor(t2 = null, e2 = 1, n2 = 1, i2 = 1) {
    super(null), this.image = { data: t2, width: e2, height: n2, depth: i2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
function Fi(t2, e2) {
  return t2[0] - e2[0];
}
function Oi(t2, e2) {
  return Math.abs(e2[1]) - Math.abs(t2[1]);
}
function Ui(t2, e2) {
  let n2 = 1;
  const i2 = e2.isInterleavedBufferAttribute ? e2.data.array : e2.array;
  i2 instanceof Int8Array ? n2 = 127 : i2 instanceof Int16Array ? n2 = 32767 : i2 instanceof Int32Array ? n2 = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i2), t2.divideScalar(n2);
}
function ki(t2, e2, n2) {
  const i2 = {}, r2 = new Float32Array(8), s2 = /* @__PURE__ */ new WeakMap(), a2 = new At(), o2 = [];
  for (let t3 = 0; t3 < 8; t3++)
    o2[t3] = [t3, 0];
  return { update: function(l2, c2, h2, u2) {
    const d2 = l2.morphTargetInfluences;
    if (e2.isWebGL2 === true) {
      const i3 = c2.morphAttributes.position.length;
      let r3 = s2.get(c2);
      if (r3 === void 0 || r3.count !== i3) {
        r3 !== void 0 && r3.texture.dispose();
        const t3 = c2.morphAttributes.normal !== void 0, n3 = c2.morphAttributes.position, o4 = c2.morphAttributes.normal || [], l4 = t3 === true ? 2 : 1;
        let h3 = c2.attributes.position.count * l4, u3 = 1;
        h3 > e2.maxTextureSize && (u3 = Math.ceil(h3 / e2.maxTextureSize), h3 = e2.maxTextureSize);
        const d3 = new Float32Array(h3 * u3 * 4 * i3), p2 = new Ni(d3, h3, u3, i3);
        p2.format = 1023, p2.type = 1015, p2.needsUpdate = true;
        const m2 = 4 * l4;
        for (let e3 = 0; e3 < i3; e3++) {
          const i4 = n3[e3], r4 = o4[e3], s3 = h3 * u3 * 4 * e3;
          for (let e4 = 0; e4 < i4.count; e4++) {
            a2.fromBufferAttribute(i4, e4), i4.normalized === true && Ui(a2, i4);
            const n4 = e4 * m2;
            d3[s3 + n4 + 0] = a2.x, d3[s3 + n4 + 1] = a2.y, d3[s3 + n4 + 2] = a2.z, d3[s3 + n4 + 3] = 0, t3 === true && (a2.fromBufferAttribute(r4, e4), r4.normalized === true && Ui(a2, r4), d3[s3 + n4 + 4] = a2.x, d3[s3 + n4 + 5] = a2.y, d3[s3 + n4 + 6] = a2.z, d3[s3 + n4 + 7] = 0);
          }
        }
        r3 = { count: i3, texture: p2, size: new mt(h3, u3) }, s2.set(c2, r3);
      }
      let o3 = 0;
      for (let t3 = 0; t3 < d2.length; t3++)
        o3 += d2[t3];
      const l3 = c2.morphTargetsRelative ? 1 : 1 - o3;
      u2.getUniforms().setValue(t2, "morphTargetBaseInfluence", l3), u2.getUniforms().setValue(t2, "morphTargetInfluences", d2), u2.getUniforms().setValue(t2, "morphTargetsTexture", r3.texture, n2), u2.getUniforms().setValue(t2, "morphTargetsTextureSize", r3.size);
    } else {
      const e3 = d2 === void 0 ? 0 : d2.length;
      let n3 = i2[c2.id];
      if (n3 === void 0 || n3.length !== e3) {
        n3 = [];
        for (let t3 = 0; t3 < e3; t3++)
          n3[t3] = [t3, 0];
        i2[c2.id] = n3;
      }
      for (let t3 = 0; t3 < e3; t3++) {
        const e4 = n3[t3];
        e4[0] = t3, e4[1] = d2[t3];
      }
      n3.sort(Oi);
      for (let t3 = 0; t3 < 8; t3++)
        t3 < e3 && n3[t3][1] ? (o2[t3][0] = n3[t3][0], o2[t3][1] = n3[t3][1]) : (o2[t3][0] = Number.MAX_SAFE_INTEGER, o2[t3][1] = 0);
      o2.sort(Fi);
      const s3 = c2.morphAttributes.position, a3 = c2.morphAttributes.normal;
      let l3 = 0;
      for (let t3 = 0; t3 < 8; t3++) {
        const e4 = o2[t3], n4 = e4[0], i3 = e4[1];
        n4 !== Number.MAX_SAFE_INTEGER && i3 ? (s3 && c2.getAttribute("morphTarget" + t3) !== s3[n4] && c2.setAttribute("morphTarget" + t3, s3[n4]), a3 && c2.getAttribute("morphNormal" + t3) !== a3[n4] && c2.setAttribute("morphNormal" + t3, a3[n4]), r2[t3] = i3, l3 += i3) : (s3 && c2.hasAttribute("morphTarget" + t3) === true && c2.deleteAttribute("morphTarget" + t3), a3 && c2.hasAttribute("morphNormal" + t3) === true && c2.deleteAttribute("morphNormal" + t3), r2[t3] = 0);
      }
      const h3 = c2.morphTargetsRelative ? 1 : 1 - l3;
      u2.getUniforms().setValue(t2, "morphTargetBaseInfluence", h3), u2.getUniforms().setValue(t2, "morphTargetInfluences", r2);
    }
  } };
}
function zi(t2, e2, n2, i2) {
  let r2 = /* @__PURE__ */ new WeakMap();
  function s2(t3) {
    const e3 = t3.target;
    e3.removeEventListener("dispose", s2), n2.remove(e3.instanceMatrix), e3.instanceColor !== null && n2.remove(e3.instanceColor);
  }
  return { update: function(t3) {
    const a2 = i2.render.frame, o2 = t3.geometry, l2 = e2.get(t3, o2);
    return r2.get(l2) !== a2 && (e2.update(l2), r2.set(l2, a2)), t3.isInstancedMesh && (t3.hasEventListener("dispose", s2) === false && t3.addEventListener("dispose", s2), n2.update(t3.instanceMatrix, 34962), t3.instanceColor !== null && n2.update(t3.instanceColor, 34962)), l2;
  }, dispose: function() {
    r2 = /* @__PURE__ */ new WeakMap();
  } };
}
Ni.prototype.isDataTexture2DArray = true;
class Bi extends wt {
  constructor(t2 = null, e2 = 1, n2 = 1, i2 = 1) {
    super(null), this.image = { data: t2, width: e2, height: n2, depth: i2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
Bi.prototype.isDataTexture3D = true;
const Hi = new wt(), Vi = new Ni(), Gi = new Bi(), Wi = new zn(), ji = [], qi = [], Xi = new Float32Array(16), Yi = new Float32Array(9), Zi = new Float32Array(4);
function Ji(t2, e2, n2) {
  const i2 = t2[0];
  if (i2 <= 0 || i2 > 0)
    return t2;
  const r2 = e2 * n2;
  let s2 = ji[r2];
  if (s2 === void 0 && (s2 = new Float32Array(r2), ji[r2] = s2), e2 !== 0) {
    i2.toArray(s2, 0);
    for (let i3 = 1, r3 = 0; i3 !== e2; ++i3)
      r3 += n2, t2[i3].toArray(s2, r3);
  }
  return s2;
}
function $i(t2, e2) {
  if (t2.length !== e2.length)
    return false;
  for (let n2 = 0, i2 = t2.length; n2 < i2; n2++)
    if (t2[n2] !== e2[n2])
      return false;
  return true;
}
function Ki(t2, e2) {
  for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
    t2[n2] = e2[n2];
}
function Qi(t2, e2) {
  let n2 = qi[e2];
  n2 === void 0 && (n2 = new Int32Array(e2), qi[e2] = n2);
  for (let i2 = 0; i2 !== e2; ++i2)
    n2[i2] = t2.allocateTextureUnit();
  return n2;
}
function tr(t2, e2) {
  const n2 = this.cache;
  n2[0] !== e2 && (t2.uniform1f(this.addr, e2), n2[0] = e2);
}
function er(t2, e2) {
  const n2 = this.cache;
  if (e2.x !== void 0)
    n2[0] === e2.x && n2[1] === e2.y || (t2.uniform2f(this.addr, e2.x, e2.y), n2[0] = e2.x, n2[1] = e2.y);
  else {
    if ($i(n2, e2))
      return;
    t2.uniform2fv(this.addr, e2), Ki(n2, e2);
  }
}
function nr(t2, e2) {
  const n2 = this.cache;
  if (e2.x !== void 0)
    n2[0] === e2.x && n2[1] === e2.y && n2[2] === e2.z || (t2.uniform3f(this.addr, e2.x, e2.y, e2.z), n2[0] = e2.x, n2[1] = e2.y, n2[2] = e2.z);
  else if (e2.r !== void 0)
    n2[0] === e2.r && n2[1] === e2.g && n2[2] === e2.b || (t2.uniform3f(this.addr, e2.r, e2.g, e2.b), n2[0] = e2.r, n2[1] = e2.g, n2[2] = e2.b);
  else {
    if ($i(n2, e2))
      return;
    t2.uniform3fv(this.addr, e2), Ki(n2, e2);
  }
}
function ir(t2, e2) {
  const n2 = this.cache;
  if (e2.x !== void 0)
    n2[0] === e2.x && n2[1] === e2.y && n2[2] === e2.z && n2[3] === e2.w || (t2.uniform4f(this.addr, e2.x, e2.y, e2.z, e2.w), n2[0] = e2.x, n2[1] = e2.y, n2[2] = e2.z, n2[3] = e2.w);
  else {
    if ($i(n2, e2))
      return;
    t2.uniform4fv(this.addr, e2), Ki(n2, e2);
  }
}
function rr(t2, e2) {
  const n2 = this.cache, i2 = e2.elements;
  if (i2 === void 0) {
    if ($i(n2, e2))
      return;
    t2.uniformMatrix2fv(this.addr, false, e2), Ki(n2, e2);
  } else {
    if ($i(n2, i2))
      return;
    Zi.set(i2), t2.uniformMatrix2fv(this.addr, false, Zi), Ki(n2, i2);
  }
}
function sr(t2, e2) {
  const n2 = this.cache, i2 = e2.elements;
  if (i2 === void 0) {
    if ($i(n2, e2))
      return;
    t2.uniformMatrix3fv(this.addr, false, e2), Ki(n2, e2);
  } else {
    if ($i(n2, i2))
      return;
    Yi.set(i2), t2.uniformMatrix3fv(this.addr, false, Yi), Ki(n2, i2);
  }
}
function ar(t2, e2) {
  const n2 = this.cache, i2 = e2.elements;
  if (i2 === void 0) {
    if ($i(n2, e2))
      return;
    t2.uniformMatrix4fv(this.addr, false, e2), Ki(n2, e2);
  } else {
    if ($i(n2, i2))
      return;
    Xi.set(i2), t2.uniformMatrix4fv(this.addr, false, Xi), Ki(n2, i2);
  }
}
function or(t2, e2) {
  const n2 = this.cache;
  n2[0] !== e2 && (t2.uniform1i(this.addr, e2), n2[0] = e2);
}
function lr(t2, e2) {
  const n2 = this.cache;
  $i(n2, e2) || (t2.uniform2iv(this.addr, e2), Ki(n2, e2));
}
function cr(t2, e2) {
  const n2 = this.cache;
  $i(n2, e2) || (t2.uniform3iv(this.addr, e2), Ki(n2, e2));
}
function hr(t2, e2) {
  const n2 = this.cache;
  $i(n2, e2) || (t2.uniform4iv(this.addr, e2), Ki(n2, e2));
}
function ur(t2, e2) {
  const n2 = this.cache;
  n2[0] !== e2 && (t2.uniform1ui(this.addr, e2), n2[0] = e2);
}
function dr(t2, e2) {
  const n2 = this.cache;
  $i(n2, e2) || (t2.uniform2uiv(this.addr, e2), Ki(n2, e2));
}
function pr(t2, e2) {
  const n2 = this.cache;
  $i(n2, e2) || (t2.uniform3uiv(this.addr, e2), Ki(n2, e2));
}
function mr(t2, e2) {
  const n2 = this.cache;
  $i(n2, e2) || (t2.uniform4uiv(this.addr, e2), Ki(n2, e2));
}
function fr(t2, e2, n2) {
  const i2 = this.cache, r2 = n2.allocateTextureUnit();
  i2[0] !== r2 && (t2.uniform1i(this.addr, r2), i2[0] = r2), n2.safeSetTexture2D(e2 || Hi, r2);
}
function gr(t2, e2, n2) {
  const i2 = this.cache, r2 = n2.allocateTextureUnit();
  i2[0] !== r2 && (t2.uniform1i(this.addr, r2), i2[0] = r2), n2.setTexture3D(e2 || Gi, r2);
}
function vr(t2, e2, n2) {
  const i2 = this.cache, r2 = n2.allocateTextureUnit();
  i2[0] !== r2 && (t2.uniform1i(this.addr, r2), i2[0] = r2), n2.safeSetTextureCube(e2 || Wi, r2);
}
function yr(t2, e2, n2) {
  const i2 = this.cache, r2 = n2.allocateTextureUnit();
  i2[0] !== r2 && (t2.uniform1i(this.addr, r2), i2[0] = r2), n2.setTexture2DArray(e2 || Vi, r2);
}
function xr(t2, e2) {
  t2.uniform1fv(this.addr, e2);
}
function br(t2, e2) {
  const n2 = Ji(e2, this.size, 2);
  t2.uniform2fv(this.addr, n2);
}
function wr(t2, e2) {
  const n2 = Ji(e2, this.size, 3);
  t2.uniform3fv(this.addr, n2);
}
function _r(t2, e2) {
  const n2 = Ji(e2, this.size, 4);
  t2.uniform4fv(this.addr, n2);
}
function Mr(t2, e2) {
  const n2 = Ji(e2, this.size, 4);
  t2.uniformMatrix2fv(this.addr, false, n2);
}
function Sr(t2, e2) {
  const n2 = Ji(e2, this.size, 9);
  t2.uniformMatrix3fv(this.addr, false, n2);
}
function Tr(t2, e2) {
  const n2 = Ji(e2, this.size, 16);
  t2.uniformMatrix4fv(this.addr, false, n2);
}
function Er(t2, e2) {
  t2.uniform1iv(this.addr, e2);
}
function Ar(t2, e2) {
  t2.uniform2iv(this.addr, e2);
}
function Rr(t2, e2) {
  t2.uniform3iv(this.addr, e2);
}
function Lr(t2, e2) {
  t2.uniform4iv(this.addr, e2);
}
function Cr(t2, e2) {
  t2.uniform1uiv(this.addr, e2);
}
function Pr(t2, e2) {
  t2.uniform2uiv(this.addr, e2);
}
function Ir(t2, e2) {
  t2.uniform3uiv(this.addr, e2);
}
function Dr(t2, e2) {
  t2.uniform4uiv(this.addr, e2);
}
function Nr(t2, e2, n2) {
  const i2 = e2.length, r2 = Qi(n2, i2);
  t2.uniform1iv(this.addr, r2);
  for (let t3 = 0; t3 !== i2; ++t3)
    n2.safeSetTexture2D(e2[t3] || Hi, r2[t3]);
}
function Fr(t2, e2, n2) {
  const i2 = e2.length, r2 = Qi(n2, i2);
  t2.uniform1iv(this.addr, r2);
  for (let t3 = 0; t3 !== i2; ++t3)
    n2.setTexture3D(e2[t3] || Gi, r2[t3]);
}
function Or(t2, e2, n2) {
  const i2 = e2.length, r2 = Qi(n2, i2);
  t2.uniform1iv(this.addr, r2);
  for (let t3 = 0; t3 !== i2; ++t3)
    n2.safeSetTextureCube(e2[t3] || Wi, r2[t3]);
}
function Ur(t2, e2, n2) {
  const i2 = e2.length, r2 = Qi(n2, i2);
  t2.uniform1iv(this.addr, r2);
  for (let t3 = 0; t3 !== i2; ++t3)
    n2.setTexture2DArray(e2[t3] || Vi, r2[t3]);
}
function kr(t2, e2, n2) {
  this.id = t2, this.addr = n2, this.cache = [], this.setValue = function(t3) {
    switch (t3) {
      case 5126:
        return tr;
      case 35664:
        return er;
      case 35665:
        return nr;
      case 35666:
        return ir;
      case 35674:
        return rr;
      case 35675:
        return sr;
      case 35676:
        return ar;
      case 5124:
      case 35670:
        return or;
      case 35667:
      case 35671:
        return lr;
      case 35668:
      case 35672:
        return cr;
      case 35669:
      case 35673:
        return hr;
      case 5125:
        return ur;
      case 36294:
        return dr;
      case 36295:
        return pr;
      case 36296:
        return mr;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return fr;
      case 35679:
      case 36299:
      case 36307:
        return gr;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return vr;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return yr;
    }
  }(e2.type);
}
function zr(t2, e2, n2) {
  this.id = t2, this.addr = n2, this.cache = [], this.size = e2.size, this.setValue = function(t3) {
    switch (t3) {
      case 5126:
        return xr;
      case 35664:
        return br;
      case 35665:
        return wr;
      case 35666:
        return _r;
      case 35674:
        return Mr;
      case 35675:
        return Sr;
      case 35676:
        return Tr;
      case 5124:
      case 35670:
        return Er;
      case 35667:
      case 35671:
        return Ar;
      case 35668:
      case 35672:
        return Rr;
      case 35669:
      case 35673:
        return Lr;
      case 5125:
        return Cr;
      case 36294:
        return Pr;
      case 36295:
        return Ir;
      case 36296:
        return Dr;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Nr;
      case 35679:
      case 36299:
      case 36307:
        return Fr;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Or;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Ur;
    }
  }(e2.type);
}
function Br(t2) {
  this.id = t2, this.seq = [], this.map = {};
}
zr.prototype.updateCache = function(t2) {
  const e2 = this.cache;
  t2 instanceof Float32Array && e2.length !== t2.length && (this.cache = new Float32Array(t2.length)), Ki(e2, t2);
}, Br.prototype.setValue = function(t2, e2, n2) {
  const i2 = this.seq;
  for (let r2 = 0, s2 = i2.length; r2 !== s2; ++r2) {
    const s3 = i2[r2];
    s3.setValue(t2, e2[s3.id], n2);
  }
};
const Hr = /(\w+)(\])?(\[|\.)?/g;
function Vr(t2, e2) {
  t2.seq.push(e2), t2.map[e2.id] = e2;
}
function Gr(t2, e2, n2) {
  const i2 = t2.name, r2 = i2.length;
  for (Hr.lastIndex = 0; ; ) {
    const s2 = Hr.exec(i2), a2 = Hr.lastIndex;
    let o2 = s2[1];
    const l2 = s2[2] === "]", c2 = s2[3];
    if (l2 && (o2 |= 0), c2 === void 0 || c2 === "[" && a2 + 2 === r2) {
      Vr(n2, c2 === void 0 ? new kr(o2, t2, e2) : new zr(o2, t2, e2));
      break;
    }
    {
      let t3 = n2.map[o2];
      t3 === void 0 && (t3 = new Br(o2), Vr(n2, t3)), n2 = t3;
    }
  }
}
function Wr(t2, e2) {
  this.seq = [], this.map = {};
  const n2 = t2.getProgramParameter(e2, 35718);
  for (let i2 = 0; i2 < n2; ++i2) {
    const n3 = t2.getActiveUniform(e2, i2);
    Gr(n3, t2.getUniformLocation(e2, n3.name), this);
  }
}
function jr(t2, e2, n2) {
  const i2 = t2.createShader(e2);
  return t2.shaderSource(i2, n2), t2.compileShader(i2), i2;
}
Wr.prototype.setValue = function(t2, e2, n2, i2) {
  const r2 = this.map[e2];
  r2 !== void 0 && r2.setValue(t2, n2, i2);
}, Wr.prototype.setOptional = function(t2, e2, n2) {
  const i2 = e2[n2];
  i2 !== void 0 && this.setValue(t2, n2, i2);
}, Wr.upload = function(t2, e2, n2, i2) {
  for (let r2 = 0, s2 = e2.length; r2 !== s2; ++r2) {
    const s3 = e2[r2], a2 = n2[s3.id];
    a2.needsUpdate !== false && s3.setValue(t2, a2.value, i2);
  }
}, Wr.seqWithValue = function(t2, e2) {
  const n2 = [];
  for (let i2 = 0, r2 = t2.length; i2 !== r2; ++i2) {
    const r3 = t2[i2];
    r3.id in e2 && n2.push(r3);
  }
  return n2;
};
let qr = 0;
function Xr(t2) {
  switch (t2) {
    case 3e3:
      return ["Linear", "( value )"];
    case 3001:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", t2), ["Linear", "( value )"];
  }
}
function Yr(t2, e2, n2) {
  const i2 = t2.getShaderParameter(e2, 35713), r2 = t2.getShaderInfoLog(e2).trim();
  return i2 && r2 === "" ? "" : n2.toUpperCase() + "\n\n" + r2 + "\n\n" + function(t3) {
    const e3 = t3.split("\n");
    for (let t4 = 0; t4 < e3.length; t4++)
      e3[t4] = t4 + 1 + ": " + e3[t4];
    return e3.join("\n");
  }(t2.getShaderSource(e2));
}
function Zr(t2, e2) {
  const n2 = Xr(e2);
  return "vec4 " + t2 + "( vec4 value ) { return " + n2[0] + "ToLinear" + n2[1] + "; }";
}
function Jr(t2, e2) {
  const n2 = Xr(e2);
  return "vec4 " + t2 + "( vec4 value ) { return LinearTo" + n2[0] + n2[1] + "; }";
}
function $r(t2, e2) {
  let n2;
  switch (e2) {
    case 1:
      n2 = "Linear";
      break;
    case 2:
      n2 = "Reinhard";
      break;
    case 3:
      n2 = "OptimizedCineon";
      break;
    case 4:
      n2 = "ACESFilmic";
      break;
    case 5:
      n2 = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e2), n2 = "Linear";
  }
  return "vec3 " + t2 + "( vec3 color ) { return " + n2 + "ToneMapping( color ); }";
}
function Kr(t2) {
  return t2 !== "";
}
function Qr(t2, e2) {
  return t2.replace(/NUM_DIR_LIGHTS/g, e2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e2.numPointLightShadows);
}
function ts(t2, e2) {
  return t2.replace(/NUM_CLIPPING_PLANES/g, e2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e2.numClippingPlanes - e2.numClipIntersection);
}
const es = /^[ \t]*#include +<([\w\d./]+)>/gm;
function ns(t2) {
  return t2.replace(es, is);
}
function is(t2, e2) {
  const n2 = $n[e2];
  if (n2 === void 0)
    throw new Error("Can not resolve #include <" + e2 + ">");
  return ns(n2);
}
const rs = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, ss = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function as(t2) {
  return t2.replace(ss, ls).replace(rs, os);
}
function os(t2, e2, n2, i2) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), ls(t2, e2, n2, i2);
}
function ls(t2, e2, n2, i2) {
  let r2 = "";
  for (let t3 = parseInt(e2); t3 < parseInt(n2); t3++)
    r2 += i2.replace(/\[\s*i\s*\]/g, "[ " + t3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t3);
  return r2;
}
function cs(t2) {
  let e2 = "precision " + t2.precision + " float;\nprecision " + t2.precision + " int;";
  return t2.precision === "highp" ? e2 += "\n#define HIGH_PRECISION" : t2.precision === "mediump" ? e2 += "\n#define MEDIUM_PRECISION" : t2.precision === "lowp" && (e2 += "\n#define LOW_PRECISION"), e2;
}
function hs(t2, e2, n2, i2) {
  const r2 = t2.getContext(), s2 = n2.defines;
  let a2 = n2.vertexShader, o2 = n2.fragmentShader;
  const l2 = function(t3) {
    let e3 = "SHADOWMAP_TYPE_BASIC";
    return t3.shadowMapType === 1 ? e3 = "SHADOWMAP_TYPE_PCF" : t3.shadowMapType === 2 ? e3 = "SHADOWMAP_TYPE_PCF_SOFT" : t3.shadowMapType === 3 && (e3 = "SHADOWMAP_TYPE_VSM"), e3;
  }(n2), c2 = function(t3) {
    let e3 = "ENVMAP_TYPE_CUBE";
    if (t3.envMap)
      switch (t3.envMapMode) {
        case 301:
        case 302:
          e3 = "ENVMAP_TYPE_CUBE";
          break;
        case 306:
        case 307:
          e3 = "ENVMAP_TYPE_CUBE_UV";
      }
    return e3;
  }(n2), h2 = function(t3) {
    let e3 = "ENVMAP_MODE_REFLECTION";
    if (t3.envMap)
      switch (t3.envMapMode) {
        case 302:
        case 307:
          e3 = "ENVMAP_MODE_REFRACTION";
      }
    return e3;
  }(n2), u2 = function(t3) {
    let e3 = "ENVMAP_BLENDING_NONE";
    if (t3.envMap)
      switch (t3.combine) {
        case 0:
          e3 = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          e3 = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          e3 = "ENVMAP_BLENDING_ADD";
      }
    return e3;
  }(n2), d2 = n2.isWebGL2 ? "" : function(t3) {
    return [t3.extensionDerivatives || t3.envMapCubeUV || t3.bumpMap || t3.tangentSpaceNormalMap || t3.clearcoatNormalMap || t3.flatShading || t3.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (t3.extensionFragDepth || t3.logarithmicDepthBuffer) && t3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t3.extensionDrawBuffers && t3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t3.extensionShaderTextureLOD || t3.envMap || t3.transmission) && t3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Kr).join("\n");
  }(n2), p2 = function(t3) {
    const e3 = [];
    for (const n3 in t3) {
      const i3 = t3[n3];
      i3 !== false && e3.push("#define " + n3 + " " + i3);
    }
    return e3.join("\n");
  }(s2), m2 = r2.createProgram();
  let f2, g2, v2 = n2.glslVersion ? "#version " + n2.glslVersion + "\n" : "";
  n2.isRawShaderMaterial ? (f2 = [p2].filter(Kr).join("\n"), f2.length > 0 && (f2 += "\n"), g2 = [d2, p2].filter(Kr).join("\n"), g2.length > 0 && (g2 += "\n")) : (f2 = [cs(n2), "#define SHADER_NAME " + n2.shaderName, p2, n2.instancing ? "#define USE_INSTANCING" : "", n2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n2.maxBones, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + h2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.displacementMap && n2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.transmission ? "#define USE_TRANSMISSION" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.thicknessMap ? "#define USE_THICKNESSMAP" : "", n2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.skinning ? "#define USE_SKINNING" : "", n2.useVertexTexture ? "#define BONE_TEXTURE" : "", n2.morphTargets ? "#define USE_MORPHTARGETS" : "", n2.morphNormals && n2.flatShading === false ? "#define USE_MORPHNORMALS" : "", n2.morphTargets && n2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n2.morphTargets && n2.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n2.morphTargetsCount : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + l2 : "", n2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Kr).join("\n"), g2 = [d2, cs(n2), "#define SHADER_NAME " + n2.shaderName, p2, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.matcap ? "#define USE_MATCAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + c2 : "", n2.envMap ? "#define " + h2 : "", n2.envMap ? "#define " + u2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoat ? "#define USE_CLEARCOAT" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.alphaTest ? "#define USE_ALPHATEST" : "", n2.sheen ? "#define USE_SHEEN" : "", n2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n2.transmission ? "#define USE_TRANSMISSION" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.thicknessMap ? "#define USE_THICKNESSMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors || n2.instancingColor ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.gradientMap ? "#define USE_GRADIENTMAP" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + l2 : "", n2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n2.extensionShaderTextureLOD || n2.envMap) && n2.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n2.toneMapping !== 0 ? "#define TONE_MAPPING" : "", n2.toneMapping !== 0 ? $n.tonemapping_pars_fragment : "", n2.toneMapping !== 0 ? $r("toneMapping", n2.toneMapping) : "", n2.dithering ? "#define DITHERING" : "", n2.format === 1022 ? "#define OPAQUE" : "", $n.encodings_pars_fragment, n2.map ? Zr("mapTexelToLinear", n2.mapEncoding) : "", n2.matcap ? Zr("matcapTexelToLinear", n2.matcapEncoding) : "", n2.envMap ? Zr("envMapTexelToLinear", n2.envMapEncoding) : "", n2.emissiveMap ? Zr("emissiveMapTexelToLinear", n2.emissiveMapEncoding) : "", n2.specularColorMap ? Zr("specularColorMapTexelToLinear", n2.specularColorMapEncoding) : "", n2.sheenColorMap ? Zr("sheenColorMapTexelToLinear", n2.sheenColorMapEncoding) : "", n2.lightMap ? Zr("lightMapTexelToLinear", n2.lightMapEncoding) : "", Jr("linearToOutputTexel", n2.outputEncoding), n2.depthPacking ? "#define DEPTH_PACKING " + n2.depthPacking : "", "\n"].filter(Kr).join("\n")), a2 = ns(a2), a2 = Qr(a2, n2), a2 = ts(a2, n2), o2 = ns(o2), o2 = Qr(o2, n2), o2 = ts(o2, n2), a2 = as(a2), o2 = as(o2), n2.isWebGL2 && n2.isRawShaderMaterial !== true && (v2 = "#version 300 es\n", f2 = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + f2, g2 = ["#define varying in", n2.glslVersion === "300 es" ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n2.glslVersion === "300 es" ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + g2);
  const y2 = v2 + g2 + o2, x2 = jr(r2, 35633, v2 + f2 + a2), b2 = jr(r2, 35632, y2);
  if (r2.attachShader(m2, x2), r2.attachShader(m2, b2), n2.index0AttributeName !== void 0 ? r2.bindAttribLocation(m2, 0, n2.index0AttributeName) : n2.morphTargets === true && r2.bindAttribLocation(m2, 0, "position"), r2.linkProgram(m2), t2.debug.checkShaderErrors) {
    const t3 = r2.getProgramInfoLog(m2).trim(), e3 = r2.getShaderInfoLog(x2).trim(), n3 = r2.getShaderInfoLog(b2).trim();
    let i3 = true, s3 = true;
    if (r2.getProgramParameter(m2, 35714) === false) {
      i3 = false;
      const e4 = Yr(r2, x2, "vertex"), n4 = Yr(r2, b2, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + r2.getError() + " - VALIDATE_STATUS " + r2.getProgramParameter(m2, 35715) + "\n\nProgram Info Log: " + t3 + "\n" + e4 + "\n" + n4);
    } else
      t3 !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", t3) : e3 !== "" && n3 !== "" || (s3 = false);
    s3 && (this.diagnostics = { runnable: i3, programLog: t3, vertexShader: { log: e3, prefix: f2 }, fragmentShader: { log: n3, prefix: g2 } });
  }
  let w2, _2;
  return r2.deleteShader(x2), r2.deleteShader(b2), this.getUniforms = function() {
    return w2 === void 0 && (w2 = new Wr(r2, m2)), w2;
  }, this.getAttributes = function() {
    return _2 === void 0 && (_2 = function(t3, e3) {
      const n3 = {}, i3 = t3.getProgramParameter(e3, 35721);
      for (let r3 = 0; r3 < i3; r3++) {
        const i4 = t3.getActiveAttrib(e3, r3), s3 = i4.name;
        let a3 = 1;
        i4.type === 35674 && (a3 = 2), i4.type === 35675 && (a3 = 3), i4.type === 35676 && (a3 = 4), n3[s3] = { type: i4.type, location: t3.getAttribLocation(e3, s3), locationSize: a3 };
      }
      return n3;
    }(r2, m2)), _2;
  }, this.destroy = function() {
    i2.releaseStatesOfProgram(this), r2.deleteProgram(m2), this.program = void 0;
  }, this.name = n2.shaderName, this.id = qr++, this.cacheKey = e2, this.usedTimes = 1, this.program = m2, this.vertexShader = x2, this.fragmentShader = b2, this;
}
let us = 0;
class ds {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(t2) {
    const e2 = t2.vertexShader, n2 = t2.fragmentShader, i2 = this._getShaderStage(e2), r2 = this._getShaderStage(n2), s2 = this._getShaderCacheForMaterial(t2);
    return s2.has(i2) === false && (s2.add(i2), i2.usedTimes++), s2.has(r2) === false && (s2.add(r2), r2.usedTimes++), this;
  }
  remove(t2) {
    const e2 = this.materialCache.get(t2);
    for (const t3 of e2)
      t3.usedTimes--, t3.usedTimes === 0 && this.shaderCache.delete(t3);
    return this.materialCache.delete(t2), this;
  }
  getVertexShaderID(t2) {
    return this._getShaderStage(t2.vertexShader).id;
  }
  getFragmentShaderID(t2) {
    return this._getShaderStage(t2.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t2) {
    const e2 = this.materialCache;
    return e2.has(t2) === false && e2.set(t2, /* @__PURE__ */ new Set()), e2.get(t2);
  }
  _getShaderStage(t2) {
    const e2 = this.shaderCache;
    if (e2.has(t2) === false) {
      const n2 = new ps();
      e2.set(t2, n2);
    }
    return e2.get(t2);
  }
}
class ps {
  constructor() {
    this.id = us++, this.usedTimes = 0;
  }
}
function ms(t2, e2, n2, i2, r2, s2, a2) {
  const o2 = new fe(), l2 = new ds(), c2 = [], h2 = r2.isWebGL2, u2 = r2.logarithmicDepthBuffer, d2 = r2.floatVertexTextures, p2 = r2.maxVertexUniforms, m2 = r2.vertexTextures;
  let f2 = r2.precision;
  const g2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function v2(t3) {
    let e3;
    return t3 && t3.isTexture ? e3 = t3.encoding : t3 && t3.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e3 = t3.texture.encoding) : e3 = 3e3, h2 && t3 && t3.isTexture && t3.format === 1023 && t3.type === 1009 && t3.encoding === 3001 && (e3 = 3e3), e3;
  }
  return { getParameters: function(s3, o3, c3, y2, x2) {
    const b2 = y2.fog, w2 = s3.isMeshStandardMaterial ? y2.environment : null, _2 = (s3.isMeshStandardMaterial ? n2 : e2).get(s3.envMap || w2), M2 = g2[s3.type], S2 = x2.isSkinnedMesh ? function(t3) {
      const e3 = t3.skeleton.bones;
      if (d2)
        return 1024;
      {
        const t4 = p2, n3 = Math.floor((t4 - 20) / 4), i3 = Math.min(n3, e3.length);
        return i3 < e3.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e3.length + " bones. This GPU supports " + i3 + "."), 0) : i3;
      }
    }(x2) : 0;
    let T2, E2, A2, R2;
    if (s3.precision !== null && (f2 = r2.getMaxPrecision(s3.precision), f2 !== s3.precision && console.warn("THREE.WebGLProgram.getParameters:", s3.precision, "not supported, using", f2, "instead.")), M2) {
      const t3 = Qn[M2];
      T2 = t3.vertexShader, E2 = t3.fragmentShader;
    } else
      T2 = s3.vertexShader, E2 = s3.fragmentShader, l2.update(s3), A2 = l2.getVertexShaderID(s3), R2 = l2.getFragmentShaderID(s3);
    const L2 = t2.getRenderTarget(), C2 = s3.alphaTest > 0, P2 = s3.clearcoat > 0;
    return { isWebGL2: h2, shaderID: M2, shaderName: s3.type, vertexShader: T2, fragmentShader: E2, defines: s3.defines, customVertexShaderID: A2, customFragmentShaderID: R2, isRawShaderMaterial: s3.isRawShaderMaterial === true, glslVersion: s3.glslVersion, precision: f2, instancing: x2.isInstancedMesh === true, instancingColor: x2.isInstancedMesh === true && x2.instanceColor !== null, supportsVertexTextures: m2, outputEncoding: L2 !== null ? v2(L2.texture) : t2.outputEncoding, map: !!s3.map, mapEncoding: v2(s3.map), matcap: !!s3.matcap, matcapEncoding: v2(s3.matcap), envMap: !!_2, envMapMode: _2 && _2.mapping, envMapEncoding: v2(_2), envMapCubeUV: !!_2 && (_2.mapping === 306 || _2.mapping === 307), lightMap: !!s3.lightMap, lightMapEncoding: v2(s3.lightMap), aoMap: !!s3.aoMap, emissiveMap: !!s3.emissiveMap, emissiveMapEncoding: v2(s3.emissiveMap), bumpMap: !!s3.bumpMap, normalMap: !!s3.normalMap, objectSpaceNormalMap: s3.normalMapType === 1, tangentSpaceNormalMap: s3.normalMapType === 0, clearcoat: P2, clearcoatMap: P2 && !!s3.clearcoatMap, clearcoatRoughnessMap: P2 && !!s3.clearcoatRoughnessMap, clearcoatNormalMap: P2 && !!s3.clearcoatNormalMap, displacementMap: !!s3.displacementMap, roughnessMap: !!s3.roughnessMap, metalnessMap: !!s3.metalnessMap, specularMap: !!s3.specularMap, specularIntensityMap: !!s3.specularIntensityMap, specularColorMap: !!s3.specularColorMap, specularColorMapEncoding: v2(s3.specularColorMap), alphaMap: !!s3.alphaMap, alphaTest: C2, gradientMap: !!s3.gradientMap, sheen: s3.sheen > 0, sheenColorMap: !!s3.sheenColorMap, sheenColorMapEncoding: v2(s3.sheenColorMap), sheenRoughnessMap: !!s3.sheenRoughnessMap, transmission: s3.transmission > 0, transmissionMap: !!s3.transmissionMap, thicknessMap: !!s3.thicknessMap, combine: s3.combine, vertexTangents: !!s3.normalMap && !!x2.geometry && !!x2.geometry.attributes.tangent, vertexColors: s3.vertexColors, vertexAlphas: s3.vertexColors === true && !!x2.geometry && !!x2.geometry.attributes.color && x2.geometry.attributes.color.itemSize === 4, vertexUvs: !!(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatMap || s3.clearcoatRoughnessMap || s3.clearcoatNormalMap || s3.displacementMap || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularColorMap || s3.sheenColorMap || s3.sheenRoughnessMap), uvsVertexOnly: !(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatNormalMap || s3.transmission > 0 || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularColorMap || s3.sheen > 0 || s3.sheenColorMap || s3.sheenRoughnessMap || !s3.displacementMap), fog: !!b2, useFog: s3.fog, fogExp2: b2 && b2.isFogExp2, flatShading: !!s3.flatShading, sizeAttenuation: s3.sizeAttenuation, logarithmicDepthBuffer: u2, skinning: x2.isSkinnedMesh === true && S2 > 0, maxBones: S2, useVertexTexture: d2, morphTargets: !!x2.geometry && !!x2.geometry.morphAttributes.position, morphNormals: !!x2.geometry && !!x2.geometry.morphAttributes.normal, morphTargetsCount: x2.geometry && x2.geometry.morphAttributes.position ? x2.geometry.morphAttributes.position.length : 0, numDirLights: o3.directional.length, numPointLights: o3.point.length, numSpotLights: o3.spot.length, numRectAreaLights: o3.rectArea.length, numHemiLights: o3.hemi.length, numDirLightShadows: o3.directionalShadowMap.length, numPointLightShadows: o3.pointShadowMap.length, numSpotLightShadows: o3.spotShadowMap.length, numClippingPlanes: a2.numPlanes, numClipIntersection: a2.numIntersection, format: s3.format, dithering: s3.dithering, shadowMapEnabled: t2.shadowMap.enabled && c3.length > 0, shadowMapType: t2.shadowMap.type, toneMapping: s3.toneMapped ? t2.toneMapping : 0, physicallyCorrectLights: t2.physicallyCorrectLights, premultipliedAlpha: s3.premultipliedAlpha, doubleSided: s3.side === 2, flipSided: s3.side === 1, depthPacking: s3.depthPacking !== void 0 && s3.depthPacking, index0AttributeName: s3.index0AttributeName, extensionDerivatives: s3.extensions && s3.extensions.derivatives, extensionFragDepth: s3.extensions && s3.extensions.fragDepth, extensionDrawBuffers: s3.extensions && s3.extensions.drawBuffers, extensionShaderTextureLOD: s3.extensions && s3.extensions.shaderTextureLOD, rendererExtensionFragDepth: h2 || i2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h2 || i2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h2 || i2.has("EXT_shader_texture_lod"), customProgramCacheKey: s3.customProgramCacheKey() };
  }, getProgramCacheKey: function(e3) {
    const n3 = [];
    if (e3.shaderID ? n3.push(e3.shaderID) : (n3.push(e3.customVertexShaderID), n3.push(e3.customFragmentShaderID)), e3.defines !== void 0)
      for (const t3 in e3.defines)
        n3.push(t3), n3.push(e3.defines[t3]);
    return e3.isRawShaderMaterial === false && (!function(t3, e4) {
      t3.push(e4.precision), t3.push(e4.outputEncoding), t3.push(e4.mapEncoding), t3.push(e4.matcapEncoding), t3.push(e4.envMapMode), t3.push(e4.envMapEncoding), t3.push(e4.lightMapEncoding), t3.push(e4.emissiveMapEncoding), t3.push(e4.combine), t3.push(e4.vertexUvs), t3.push(e4.fogExp2), t3.push(e4.sizeAttenuation), t3.push(e4.maxBones), t3.push(e4.morphTargetsCount), t3.push(e4.numDirLights), t3.push(e4.numPointLights), t3.push(e4.numSpotLights), t3.push(e4.numHemiLights), t3.push(e4.numRectAreaLights), t3.push(e4.numDirLightShadows), t3.push(e4.numPointLightShadows), t3.push(e4.numSpotLightShadows), t3.push(e4.shadowMapType), t3.push(e4.toneMapping), t3.push(e4.numClippingPlanes), t3.push(e4.numClipIntersection), t3.push(e4.format), t3.push(e4.specularColorMapEncoding), t3.push(e4.sheenColorMapEncoding);
    }(n3, e3), function(t3, e4) {
      o2.disableAll(), e4.isWebGL2 && o2.enable(0);
      e4.supportsVertexTextures && o2.enable(1);
      e4.instancing && o2.enable(2);
      e4.instancingColor && o2.enable(3);
      e4.map && o2.enable(4);
      e4.matcap && o2.enable(5);
      e4.envMap && o2.enable(6);
      e4.envMapCubeUV && o2.enable(7);
      e4.lightMap && o2.enable(8);
      e4.aoMap && o2.enable(9);
      e4.emissiveMap && o2.enable(10);
      e4.bumpMap && o2.enable(11);
      e4.normalMap && o2.enable(12);
      e4.objectSpaceNormalMap && o2.enable(13);
      e4.tangentSpaceNormalMap && o2.enable(14);
      e4.clearcoat && o2.enable(15);
      e4.clearcoatMap && o2.enable(16);
      e4.clearcoatRoughnessMap && o2.enable(17);
      e4.clearcoatNormalMap && o2.enable(18);
      e4.displacementMap && o2.enable(19);
      e4.specularMap && o2.enable(20);
      e4.roughnessMap && o2.enable(21);
      e4.metalnessMap && o2.enable(22);
      e4.gradientMap && o2.enable(23);
      e4.alphaMap && o2.enable(24);
      e4.alphaTest && o2.enable(25);
      e4.vertexColors && o2.enable(26);
      e4.vertexAlphas && o2.enable(27);
      e4.vertexUvs && o2.enable(28);
      e4.vertexTangents && o2.enable(29);
      e4.uvsVertexOnly && o2.enable(30);
      e4.fog && o2.enable(31);
      t3.push(o2.mask), o2.disableAll(), e4.useFog && o2.enable(0);
      e4.flatShading && o2.enable(1);
      e4.logarithmicDepthBuffer && o2.enable(2);
      e4.skinning && o2.enable(3);
      e4.useVertexTexture && o2.enable(4);
      e4.morphTargets && o2.enable(5);
      e4.morphNormals && o2.enable(6);
      e4.premultipliedAlpha && o2.enable(7);
      e4.shadowMapEnabled && o2.enable(8);
      e4.physicallyCorrectLights && o2.enable(9);
      e4.doubleSided && o2.enable(10);
      e4.flipSided && o2.enable(11);
      e4.depthPacking && o2.enable(12);
      e4.dithering && o2.enable(13);
      e4.specularIntensityMap && o2.enable(14);
      e4.specularColorMap && o2.enable(15);
      e4.transmission && o2.enable(16);
      e4.transmissionMap && o2.enable(17);
      e4.thicknessMap && o2.enable(18);
      e4.sheen && o2.enable(19);
      e4.sheenColorMap && o2.enable(20);
      e4.sheenRoughnessMap && o2.enable(21);
      t3.push(o2.mask);
    }(n3, e3), n3.push(t2.outputEncoding)), n3.push(e3.customProgramCacheKey), n3.join();
  }, getUniforms: function(t3) {
    const e3 = g2[t3.type];
    let n3;
    if (e3) {
      const t4 = Qn[e3];
      n3 = Nn.clone(t4.uniforms);
    } else
      n3 = t3.uniforms;
    return n3;
  }, acquireProgram: function(e3, n3) {
    let i3;
    for (let t3 = 0, e4 = c2.length; t3 < e4; t3++) {
      const e5 = c2[t3];
      if (e5.cacheKey === n3) {
        i3 = e5, ++i3.usedTimes;
        break;
      }
    }
    return i3 === void 0 && (i3 = new hs(t2, n3, e3, s2), c2.push(i3)), i3;
  }, releaseProgram: function(t3) {
    if (--t3.usedTimes == 0) {
      const e3 = c2.indexOf(t3);
      c2[e3] = c2[c2.length - 1], c2.pop(), t3.destroy();
    }
  }, releaseShaderCache: function(t3) {
    l2.remove(t3);
  }, programs: c2, dispose: function() {
    l2.dispose();
  } };
}
function fs() {
  let t2 = /* @__PURE__ */ new WeakMap();
  return { get: function(e2) {
    let n2 = t2.get(e2);
    return n2 === void 0 && (n2 = {}, t2.set(e2, n2)), n2;
  }, remove: function(e2) {
    t2.delete(e2);
  }, update: function(e2, n2, i2) {
    t2.get(e2)[n2] = i2;
  }, dispose: function() {
    t2 = /* @__PURE__ */ new WeakMap();
  } };
}
function gs(t2, e2) {
  return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.material.id !== e2.material.id ? t2.material.id - e2.material.id : t2.z !== e2.z ? t2.z - e2.z : t2.id - e2.id;
}
function vs(t2, e2) {
  return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.z !== e2.z ? e2.z - t2.z : t2.id - e2.id;
}
function ys() {
  const t2 = [];
  let e2 = 0;
  const n2 = [], i2 = [], r2 = [];
  function s2(n3, i3, r3, s3, a2, o2) {
    let l2 = t2[e2];
    return l2 === void 0 ? (l2 = { id: n3.id, object: n3, geometry: i3, material: r3, groupOrder: s3, renderOrder: n3.renderOrder, z: a2, group: o2 }, t2[e2] = l2) : (l2.id = n3.id, l2.object = n3, l2.geometry = i3, l2.material = r3, l2.groupOrder = s3, l2.renderOrder = n3.renderOrder, l2.z = a2, l2.group = o2), e2++, l2;
  }
  return { opaque: n2, transmissive: i2, transparent: r2, init: function() {
    e2 = 0, n2.length = 0, i2.length = 0, r2.length = 0;
  }, push: function(t3, e3, a2, o2, l2, c2) {
    const h2 = s2(t3, e3, a2, o2, l2, c2);
    a2.transmission > 0 ? i2.push(h2) : a2.transparent === true ? r2.push(h2) : n2.push(h2);
  }, unshift: function(t3, e3, a2, o2, l2, c2) {
    const h2 = s2(t3, e3, a2, o2, l2, c2);
    a2.transmission > 0 ? i2.unshift(h2) : a2.transparent === true ? r2.unshift(h2) : n2.unshift(h2);
  }, finish: function() {
    for (let n3 = e2, i3 = t2.length; n3 < i3; n3++) {
      const e3 = t2[n3];
      if (e3.id === null)
        break;
      e3.id = null, e3.object = null, e3.geometry = null, e3.material = null, e3.group = null;
    }
  }, sort: function(t3, e3) {
    n2.length > 1 && n2.sort(t3 || gs), i2.length > 1 && i2.sort(e3 || vs), r2.length > 1 && r2.sort(e3 || vs);
  } };
}
function xs() {
  let t2 = /* @__PURE__ */ new WeakMap();
  return { get: function(e2, n2) {
    let i2;
    return t2.has(e2) === false ? (i2 = new ys(), t2.set(e2, [i2])) : n2 >= t2.get(e2).length ? (i2 = new ys(), t2.get(e2).push(i2)) : i2 = t2.get(e2)[n2], i2;
  }, dispose: function() {
    t2 = /* @__PURE__ */ new WeakMap();
  } };
}
function bs() {
  const t2 = {};
  return { get: function(e2) {
    if (t2[e2.id] !== void 0)
      return t2[e2.id];
    let n2;
    switch (e2.type) {
      case "DirectionalLight":
        n2 = { direction: new At(), color: new Ze() };
        break;
      case "SpotLight":
        n2 = { position: new At(), direction: new At(), color: new Ze(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        n2 = { position: new At(), color: new Ze(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        n2 = { direction: new At(), skyColor: new Ze(), groundColor: new Ze() };
        break;
      case "RectAreaLight":
        n2 = { color: new Ze(), position: new At(), halfWidth: new At(), halfHeight: new At() };
    }
    return t2[e2.id] = n2, n2;
  } };
}
let ws = 0;
function _s(t2, e2) {
  return (e2.castShadow ? 1 : 0) - (t2.castShadow ? 1 : 0);
}
function Ms(t2, e2) {
  const n2 = new bs(), i2 = function() {
    const t3 = {};
    return { get: function(e3) {
      if (t3[e3.id] !== void 0)
        return t3[e3.id];
      let n3;
      switch (e3.type) {
        case "DirectionalLight":
        case "SpotLight":
          n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new mt() };
          break;
        case "PointLight":
          n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new mt(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
      }
      return t3[e3.id] = n3, n3;
    } };
  }(), r2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
  for (let t3 = 0; t3 < 9; t3++)
    r2.probe.push(new At());
  const s2 = new At(), a2 = new re(), o2 = new re();
  return { setup: function(s3, a3) {
    let o3 = 0, l2 = 0, c2 = 0;
    for (let t3 = 0; t3 < 9; t3++)
      r2.probe[t3].set(0, 0, 0);
    let h2 = 0, u2 = 0, d2 = 0, p2 = 0, m2 = 0, f2 = 0, g2 = 0, v2 = 0;
    s3.sort(_s);
    const y2 = a3 !== true ? Math.PI : 1;
    for (let t3 = 0, e3 = s3.length; t3 < e3; t3++) {
      const e4 = s3[t3], a4 = e4.color, x3 = e4.intensity, b2 = e4.distance, w2 = e4.shadow && e4.shadow.map ? e4.shadow.map.texture : null;
      if (e4.isAmbientLight)
        o3 += a4.r * x3 * y2, l2 += a4.g * x3 * y2, c2 += a4.b * x3 * y2;
      else if (e4.isLightProbe)
        for (let t4 = 0; t4 < 9; t4++)
          r2.probe[t4].addScaledVector(e4.sh.coefficients[t4], x3);
      else if (e4.isDirectionalLight) {
        const t4 = n2.get(e4);
        if (t4.color.copy(e4.color).multiplyScalar(e4.intensity * y2), e4.castShadow) {
          const t5 = e4.shadow, n3 = i2.get(e4);
          n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, r2.directionalShadow[h2] = n3, r2.directionalShadowMap[h2] = w2, r2.directionalShadowMatrix[h2] = e4.shadow.matrix, f2++;
        }
        r2.directional[h2] = t4, h2++;
      } else if (e4.isSpotLight) {
        const t4 = n2.get(e4);
        if (t4.position.setFromMatrixPosition(e4.matrixWorld), t4.color.copy(a4).multiplyScalar(x3 * y2), t4.distance = b2, t4.coneCos = Math.cos(e4.angle), t4.penumbraCos = Math.cos(e4.angle * (1 - e4.penumbra)), t4.decay = e4.decay, e4.castShadow) {
          const t5 = e4.shadow, n3 = i2.get(e4);
          n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, r2.spotShadow[d2] = n3, r2.spotShadowMap[d2] = w2, r2.spotShadowMatrix[d2] = e4.shadow.matrix, v2++;
        }
        r2.spot[d2] = t4, d2++;
      } else if (e4.isRectAreaLight) {
        const t4 = n2.get(e4);
        t4.color.copy(a4).multiplyScalar(x3), t4.halfWidth.set(0.5 * e4.width, 0, 0), t4.halfHeight.set(0, 0.5 * e4.height, 0), r2.rectArea[p2] = t4, p2++;
      } else if (e4.isPointLight) {
        const t4 = n2.get(e4);
        if (t4.color.copy(e4.color).multiplyScalar(e4.intensity * y2), t4.distance = e4.distance, t4.decay = e4.decay, e4.castShadow) {
          const t5 = e4.shadow, n3 = i2.get(e4);
          n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, n3.shadowCameraNear = t5.camera.near, n3.shadowCameraFar = t5.camera.far, r2.pointShadow[u2] = n3, r2.pointShadowMap[u2] = w2, r2.pointShadowMatrix[u2] = e4.shadow.matrix, g2++;
        }
        r2.point[u2] = t4, u2++;
      } else if (e4.isHemisphereLight) {
        const t4 = n2.get(e4);
        t4.skyColor.copy(e4.color).multiplyScalar(x3 * y2), t4.groundColor.copy(e4.groundColor).multiplyScalar(x3 * y2), r2.hemi[m2] = t4, m2++;
      }
    }
    p2 > 0 && (e2.isWebGL2 || t2.has("OES_texture_float_linear") === true ? (r2.rectAreaLTC1 = Kn.LTC_FLOAT_1, r2.rectAreaLTC2 = Kn.LTC_FLOAT_2) : t2.has("OES_texture_half_float_linear") === true ? (r2.rectAreaLTC1 = Kn.LTC_HALF_1, r2.rectAreaLTC2 = Kn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r2.ambient[0] = o3, r2.ambient[1] = l2, r2.ambient[2] = c2;
    const x2 = r2.hash;
    x2.directionalLength === h2 && x2.pointLength === u2 && x2.spotLength === d2 && x2.rectAreaLength === p2 && x2.hemiLength === m2 && x2.numDirectionalShadows === f2 && x2.numPointShadows === g2 && x2.numSpotShadows === v2 || (r2.directional.length = h2, r2.spot.length = d2, r2.rectArea.length = p2, r2.point.length = u2, r2.hemi.length = m2, r2.directionalShadow.length = f2, r2.directionalShadowMap.length = f2, r2.pointShadow.length = g2, r2.pointShadowMap.length = g2, r2.spotShadow.length = v2, r2.spotShadowMap.length = v2, r2.directionalShadowMatrix.length = f2, r2.pointShadowMatrix.length = g2, r2.spotShadowMatrix.length = v2, x2.directionalLength = h2, x2.pointLength = u2, x2.spotLength = d2, x2.rectAreaLength = p2, x2.hemiLength = m2, x2.numDirectionalShadows = f2, x2.numPointShadows = g2, x2.numSpotShadows = v2, r2.version = ws++);
  }, setupView: function(t3, e3) {
    let n3 = 0, i3 = 0, l2 = 0, c2 = 0, h2 = 0;
    const u2 = e3.matrixWorldInverse;
    for (let e4 = 0, d2 = t3.length; e4 < d2; e4++) {
      const d3 = t3[e4];
      if (d3.isDirectionalLight) {
        const t4 = r2.directional[n3];
        t4.direction.setFromMatrixPosition(d3.matrixWorld), s2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(s2), t4.direction.transformDirection(u2), n3++;
      } else if (d3.isSpotLight) {
        const t4 = r2.spot[l2];
        t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(u2), t4.direction.setFromMatrixPosition(d3.matrixWorld), s2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(s2), t4.direction.transformDirection(u2), l2++;
      } else if (d3.isRectAreaLight) {
        const t4 = r2.rectArea[c2];
        t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(u2), o2.identity(), a2.copy(d3.matrixWorld), a2.premultiply(u2), o2.extractRotation(a2), t4.halfWidth.set(0.5 * d3.width, 0, 0), t4.halfHeight.set(0, 0.5 * d3.height, 0), t4.halfWidth.applyMatrix4(o2), t4.halfHeight.applyMatrix4(o2), c2++;
      } else if (d3.isPointLight) {
        const t4 = r2.point[i3];
        t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(u2), i3++;
      } else if (d3.isHemisphereLight) {
        const t4 = r2.hemi[h2];
        t4.direction.setFromMatrixPosition(d3.matrixWorld), t4.direction.transformDirection(u2), t4.direction.normalize(), h2++;
      }
    }
  }, state: r2 };
}
function Ss(t2, e2) {
  const n2 = new Ms(t2, e2), i2 = [], r2 = [];
  return { init: function() {
    i2.length = 0, r2.length = 0;
  }, state: { lightsArray: i2, shadowsArray: r2, lights: n2 }, setupLights: function(t3) {
    n2.setup(i2, t3);
  }, setupLightsView: function(t3) {
    n2.setupView(i2, t3);
  }, pushLight: function(t3) {
    i2.push(t3);
  }, pushShadow: function(t3) {
    r2.push(t3);
  } };
}
function Ts(t2, e2) {
  let n2 = /* @__PURE__ */ new WeakMap();
  return { get: function(i2, r2 = 0) {
    let s2;
    return n2.has(i2) === false ? (s2 = new Ss(t2, e2), n2.set(i2, [s2])) : r2 >= n2.get(i2).length ? (s2 = new Ss(t2, e2), n2.get(i2).push(s2)) : s2 = n2.get(i2)[r2], s2;
  }, dispose: function() {
    n2 = /* @__PURE__ */ new WeakMap();
  } };
}
class Es extends Ve {
  constructor(t2) {
    super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.depthPacking = t2.depthPacking, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this;
  }
}
Es.prototype.isMeshDepthMaterial = true;
class As extends Ve {
  constructor(t2) {
    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new At(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.referencePosition.copy(t2.referencePosition), this.nearDistance = t2.nearDistance, this.farDistance = t2.farDistance, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this;
  }
}
As.prototype.isMeshDistanceMaterial = true;
function Rs(t2, e2, n2) {
  let i2 = new Xn();
  const r2 = new mt(), s2 = new mt(), a2 = new Mt(), o2 = new Es({ depthPacking: 3201 }), l2 = new As(), c2 = {}, h2 = n2.maxTextureSize, u2 = { 0: 1, 1: 0, 2: 2 }, d2 = new Fn({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new mt() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p2 = d2.clone();
  p2.defines.HORIZONTAL_PASS = 1;
  const m2 = new un();
  m2.setAttribute("position", new Qe(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const f2 = new Ln(m2, d2), g2 = this;
  function v2(n3, i3) {
    const r3 = e2.update(f2);
    d2.defines.VSM_SAMPLES !== n3.blurSamples && (d2.defines.VSM_SAMPLES = n3.blurSamples, p2.defines.VSM_SAMPLES = n3.blurSamples, d2.needsUpdate = true, p2.needsUpdate = true), d2.uniforms.shadow_pass.value = n3.map.texture, d2.uniforms.resolution.value = n3.mapSize, d2.uniforms.radius.value = n3.radius, t2.setRenderTarget(n3.mapPass), t2.clear(), t2.renderBufferDirect(i3, null, r3, d2, f2, null), p2.uniforms.shadow_pass.value = n3.mapPass.texture, p2.uniforms.resolution.value = n3.mapSize, p2.uniforms.radius.value = n3.radius, t2.setRenderTarget(n3.map), t2.clear(), t2.renderBufferDirect(i3, null, r3, p2, f2, null);
  }
  function y2(e3, n3, i3, r3, s3, a3, h3) {
    let d3 = null;
    const p3 = r3.isPointLight === true ? e3.customDistanceMaterial : e3.customDepthMaterial;
    if (d3 = p3 !== void 0 ? p3 : r3.isPointLight === true ? l2 : o2, t2.localClippingEnabled && i3.clipShadows === true && i3.clippingPlanes.length !== 0 || i3.displacementMap && i3.displacementScale !== 0 || i3.alphaMap && i3.alphaTest > 0) {
      const t3 = d3.uuid, e4 = i3.uuid;
      let n4 = c2[t3];
      n4 === void 0 && (n4 = {}, c2[t3] = n4);
      let r4 = n4[e4];
      r4 === void 0 && (r4 = d3.clone(), n4[e4] = r4), d3 = r4;
    }
    return d3.visible = i3.visible, d3.wireframe = i3.wireframe, d3.side = h3 === 3 ? i3.shadowSide !== null ? i3.shadowSide : i3.side : i3.shadowSide !== null ? i3.shadowSide : u2[i3.side], d3.alphaMap = i3.alphaMap, d3.alphaTest = i3.alphaTest, d3.clipShadows = i3.clipShadows, d3.clippingPlanes = i3.clippingPlanes, d3.clipIntersection = i3.clipIntersection, d3.displacementMap = i3.displacementMap, d3.displacementScale = i3.displacementScale, d3.displacementBias = i3.displacementBias, d3.wireframeLinewidth = i3.wireframeLinewidth, d3.linewidth = i3.linewidth, r3.isPointLight === true && d3.isMeshDistanceMaterial === true && (d3.referencePosition.setFromMatrixPosition(r3.matrixWorld), d3.nearDistance = s3, d3.farDistance = a3), d3;
  }
  function x2(n3, r3, s3, a3, o3) {
    if (n3.visible === false)
      return;
    if (n3.layers.test(r3.layers) && (n3.isMesh || n3.isLine || n3.isPoints) && (n3.castShadow || n3.receiveShadow && o3 === 3) && (!n3.frustumCulled || i2.intersectsObject(n3))) {
      n3.modelViewMatrix.multiplyMatrices(s3.matrixWorldInverse, n3.matrixWorld);
      const i3 = e2.update(n3), r4 = n3.material;
      if (Array.isArray(r4)) {
        const e3 = i3.groups;
        for (let l4 = 0, c3 = e3.length; l4 < c3; l4++) {
          const c4 = e3[l4], h3 = r4[c4.materialIndex];
          if (h3 && h3.visible) {
            const e4 = y2(n3, 0, h3, a3, s3.near, s3.far, o3);
            t2.renderBufferDirect(s3, null, i3, e4, n3, c4);
          }
        }
      } else if (r4.visible) {
        const e3 = y2(n3, 0, r4, a3, s3.near, s3.far, o3);
        t2.renderBufferDirect(s3, null, i3, e3, n3, null);
      }
    }
    const l3 = n3.children;
    for (let t3 = 0, e3 = l3.length; t3 < e3; t3++)
      x2(l3[t3], r3, s3, a3, o3);
  }
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(e3, n3, o3) {
    if (g2.enabled === false)
      return;
    if (g2.autoUpdate === false && g2.needsUpdate === false)
      return;
    if (e3.length === 0)
      return;
    const l3 = t2.getRenderTarget(), c3 = t2.getActiveCubeFace(), u3 = t2.getActiveMipmapLevel(), d3 = t2.state;
    d3.setBlending(0), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
    for (let l4 = 0, c4 = e3.length; l4 < c4; l4++) {
      const c5 = e3[l4], u4 = c5.shadow;
      if (u4 === void 0) {
        console.warn("THREE.WebGLShadowMap:", c5, "has no shadow.");
        continue;
      }
      if (u4.autoUpdate === false && u4.needsUpdate === false)
        continue;
      r2.copy(u4.mapSize);
      const p3 = u4.getFrameExtents();
      if (r2.multiply(p3), s2.copy(u4.mapSize), (r2.x > h2 || r2.y > h2) && (r2.x > h2 && (s2.x = Math.floor(h2 / p3.x), r2.x = s2.x * p3.x, u4.mapSize.x = s2.x), r2.y > h2 && (s2.y = Math.floor(h2 / p3.y), r2.y = s2.y * p3.y, u4.mapSize.y = s2.y)), u4.map === null && !u4.isPointLightShadow && this.type === 3) {
        const t3 = { minFilter: 1006, magFilter: 1006, format: 1023 };
        u4.map = new St(r2.x, r2.y, t3), u4.map.texture.name = c5.name + ".shadowMap", u4.mapPass = new St(r2.x, r2.y, t3), u4.camera.updateProjectionMatrix();
      }
      if (u4.map === null) {
        const t3 = { minFilter: 1003, magFilter: 1003, format: 1023 };
        u4.map = new St(r2.x, r2.y, t3), u4.map.texture.name = c5.name + ".shadowMap", u4.camera.updateProjectionMatrix();
      }
      t2.setRenderTarget(u4.map), t2.clear();
      const m3 = u4.getViewportCount();
      for (let t3 = 0; t3 < m3; t3++) {
        const e4 = u4.getViewport(t3);
        a2.set(s2.x * e4.x, s2.y * e4.y, s2.x * e4.z, s2.y * e4.w), d3.viewport(a2), u4.updateMatrices(c5, t3), i2 = u4.getFrustum(), x2(n3, o3, u4.camera, c5, this.type);
      }
      u4.isPointLightShadow || this.type !== 3 || v2(u4, o3), u4.needsUpdate = false;
    }
    g2.needsUpdate = false, t2.setRenderTarget(l3, c3, u3);
  };
}
function Ls(t2, e2, n2) {
  const i2 = n2.isWebGL2;
  const r2 = new function() {
    let e3 = false;
    const n3 = new Mt();
    let i3 = null;
    const r3 = new Mt(0, 0, 0, 0);
    return { setMask: function(n4) {
      i3 === n4 || e3 || (t2.colorMask(n4, n4, n4, n4), i3 = n4);
    }, setLocked: function(t3) {
      e3 = t3;
    }, setClear: function(e4, i4, s3, a3, o3) {
      o3 === true && (e4 *= a3, i4 *= a3, s3 *= a3), n3.set(e4, i4, s3, a3), r3.equals(n3) === false && (t2.clearColor(e4, i4, s3, a3), r3.copy(n3));
    }, reset: function() {
      e3 = false, i3 = null, r3.set(-1, 0, 0, 0);
    } };
  }(), s2 = new function() {
    let e3 = false, n3 = null, i3 = null, r3 = null;
    return { setTest: function(t3) {
      t3 ? O2(2929) : U2(2929);
    }, setMask: function(i4) {
      n3 === i4 || e3 || (t2.depthMask(i4), n3 = i4);
    }, setFunc: function(e4) {
      if (i3 !== e4) {
        if (e4)
          switch (e4) {
            case 0:
              t2.depthFunc(512);
              break;
            case 1:
              t2.depthFunc(519);
              break;
            case 2:
              t2.depthFunc(513);
              break;
            case 3:
            default:
              t2.depthFunc(515);
              break;
            case 4:
              t2.depthFunc(514);
              break;
            case 5:
              t2.depthFunc(518);
              break;
            case 6:
              t2.depthFunc(516);
              break;
            case 7:
              t2.depthFunc(517);
          }
        else
          t2.depthFunc(515);
        i3 = e4;
      }
    }, setLocked: function(t3) {
      e3 = t3;
    }, setClear: function(e4) {
      r3 !== e4 && (t2.clearDepth(e4), r3 = e4);
    }, reset: function() {
      e3 = false, n3 = null, i3 = null, r3 = null;
    } };
  }(), a2 = new function() {
    let e3 = false, n3 = null, i3 = null, r3 = null, s3 = null, a3 = null, o3 = null, l3 = null, c3 = null;
    return { setTest: function(t3) {
      e3 || (t3 ? O2(2960) : U2(2960));
    }, setMask: function(i4) {
      n3 === i4 || e3 || (t2.stencilMask(i4), n3 = i4);
    }, setFunc: function(e4, n4, a4) {
      i3 === e4 && r3 === n4 && s3 === a4 || (t2.stencilFunc(e4, n4, a4), i3 = e4, r3 = n4, s3 = a4);
    }, setOp: function(e4, n4, i4) {
      a3 === e4 && o3 === n4 && l3 === i4 || (t2.stencilOp(e4, n4, i4), a3 = e4, o3 = n4, l3 = i4);
    }, setLocked: function(t3) {
      e3 = t3;
    }, setClear: function(e4) {
      c3 !== e4 && (t2.clearStencil(e4), c3 = e4);
    }, reset: function() {
      e3 = false, n3 = null, i3 = null, r3 = null, s3 = null, a3 = null, o3 = null, l3 = null, c3 = null;
    } };
  }();
  let o2 = {}, l2 = {}, c2 = null, h2 = false, u2 = null, d2 = null, p2 = null, m2 = null, f2 = null, g2 = null, v2 = null, y2 = false, x2 = null, b2 = null, w2 = null, _2 = null, M2 = null;
  const S2 = t2.getParameter(35661);
  let T2 = false, E2 = 0;
  const A2 = t2.getParameter(7938);
  A2.indexOf("WebGL") !== -1 ? (E2 = parseFloat(/^WebGL (\d)/.exec(A2)[1]), T2 = E2 >= 1) : A2.indexOf("OpenGL ES") !== -1 && (E2 = parseFloat(/^OpenGL ES (\d)/.exec(A2)[1]), T2 = E2 >= 2);
  let R2 = null, L2 = {};
  const C2 = t2.getParameter(3088), P2 = t2.getParameter(2978), I2 = new Mt().fromArray(C2), D2 = new Mt().fromArray(P2);
  function N2(e3, n3, i3) {
    const r3 = new Uint8Array(4), s3 = t2.createTexture();
    t2.bindTexture(e3, s3), t2.texParameteri(e3, 10241, 9728), t2.texParameteri(e3, 10240, 9728);
    for (let e4 = 0; e4 < i3; e4++)
      t2.texImage2D(n3 + e4, 0, 6408, 1, 1, 0, 6408, 5121, r3);
    return s3;
  }
  const F2 = {};
  function O2(e3) {
    o2[e3] !== true && (t2.enable(e3), o2[e3] = true);
  }
  function U2(e3) {
    o2[e3] !== false && (t2.disable(e3), o2[e3] = false);
  }
  F2[3553] = N2(3553, 3553, 1), F2[34067] = N2(34067, 34069, 6), r2.setClear(0, 0, 0, 1), s2.setClear(1), a2.setClear(0), O2(2929), s2.setFunc(3), H2(false), V2(1), O2(2884), B2(0);
  const k2 = { 100: 32774, 101: 32778, 102: 32779 };
  if (i2)
    k2[103] = 32775, k2[104] = 32776;
  else {
    const t3 = e2.get("EXT_blend_minmax");
    t3 !== null && (k2[103] = t3.MIN_EXT, k2[104] = t3.MAX_EXT);
  }
  const z2 = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
  function B2(e3, n3, i3, r3, s3, a3, o3, l3) {
    if (e3 !== 0) {
      if (h2 === false && (O2(3042), h2 = true), e3 === 5)
        s3 = s3 || n3, a3 = a3 || i3, o3 = o3 || r3, n3 === d2 && s3 === f2 || (t2.blendEquationSeparate(k2[n3], k2[s3]), d2 = n3, f2 = s3), i3 === p2 && r3 === m2 && a3 === g2 && o3 === v2 || (t2.blendFuncSeparate(z2[i3], z2[r3], z2[a3], z2[o3]), p2 = i3, m2 = r3, g2 = a3, v2 = o3), u2 = e3, y2 = null;
      else if (e3 !== u2 || l3 !== y2) {
        if (d2 === 100 && f2 === 100 || (t2.blendEquation(32774), d2 = 100, f2 = 100), l3)
          switch (e3) {
            case 1:
              t2.blendFuncSeparate(1, 771, 1, 771);
              break;
            case 2:
              t2.blendFunc(1, 1);
              break;
            case 3:
              t2.blendFuncSeparate(0, 0, 769, 771);
              break;
            case 4:
              t2.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e3);
          }
        else
          switch (e3) {
            case 1:
              t2.blendFuncSeparate(770, 771, 1, 771);
              break;
            case 2:
              t2.blendFunc(770, 1);
              break;
            case 3:
              t2.blendFunc(0, 769);
              break;
            case 4:
              t2.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e3);
          }
        p2 = null, m2 = null, g2 = null, v2 = null, u2 = e3, y2 = l3;
      }
    } else
      h2 === true && (U2(3042), h2 = false);
  }
  function H2(e3) {
    x2 !== e3 && (e3 ? t2.frontFace(2304) : t2.frontFace(2305), x2 = e3);
  }
  function V2(e3) {
    e3 !== 0 ? (O2(2884), e3 !== b2 && (e3 === 1 ? t2.cullFace(1029) : e3 === 2 ? t2.cullFace(1028) : t2.cullFace(1032))) : U2(2884), b2 = e3;
  }
  function G2(e3, n3, i3) {
    e3 ? (O2(32823), _2 === n3 && M2 === i3 || (t2.polygonOffset(n3, i3), _2 = n3, M2 = i3)) : U2(32823);
  }
  function W2(e3) {
    e3 === void 0 && (e3 = 33984 + S2 - 1), R2 !== e3 && (t2.activeTexture(e3), R2 = e3);
  }
  return { buffers: { color: r2, depth: s2, stencil: a2 }, enable: O2, disable: U2, bindFramebuffer: function(e3, n3) {
    return l2[e3] !== n3 && (t2.bindFramebuffer(e3, n3), l2[e3] = n3, i2 && (e3 === 36009 && (l2[36160] = n3), e3 === 36160 && (l2[36009] = n3)), true);
  }, useProgram: function(e3) {
    return c2 !== e3 && (t2.useProgram(e3), c2 = e3, true);
  }, setBlending: B2, setMaterial: function(t3, e3) {
    t3.side === 2 ? U2(2884) : O2(2884);
    let n3 = t3.side === 1;
    e3 && (n3 = !n3), H2(n3), t3.blending === 1 && t3.transparent === false ? B2(0) : B2(t3.blending, t3.blendEquation, t3.blendSrc, t3.blendDst, t3.blendEquationAlpha, t3.blendSrcAlpha, t3.blendDstAlpha, t3.premultipliedAlpha), s2.setFunc(t3.depthFunc), s2.setTest(t3.depthTest), s2.setMask(t3.depthWrite), r2.setMask(t3.colorWrite);
    const i3 = t3.stencilWrite;
    a2.setTest(i3), i3 && (a2.setMask(t3.stencilWriteMask), a2.setFunc(t3.stencilFunc, t3.stencilRef, t3.stencilFuncMask), a2.setOp(t3.stencilFail, t3.stencilZFail, t3.stencilZPass)), G2(t3.polygonOffset, t3.polygonOffsetFactor, t3.polygonOffsetUnits), t3.alphaToCoverage === true ? O2(32926) : U2(32926);
  }, setFlipSided: H2, setCullFace: V2, setLineWidth: function(e3) {
    e3 !== w2 && (T2 && t2.lineWidth(e3), w2 = e3);
  }, setPolygonOffset: G2, setScissorTest: function(t3) {
    t3 ? O2(3089) : U2(3089);
  }, activeTexture: W2, bindTexture: function(e3, n3) {
    R2 === null && W2();
    let i3 = L2[R2];
    i3 === void 0 && (i3 = { type: void 0, texture: void 0 }, L2[R2] = i3), i3.type === e3 && i3.texture === n3 || (t2.bindTexture(e3, n3 || F2[e3]), i3.type = e3, i3.texture = n3);
  }, unbindTexture: function() {
    const e3 = L2[R2];
    e3 !== void 0 && e3.type !== void 0 && (t2.bindTexture(e3.type, null), e3.type = void 0, e3.texture = void 0);
  }, compressedTexImage2D: function() {
    try {
      t2.compressedTexImage2D.apply(t2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, texImage2D: function() {
    try {
      t2.texImage2D.apply(t2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, texImage3D: function() {
    try {
      t2.texImage3D.apply(t2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, texStorage2D: function() {
    try {
      t2.texStorage2D.apply(t2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, texStorage3D: function() {
    try {
      t2.texStorage3D.apply(t2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, texSubImage2D: function() {
    try {
      t2.texSubImage2D.apply(t2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, texSubImage3D: function() {
    try {
      t2.texSubImage3D.apply(t2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, compressedTexSubImage2D: function() {
    try {
      t2.compressedTexSubImage2D.apply(t2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, scissor: function(e3) {
    I2.equals(e3) === false && (t2.scissor(e3.x, e3.y, e3.z, e3.w), I2.copy(e3));
  }, viewport: function(e3) {
    D2.equals(e3) === false && (t2.viewport(e3.x, e3.y, e3.z, e3.w), D2.copy(e3));
  }, reset: function() {
    t2.disable(3042), t2.disable(2884), t2.disable(2929), t2.disable(32823), t2.disable(3089), t2.disable(2960), t2.disable(32926), t2.blendEquation(32774), t2.blendFunc(1, 0), t2.blendFuncSeparate(1, 0, 1, 0), t2.colorMask(true, true, true, true), t2.clearColor(0, 0, 0, 0), t2.depthMask(true), t2.depthFunc(513), t2.clearDepth(1), t2.stencilMask(4294967295), t2.stencilFunc(519, 0, 4294967295), t2.stencilOp(7680, 7680, 7680), t2.clearStencil(0), t2.cullFace(1029), t2.frontFace(2305), t2.polygonOffset(0, 0), t2.activeTexture(33984), t2.bindFramebuffer(36160, null), i2 === true && (t2.bindFramebuffer(36009, null), t2.bindFramebuffer(36008, null)), t2.useProgram(null), t2.lineWidth(1), t2.scissor(0, 0, t2.canvas.width, t2.canvas.height), t2.viewport(0, 0, t2.canvas.width, t2.canvas.height), o2 = {}, R2 = null, L2 = {}, l2 = {}, c2 = null, h2 = false, u2 = null, d2 = null, p2 = null, m2 = null, f2 = null, g2 = null, v2 = null, y2 = false, x2 = null, b2 = null, w2 = null, _2 = null, M2 = null, I2.set(0, 0, t2.canvas.width, t2.canvas.height), D2.set(0, 0, t2.canvas.width, t2.canvas.height), r2.reset(), s2.reset(), a2.reset();
  } };
}
function Cs(t2, e2, n2, i2, r2, s2, a2) {
  const o2 = r2.isWebGL2, l2 = r2.maxTextures, c2 = r2.maxCubemapSize, h2 = r2.maxTextureSize, u2 = r2.maxSamples, d2 = e2.has("WEBGL_multisampled_render_to_texture") ? e2.get("WEBGL_multisampled_render_to_texture") : void 0, p2 = /* @__PURE__ */ new WeakMap();
  let m2, f2 = false;
  try {
    f2 = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (t3) {
  }
  function g2(t3, e3) {
    return f2 ? new OffscreenCanvas(t3, e3) : vt("canvas");
  }
  function v2(t3, e3, n3, i3) {
    let r3 = 1;
    if ((t3.width > i3 || t3.height > i3) && (r3 = i3 / Math.max(t3.width, t3.height)), r3 < 1 || e3 === true) {
      if (typeof HTMLImageElement != "undefined" && t3 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t3 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t3 instanceof ImageBitmap) {
        const i4 = e3 ? dt : Math.floor, s3 = i4(r3 * t3.width), a3 = i4(r3 * t3.height);
        m2 === void 0 && (m2 = g2(s3, a3));
        const o3 = n3 ? g2(s3, a3) : m2;
        o3.width = s3, o3.height = a3;
        return o3.getContext("2d").drawImage(t3, 0, 0, s3, a3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t3.width + "x" + t3.height + ") to (" + s3 + "x" + a3 + ")."), o3;
      }
      return "data" in t3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t3.width + "x" + t3.height + ")."), t3;
    }
    return t3;
  }
  function y2(t3) {
    return ht(t3.width) && ht(t3.height);
  }
  function x2(t3, e3) {
    return t3.generateMipmaps && e3 && t3.minFilter !== 1003 && t3.minFilter !== 1006;
  }
  function b2(e3) {
    t2.generateMipmap(e3);
  }
  function w2(n3, i3, r3, s3) {
    if (o2 === false)
      return i3;
    if (n3 !== null) {
      if (t2[n3] !== void 0)
        return t2[n3];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n3 + "'");
    }
    let a3 = i3;
    return i3 === 6403 && (r3 === 5126 && (a3 = 33326), r3 === 5131 && (a3 = 33325), r3 === 5121 && (a3 = 33321)), i3 === 6407 && (r3 === 5126 && (a3 = 34837), r3 === 5131 && (a3 = 34843), r3 === 5121 && (a3 = 32849)), i3 === 6408 && (r3 === 5126 && (a3 = 34836), r3 === 5131 && (a3 = 34842), r3 === 5121 && (a3 = s3 === 3001 ? 35907 : 32856)), a3 !== 33325 && a3 !== 33326 && a3 !== 34842 && a3 !== 34836 || e2.get("EXT_color_buffer_float"), a3;
  }
  function _2(t3, e3, n3) {
    return x2(t3, n3) === true || t3.isFramebufferTexture && t3.minFilter !== 1003 && t3.minFilter !== 1006 ? Math.log2(Math.max(e3.width, e3.height)) + 1 : t3.mipmaps !== void 0 && t3.mipmaps.length > 0 ? t3.mipmaps.length : t3.isCompressedTexture && Array.isArray(t3.image) ? e3.mipmaps.length : 1;
  }
  function M2(t3) {
    return t3 === 1003 || t3 === 1004 || t3 === 1005 ? 9728 : 9729;
  }
  function S2(e3) {
    const n3 = e3.target;
    n3.removeEventListener("dispose", S2), function(e4) {
      const n4 = i2.get(e4);
      if (n4.__webglInit === void 0)
        return;
      t2.deleteTexture(n4.__webglTexture), i2.remove(e4);
    }(n3), n3.isVideoTexture && p2.delete(n3), a2.memory.textures--;
  }
  function T2(e3) {
    const n3 = e3.target;
    n3.removeEventListener("dispose", T2), function(e4) {
      const n4 = e4.texture, r3 = i2.get(e4), s3 = i2.get(n4);
      if (!e4)
        return;
      s3.__webglTexture !== void 0 && (t2.deleteTexture(s3.__webglTexture), a2.memory.textures--);
      e4.depthTexture && e4.depthTexture.dispose();
      if (e4.isWebGLCubeRenderTarget)
        for (let e5 = 0; e5 < 6; e5++)
          t2.deleteFramebuffer(r3.__webglFramebuffer[e5]), r3.__webglDepthbuffer && t2.deleteRenderbuffer(r3.__webglDepthbuffer[e5]);
      else
        t2.deleteFramebuffer(r3.__webglFramebuffer), r3.__webglDepthbuffer && t2.deleteRenderbuffer(r3.__webglDepthbuffer), r3.__webglMultisampledFramebuffer && t2.deleteFramebuffer(r3.__webglMultisampledFramebuffer), r3.__webglColorRenderbuffer && t2.deleteRenderbuffer(r3.__webglColorRenderbuffer), r3.__webglDepthRenderbuffer && t2.deleteRenderbuffer(r3.__webglDepthRenderbuffer);
      if (e4.isWebGLMultipleRenderTargets)
        for (let e5 = 0, r4 = n4.length; e5 < r4; e5++) {
          const r5 = i2.get(n4[e5]);
          r5.__webglTexture && (t2.deleteTexture(r5.__webglTexture), a2.memory.textures--), i2.remove(n4[e5]);
        }
      i2.remove(n4), i2.remove(e4);
    }(n3);
  }
  let E2 = 0;
  function A2(t3, e3) {
    const r3 = i2.get(t3);
    if (t3.isVideoTexture && function(t4) {
      const e4 = a2.render.frame;
      p2.get(t4) !== e4 && (p2.set(t4, e4), t4.update());
    }(t3), t3.version > 0 && r3.__version !== t3.version) {
      const n3 = t3.image;
      if (n3 === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else {
        if (n3.complete !== false)
          return void D2(r3, t3, e3);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }
    n2.activeTexture(33984 + e3), n2.bindTexture(3553, r3.__webglTexture);
  }
  function R2(e3, r3) {
    const a3 = i2.get(e3);
    e3.version > 0 && a3.__version !== e3.version ? function(e4, i3, r4) {
      if (i3.image.length !== 6)
        return;
      I2(e4, i3), n2.activeTexture(33984 + r4), n2.bindTexture(34067, e4.__webglTexture), t2.pixelStorei(37440, i3.flipY), t2.pixelStorei(37441, i3.premultiplyAlpha), t2.pixelStorei(3317, i3.unpackAlignment), t2.pixelStorei(37443, 0);
      const a4 = i3 && (i3.isCompressedTexture || i3.image[0].isCompressedTexture), l3 = i3.image[0] && i3.image[0].isDataTexture, h3 = [];
      for (let t3 = 0; t3 < 6; t3++)
        h3[t3] = a4 || l3 ? l3 ? i3.image[t3].image : i3.image[t3] : v2(i3.image[t3], false, true, c2);
      const u3 = h3[0], d3 = y2(u3) || o2, p3 = s2.convert(i3.format), m3 = s2.convert(i3.type), f3 = w2(i3.internalFormat, p3, m3, i3.encoding), g3 = o2 && i3.isVideoTexture !== true, M3 = e4.__version === void 0;
      let S3, T3 = _2(i3, u3, d3);
      if (P2(34067, i3, d3), a4) {
        g3 && M3 && n2.texStorage2D(34067, T3, f3, u3.width, u3.height);
        for (let t3 = 0; t3 < 6; t3++) {
          S3 = h3[t3].mipmaps;
          for (let e5 = 0; e5 < S3.length; e5++) {
            const r5 = S3[e5];
            i3.format !== 1023 && i3.format !== 1022 ? p3 !== null ? g3 ? n2.compressedTexSubImage2D(34069 + t3, e5, 0, 0, r5.width, r5.height, p3, r5.data) : n2.compressedTexImage2D(34069 + t3, e5, f3, r5.width, r5.height, 0, r5.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g3 ? n2.texSubImage2D(34069 + t3, e5, 0, 0, r5.width, r5.height, p3, m3, r5.data) : n2.texImage2D(34069 + t3, e5, f3, r5.width, r5.height, 0, p3, m3, r5.data);
          }
        }
      } else {
        S3 = i3.mipmaps, g3 && M3 && (S3.length > 0 && T3++, n2.texStorage2D(34067, T3, f3, h3[0].width, h3[0].height));
        for (let t3 = 0; t3 < 6; t3++)
          if (l3) {
            g3 ? n2.texSubImage2D(34069 + t3, 0, 0, 0, h3[t3].width, h3[t3].height, p3, m3, h3[t3].data) : n2.texImage2D(34069 + t3, 0, f3, h3[t3].width, h3[t3].height, 0, p3, m3, h3[t3].data);
            for (let e5 = 0; e5 < S3.length; e5++) {
              const i4 = S3[e5].image[t3].image;
              g3 ? n2.texSubImage2D(34069 + t3, e5 + 1, 0, 0, i4.width, i4.height, p3, m3, i4.data) : n2.texImage2D(34069 + t3, e5 + 1, f3, i4.width, i4.height, 0, p3, m3, i4.data);
            }
          } else {
            g3 ? n2.texSubImage2D(34069 + t3, 0, 0, 0, p3, m3, h3[t3]) : n2.texImage2D(34069 + t3, 0, f3, p3, m3, h3[t3]);
            for (let e5 = 0; e5 < S3.length; e5++) {
              const i4 = S3[e5];
              g3 ? n2.texSubImage2D(34069 + t3, e5 + 1, 0, 0, p3, m3, i4.image[t3]) : n2.texImage2D(34069 + t3, e5 + 1, f3, p3, m3, i4.image[t3]);
            }
          }
      }
      x2(i3, d3) && b2(34067);
      e4.__version = i3.version, i3.onUpdate && i3.onUpdate(i3);
    }(a3, e3, r3) : (n2.activeTexture(33984 + r3), n2.bindTexture(34067, a3.__webglTexture));
  }
  const L2 = { 1e3: 10497, 1001: 33071, 1002: 33648 }, C2 = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
  function P2(n3, s3, a3) {
    if (a3 ? (t2.texParameteri(n3, 10242, L2[s3.wrapS]), t2.texParameteri(n3, 10243, L2[s3.wrapT]), n3 !== 32879 && n3 !== 35866 || t2.texParameteri(n3, 32882, L2[s3.wrapR]), t2.texParameteri(n3, 10240, C2[s3.magFilter]), t2.texParameteri(n3, 10241, C2[s3.minFilter])) : (t2.texParameteri(n3, 10242, 33071), t2.texParameteri(n3, 10243, 33071), n3 !== 32879 && n3 !== 35866 || t2.texParameteri(n3, 32882, 33071), s3.wrapS === 1001 && s3.wrapT === 1001 || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t2.texParameteri(n3, 10240, M2(s3.magFilter)), t2.texParameteri(n3, 10241, M2(s3.minFilter)), s3.minFilter !== 1003 && s3.minFilter !== 1006 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e2.has("EXT_texture_filter_anisotropic") === true) {
      const a4 = e2.get("EXT_texture_filter_anisotropic");
      if (s3.type === 1015 && e2.has("OES_texture_float_linear") === false)
        return;
      if (o2 === false && s3.type === 1016 && e2.has("OES_texture_half_float_linear") === false)
        return;
      (s3.anisotropy > 1 || i2.get(s3).__currentAnisotropy) && (t2.texParameterf(n3, a4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s3.anisotropy, r2.getMaxAnisotropy())), i2.get(s3).__currentAnisotropy = s3.anisotropy);
    }
  }
  function I2(e3, n3) {
    e3.__webglInit === void 0 && (e3.__webglInit = true, n3.addEventListener("dispose", S2), e3.__webglTexture = t2.createTexture(), a2.memory.textures++);
  }
  function D2(e3, i3, r3) {
    let a3 = 3553;
    i3.isDataTexture2DArray && (a3 = 35866), i3.isDataTexture3D && (a3 = 32879), I2(e3, i3), n2.activeTexture(33984 + r3), n2.bindTexture(a3, e3.__webglTexture), t2.pixelStorei(37440, i3.flipY), t2.pixelStorei(37441, i3.premultiplyAlpha), t2.pixelStorei(3317, i3.unpackAlignment), t2.pixelStorei(37443, 0);
    const l3 = function(t3) {
      return !o2 && (t3.wrapS !== 1001 || t3.wrapT !== 1001 || t3.minFilter !== 1003 && t3.minFilter !== 1006);
    }(i3) && y2(i3.image) === false, c3 = v2(i3.image, l3, false, h2), u3 = y2(c3) || o2, d3 = s2.convert(i3.format);
    let p3, m3 = s2.convert(i3.type), f3 = w2(i3.internalFormat, d3, m3, i3.encoding);
    P2(a3, i3, u3);
    const g3 = i3.mipmaps, M3 = o2 && i3.isVideoTexture !== true, S3 = e3.__version === void 0, T3 = _2(i3, c3, u3);
    if (i3.isDepthTexture)
      f3 = 6402, o2 ? f3 = i3.type === 1015 ? 36012 : i3.type === 1014 ? 33190 : i3.type === 1020 ? 35056 : 33189 : i3.type === 1015 && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i3.format === 1026 && f3 === 6402 && i3.type !== 1012 && i3.type !== 1014 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i3.type = 1012, m3 = s2.convert(i3.type)), i3.format === 1027 && f3 === 6402 && (f3 = 34041, i3.type !== 1020 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i3.type = 1020, m3 = s2.convert(i3.type))), M3 && S3 ? n2.texStorage2D(3553, 1, f3, c3.width, c3.height) : n2.texImage2D(3553, 0, f3, c3.width, c3.height, 0, d3, m3, null);
    else if (i3.isDataTexture)
      if (g3.length > 0 && u3) {
        M3 && S3 && n2.texStorage2D(3553, T3, f3, g3[0].width, g3[0].height);
        for (let t3 = 0, e4 = g3.length; t3 < e4; t3++)
          p3 = g3[t3], M3 ? n2.texSubImage2D(3553, 0, 0, 0, p3.width, p3.height, d3, m3, p3.data) : n2.texImage2D(3553, t3, f3, p3.width, p3.height, 0, d3, m3, p3.data);
        i3.generateMipmaps = false;
      } else
        M3 ? (S3 && n2.texStorage2D(3553, T3, f3, c3.width, c3.height), n2.texSubImage2D(3553, 0, 0, 0, c3.width, c3.height, d3, m3, c3.data)) : n2.texImage2D(3553, 0, f3, c3.width, c3.height, 0, d3, m3, c3.data);
    else if (i3.isCompressedTexture) {
      M3 && S3 && n2.texStorage2D(3553, T3, f3, g3[0].width, g3[0].height);
      for (let t3 = 0, e4 = g3.length; t3 < e4; t3++)
        p3 = g3[t3], i3.format !== 1023 && i3.format !== 1022 ? d3 !== null ? M3 ? n2.compressedTexSubImage2D(3553, t3, 0, 0, p3.width, p3.height, d3, p3.data) : n2.compressedTexImage2D(3553, t3, f3, p3.width, p3.height, 0, p3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M3 ? n2.texSubImage2D(3553, t3, 0, 0, p3.width, p3.height, d3, m3, p3.data) : n2.texImage2D(3553, t3, f3, p3.width, p3.height, 0, d3, m3, p3.data);
    } else if (i3.isDataTexture2DArray)
      M3 ? (S3 && n2.texStorage3D(35866, T3, f3, c3.width, c3.height, c3.depth), n2.texSubImage3D(35866, 0, 0, 0, 0, c3.width, c3.height, c3.depth, d3, m3, c3.data)) : n2.texImage3D(35866, 0, f3, c3.width, c3.height, c3.depth, 0, d3, m3, c3.data);
    else if (i3.isDataTexture3D)
      M3 ? (S3 && n2.texStorage3D(32879, T3, f3, c3.width, c3.height, c3.depth), n2.texSubImage3D(32879, 0, 0, 0, 0, c3.width, c3.height, c3.depth, d3, m3, c3.data)) : n2.texImage3D(32879, 0, f3, c3.width, c3.height, c3.depth, 0, d3, m3, c3.data);
    else if (i3.isFramebufferTexture)
      M3 && S3 ? n2.texStorage2D(3553, T3, f3, c3.width, c3.height) : n2.texImage2D(3553, 0, f3, c3.width, c3.height, 0, d3, m3, null);
    else if (g3.length > 0 && u3) {
      M3 && S3 && n2.texStorage2D(3553, T3, f3, g3[0].width, g3[0].height);
      for (let t3 = 0, e4 = g3.length; t3 < e4; t3++)
        p3 = g3[t3], M3 ? n2.texSubImage2D(3553, t3, 0, 0, d3, m3, p3) : n2.texImage2D(3553, t3, f3, d3, m3, p3);
      i3.generateMipmaps = false;
    } else
      M3 ? (S3 && n2.texStorage2D(3553, T3, f3, c3.width, c3.height), n2.texSubImage2D(3553, 0, 0, 0, d3, m3, c3)) : n2.texImage2D(3553, 0, f3, d3, m3, c3);
    x2(i3, u3) && b2(a3), e3.__version = i3.version, i3.onUpdate && i3.onUpdate(i3);
  }
  function N2(e3, r3, a3, o3, l3) {
    const c3 = s2.convert(a3.format), h3 = s2.convert(a3.type), u3 = w2(a3.internalFormat, c3, h3, a3.encoding);
    i2.get(r3).__hasExternalTextures || (l3 === 32879 || l3 === 35866 ? n2.texImage3D(l3, 0, u3, r3.width, r3.height, r3.depth, 0, c3, h3, null) : n2.texImage2D(l3, 0, u3, r3.width, r3.height, 0, c3, h3, null)), n2.bindFramebuffer(36160, e3), r3.useRenderToTexture ? d2.framebufferTexture2DMultisampleEXT(36160, o3, l3, i2.get(a3).__webglTexture, 0, U2(r3)) : t2.framebufferTexture2D(36160, o3, l3, i2.get(a3).__webglTexture, 0), n2.bindFramebuffer(36160, null);
  }
  function F2(e3, n3, i3) {
    if (t2.bindRenderbuffer(36161, e3), n3.depthBuffer && !n3.stencilBuffer) {
      let r3 = 33189;
      if (i3 || n3.useRenderToTexture) {
        const e4 = n3.depthTexture;
        e4 && e4.isDepthTexture && (e4.type === 1015 ? r3 = 36012 : e4.type === 1014 && (r3 = 33190));
        const i4 = U2(n3);
        n3.useRenderToTexture ? d2.renderbufferStorageMultisampleEXT(36161, i4, r3, n3.width, n3.height) : t2.renderbufferStorageMultisample(36161, i4, r3, n3.width, n3.height);
      } else
        t2.renderbufferStorage(36161, r3, n3.width, n3.height);
      t2.framebufferRenderbuffer(36160, 36096, 36161, e3);
    } else if (n3.depthBuffer && n3.stencilBuffer) {
      const r3 = U2(n3);
      i3 && n3.useRenderbuffer ? t2.renderbufferStorageMultisample(36161, r3, 35056, n3.width, n3.height) : n3.useRenderToTexture ? d2.renderbufferStorageMultisampleEXT(36161, r3, 35056, n3.width, n3.height) : t2.renderbufferStorage(36161, 34041, n3.width, n3.height), t2.framebufferRenderbuffer(36160, 33306, 36161, e3);
    } else {
      const e4 = n3.isWebGLMultipleRenderTargets === true ? n3.texture[0] : n3.texture, r3 = s2.convert(e4.format), a3 = s2.convert(e4.type), o3 = w2(e4.internalFormat, r3, a3, e4.encoding), l3 = U2(n3);
      i3 && n3.useRenderbuffer ? t2.renderbufferStorageMultisample(36161, l3, o3, n3.width, n3.height) : n3.useRenderToTexture ? d2.renderbufferStorageMultisampleEXT(36161, l3, o3, n3.width, n3.height) : t2.renderbufferStorage(36161, o3, n3.width, n3.height);
    }
    t2.bindRenderbuffer(36161, null);
  }
  function O2(e3) {
    const r3 = i2.get(e3), s3 = e3.isWebGLCubeRenderTarget === true;
    if (e3.depthTexture && !r3.__autoAllocateDepthBuffer) {
      if (s3)
        throw new Error("target.depthTexture not supported in Cube render targets");
      !function(e4, r4) {
        if (r4 && r4.isWebGLCubeRenderTarget)
          throw new Error("Depth Texture with cube render targets is not supported");
        if (n2.bindFramebuffer(36160, e4), !r4.depthTexture || !r4.depthTexture.isDepthTexture)
          throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        i2.get(r4.depthTexture).__webglTexture && r4.depthTexture.image.width === r4.width && r4.depthTexture.image.height === r4.height || (r4.depthTexture.image.width = r4.width, r4.depthTexture.image.height = r4.height, r4.depthTexture.needsUpdate = true), A2(r4.depthTexture, 0);
        const s4 = i2.get(r4.depthTexture).__webglTexture, a3 = U2(r4);
        if (r4.depthTexture.format === 1026)
          r4.useRenderToTexture ? d2.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s4, 0, a3) : t2.framebufferTexture2D(36160, 36096, 3553, s4, 0);
        else {
          if (r4.depthTexture.format !== 1027)
            throw new Error("Unknown depthTexture format");
          r4.useRenderToTexture ? d2.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s4, 0, a3) : t2.framebufferTexture2D(36160, 33306, 3553, s4, 0);
        }
      }(r3.__webglFramebuffer, e3);
    } else if (s3) {
      r3.__webglDepthbuffer = [];
      for (let i3 = 0; i3 < 6; i3++)
        n2.bindFramebuffer(36160, r3.__webglFramebuffer[i3]), r3.__webglDepthbuffer[i3] = t2.createRenderbuffer(), F2(r3.__webglDepthbuffer[i3], e3, false);
    } else
      n2.bindFramebuffer(36160, r3.__webglFramebuffer), r3.__webglDepthbuffer = t2.createRenderbuffer(), F2(r3.__webglDepthbuffer, e3, false);
    n2.bindFramebuffer(36160, null);
  }
  function U2(t3) {
    return o2 && (t3.useRenderbuffer || t3.useRenderToTexture) ? Math.min(u2, t3.samples) : 0;
  }
  let k2 = false, z2 = false;
  this.allocateTextureUnit = function() {
    const t3 = E2;
    return t3 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + t3 + " texture units while this GPU supports only " + l2), E2 += 1, t3;
  }, this.resetTextureUnits = function() {
    E2 = 0;
  }, this.setTexture2D = A2, this.setTexture2DArray = function(t3, e3) {
    const r3 = i2.get(t3);
    t3.version > 0 && r3.__version !== t3.version ? D2(r3, t3, e3) : (n2.activeTexture(33984 + e3), n2.bindTexture(35866, r3.__webglTexture));
  }, this.setTexture3D = function(t3, e3) {
    const r3 = i2.get(t3);
    t3.version > 0 && r3.__version !== t3.version ? D2(r3, t3, e3) : (n2.activeTexture(33984 + e3), n2.bindTexture(32879, r3.__webglTexture));
  }, this.setTextureCube = R2, this.rebindTextures = function(t3, e3, n3) {
    const r3 = i2.get(t3);
    e3 !== void 0 && N2(r3.__webglFramebuffer, t3, t3.texture, 36064, 3553), n3 !== void 0 && O2(t3);
  }, this.setupRenderTarget = function(e3) {
    const l3 = e3.texture, c3 = i2.get(e3), h3 = i2.get(l3);
    e3.addEventListener("dispose", T2), e3.isWebGLMultipleRenderTargets !== true && (h3.__webglTexture === void 0 && (h3.__webglTexture = t2.createTexture()), h3.__version = l3.version, a2.memory.textures++);
    const u3 = e3.isWebGLCubeRenderTarget === true, d3 = e3.isWebGLMultipleRenderTargets === true, p3 = l3.isDataTexture3D || l3.isDataTexture2DArray, m3 = y2(e3) || o2;
    if (!o2 || l3.format !== 1022 || l3.type !== 1015 && l3.type !== 1016 || (l3.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u3) {
      c3.__webglFramebuffer = [];
      for (let e4 = 0; e4 < 6; e4++)
        c3.__webglFramebuffer[e4] = t2.createFramebuffer();
    } else if (c3.__webglFramebuffer = t2.createFramebuffer(), d3)
      if (r2.drawBuffers) {
        const n3 = e3.texture;
        for (let e4 = 0, r3 = n3.length; e4 < r3; e4++) {
          const r4 = i2.get(n3[e4]);
          r4.__webglTexture === void 0 && (r4.__webglTexture = t2.createTexture(), a2.memory.textures++);
        }
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
    else if (e3.useRenderbuffer)
      if (o2) {
        c3.__webglMultisampledFramebuffer = t2.createFramebuffer(), c3.__webglColorRenderbuffer = t2.createRenderbuffer(), t2.bindRenderbuffer(36161, c3.__webglColorRenderbuffer);
        const i3 = s2.convert(l3.format), r3 = s2.convert(l3.type), a3 = w2(l3.internalFormat, i3, r3, l3.encoding), o3 = U2(e3);
        t2.renderbufferStorageMultisample(36161, o3, a3, e3.width, e3.height), n2.bindFramebuffer(36160, c3.__webglMultisampledFramebuffer), t2.framebufferRenderbuffer(36160, 36064, 36161, c3.__webglColorRenderbuffer), t2.bindRenderbuffer(36161, null), e3.depthBuffer && (c3.__webglDepthRenderbuffer = t2.createRenderbuffer(), F2(c3.__webglDepthRenderbuffer, e3, true)), n2.bindFramebuffer(36160, null);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    if (u3) {
      n2.bindTexture(34067, h3.__webglTexture), P2(34067, l3, m3);
      for (let t3 = 0; t3 < 6; t3++)
        N2(c3.__webglFramebuffer[t3], e3, l3, 36064, 34069 + t3);
      x2(l3, m3) && b2(34067), n2.unbindTexture();
    } else if (d3) {
      const t3 = e3.texture;
      for (let r3 = 0, s3 = t3.length; r3 < s3; r3++) {
        const s4 = t3[r3], a3 = i2.get(s4);
        n2.bindTexture(3553, a3.__webglTexture), P2(3553, s4, m3), N2(c3.__webglFramebuffer, e3, s4, 36064 + r3, 3553), x2(s4, m3) && b2(3553);
      }
      n2.unbindTexture();
    } else {
      let t3 = 3553;
      if (p3)
        if (o2) {
          t3 = l3.isDataTexture3D ? 32879 : 35866;
        } else
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
      n2.bindTexture(t3, h3.__webglTexture), P2(t3, l3, m3), N2(c3.__webglFramebuffer, e3, l3, 36064, t3), x2(l3, m3) && b2(t3), n2.unbindTexture();
    }
    e3.depthBuffer && O2(e3);
  }, this.updateRenderTargetMipmap = function(t3) {
    const e3 = y2(t3) || o2, r3 = t3.isWebGLMultipleRenderTargets === true ? t3.texture : [t3.texture];
    for (let s3 = 0, a3 = r3.length; s3 < a3; s3++) {
      const a4 = r3[s3];
      if (x2(a4, e3)) {
        const e4 = t3.isWebGLCubeRenderTarget ? 34067 : 3553, r4 = i2.get(a4).__webglTexture;
        n2.bindTexture(e4, r4), b2(e4), n2.unbindTexture();
      }
    }
  }, this.updateMultisampleRenderTarget = function(e3) {
    if (e3.useRenderbuffer)
      if (o2) {
        const r3 = e3.width, s3 = e3.height;
        let a3 = 16384;
        const o3 = [36064], l3 = e3.stencilBuffer ? 33306 : 36096;
        e3.depthBuffer && o3.push(l3), e3.ignoreDepthForMultisampleCopy || (e3.depthBuffer && (a3 |= 256), e3.stencilBuffer && (a3 |= 1024));
        const c3 = i2.get(e3);
        n2.bindFramebuffer(36008, c3.__webglMultisampledFramebuffer), n2.bindFramebuffer(36009, c3.__webglFramebuffer), e3.ignoreDepthForMultisampleCopy && (t2.invalidateFramebuffer(36008, [l3]), t2.invalidateFramebuffer(36009, [l3])), t2.blitFramebuffer(0, 0, r3, s3, 0, 0, r3, s3, a3, 9728), t2.invalidateFramebuffer(36008, o3), n2.bindFramebuffer(36008, null), n2.bindFramebuffer(36009, c3.__webglMultisampledFramebuffer);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }, this.setupDepthRenderbuffer = O2, this.setupFrameBufferTexture = N2, this.safeSetTexture2D = function(t3, e3) {
    t3 && t3.isWebGLRenderTarget && (k2 === false && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), k2 = true), t3 = t3.texture), A2(t3, e3);
  }, this.safeSetTextureCube = function(t3, e3) {
    t3 && t3.isWebGLCubeRenderTarget && (z2 === false && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), z2 = true), t3 = t3.texture), R2(t3, e3);
  };
}
function Ps(t2, e2, n2) {
  const i2 = n2.isWebGL2;
  return { convert: function(t3) {
    let n3;
    if (t3 === 1009)
      return 5121;
    if (t3 === 1017)
      return 32819;
    if (t3 === 1018)
      return 32820;
    if (t3 === 1019)
      return 33635;
    if (t3 === 1010)
      return 5120;
    if (t3 === 1011)
      return 5122;
    if (t3 === 1012)
      return 5123;
    if (t3 === 1013)
      return 5124;
    if (t3 === 1014)
      return 5125;
    if (t3 === 1015)
      return 5126;
    if (t3 === 1016)
      return i2 ? 5131 : (n3 = e2.get("OES_texture_half_float"), n3 !== null ? n3.HALF_FLOAT_OES : null);
    if (t3 === 1021)
      return 6406;
    if (t3 === 1022)
      return 6407;
    if (t3 === 1023)
      return 6408;
    if (t3 === 1024)
      return 6409;
    if (t3 === 1025)
      return 6410;
    if (t3 === 1026)
      return 6402;
    if (t3 === 1027)
      return 34041;
    if (t3 === 1028)
      return 6403;
    if (t3 === 1029)
      return 36244;
    if (t3 === 1030)
      return 33319;
    if (t3 === 1031)
      return 33320;
    if (t3 === 1032)
      return 36248;
    if (t3 === 1033)
      return 36249;
    if (t3 === 33776 || t3 === 33777 || t3 === 33778 || t3 === 33779) {
      if (n3 = e2.get("WEBGL_compressed_texture_s3tc"), n3 === null)
        return null;
      if (t3 === 33776)
        return n3.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (t3 === 33777)
        return n3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (t3 === 33778)
        return n3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (t3 === 33779)
        return n3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    if (t3 === 35840 || t3 === 35841 || t3 === 35842 || t3 === 35843) {
      if (n3 = e2.get("WEBGL_compressed_texture_pvrtc"), n3 === null)
        return null;
      if (t3 === 35840)
        return n3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (t3 === 35841)
        return n3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (t3 === 35842)
        return n3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (t3 === 35843)
        return n3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (t3 === 36196)
      return n3 = e2.get("WEBGL_compressed_texture_etc1"), n3 !== null ? n3.COMPRESSED_RGB_ETC1_WEBGL : null;
    if ((t3 === 37492 || t3 === 37496) && (n3 = e2.get("WEBGL_compressed_texture_etc"), n3 !== null)) {
      if (t3 === 37492)
        return n3.COMPRESSED_RGB8_ETC2;
      if (t3 === 37496)
        return n3.COMPRESSED_RGBA8_ETC2_EAC;
    }
    return t3 === 37808 || t3 === 37809 || t3 === 37810 || t3 === 37811 || t3 === 37812 || t3 === 37813 || t3 === 37814 || t3 === 37815 || t3 === 37816 || t3 === 37817 || t3 === 37818 || t3 === 37819 || t3 === 37820 || t3 === 37821 || t3 === 37840 || t3 === 37841 || t3 === 37842 || t3 === 37843 || t3 === 37844 || t3 === 37845 || t3 === 37846 || t3 === 37847 || t3 === 37848 || t3 === 37849 || t3 === 37850 || t3 === 37851 || t3 === 37852 || t3 === 37853 ? (n3 = e2.get("WEBGL_compressed_texture_astc"), n3 !== null ? t3 : null) : t3 === 36492 ? (n3 = e2.get("EXT_texture_compression_bptc"), n3 !== null ? t3 : null) : t3 === 1020 ? i2 ? 34042 : (n3 = e2.get("WEBGL_depth_texture"), n3 !== null ? n3.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
  } };
}
class Is extends Un {
  constructor(t2 = []) {
    super(), this.cameras = t2;
  }
}
Is.prototype.isArrayCamera = true;
class Ds extends Le {
  constructor() {
    super(), this.type = "Group";
  }
}
Ds.prototype.isGroup = true;
const Ns = { type: "move" };
class Fs {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Ds(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Ds(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new At(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new At()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Ds(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new At(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new At()), this._grip;
  }
  dispatchEvent(t2) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t2), this._grip !== null && this._grip.dispatchEvent(t2), this._hand !== null && this._hand.dispatchEvent(t2), this;
  }
  disconnect(t2) {
    return this.dispatchEvent({ type: "disconnected", data: t2 }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
  }
  update(t2, e2, n2) {
    let i2 = null, r2 = null, s2 = null;
    const a2 = this._targetRay, o2 = this._grip, l2 = this._hand;
    if (t2 && e2.session.visibilityState !== "visible-blurred")
      if (a2 !== null && (i2 = e2.getPose(t2.targetRaySpace, n2), i2 !== null && (a2.matrix.fromArray(i2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), i2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(i2.linearVelocity)) : a2.hasLinearVelocity = false, i2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(i2.angularVelocity)) : a2.hasAngularVelocity = false, this.dispatchEvent(Ns))), l2 && t2.hand) {
        s2 = true;
        for (const i4 of t2.hand.values()) {
          const t3 = e2.getJointPose(i4, n2);
          if (l2.joints[i4.jointName] === void 0) {
            const t4 = new Ds();
            t4.matrixAutoUpdate = false, t4.visible = false, l2.joints[i4.jointName] = t4, l2.add(t4);
          }
          const r4 = l2.joints[i4.jointName];
          t3 !== null && (r4.matrix.fromArray(t3.transform.matrix), r4.matrix.decompose(r4.position, r4.rotation, r4.scale), r4.jointRadius = t3.radius), r4.visible = t3 !== null;
        }
        const i3 = l2.joints["index-finger-tip"], r3 = l2.joints["thumb-tip"], a3 = i3.position.distanceTo(r3.position), o3 = 0.02, c2 = 5e-3;
        l2.inputState.pinching && a3 > o3 + c2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t2.handedness, target: this })) : !l2.inputState.pinching && a3 <= o3 - c2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t2.handedness, target: this }));
      } else
        o2 !== null && t2.gripSpace && (r2 = e2.getPose(t2.gripSpace, n2), r2 !== null && (o2.matrix.fromArray(r2.transform.matrix), o2.matrix.decompose(o2.position, o2.rotation, o2.scale), r2.linearVelocity ? (o2.hasLinearVelocity = true, o2.linearVelocity.copy(r2.linearVelocity)) : o2.hasLinearVelocity = false, r2.angularVelocity ? (o2.hasAngularVelocity = true, o2.angularVelocity.copy(r2.angularVelocity)) : o2.hasAngularVelocity = false));
    return a2 !== null && (a2.visible = i2 !== null), o2 !== null && (o2.visible = r2 !== null), l2 !== null && (l2.visible = s2 !== null), this;
  }
}
class Os extends wt {
  constructor(t2, e2, n2, i2, r2, s2, a2, o2, l2, c2) {
    if ((c2 = c2 !== void 0 ? c2 : 1026) !== 1026 && c2 !== 1027)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n2 === void 0 && c2 === 1026 && (n2 = 1012), n2 === void 0 && c2 === 1027 && (n2 = 1020), super(null, i2, r2, s2, a2, o2, c2, n2, l2), this.image = { width: t2, height: e2 }, this.magFilter = a2 !== void 0 ? a2 : 1003, this.minFilter = o2 !== void 0 ? o2 : 1003, this.flipY = false, this.generateMipmaps = false;
  }
}
Os.prototype.isDepthTexture = true;
class Us extends et {
  constructor(t2, e2) {
    super();
    const n2 = this;
    let i2 = null, r2 = 1, s2 = null, a2 = "local-floor";
    const o2 = t2.extensions.has("WEBGL_multisampled_render_to_texture");
    let l2 = null, c2 = null, h2 = null, u2 = null, d2 = false, p2 = null;
    const m2 = e2.getContextAttributes();
    let f2 = null, g2 = null;
    const v2 = [], y2 = /* @__PURE__ */ new Map(), x2 = new Un();
    x2.layers.enable(1), x2.viewport = new Mt();
    const b2 = new Un();
    b2.layers.enable(2), b2.viewport = new Mt();
    const w2 = [x2, b2], _2 = new Is();
    _2.layers.enable(1), _2.layers.enable(2);
    let M2 = null, S2 = null;
    function T2(t3) {
      const e3 = y2.get(t3.inputSource);
      e3 && e3.dispatchEvent({ type: t3.type, data: t3.inputSource });
    }
    function E2() {
      y2.forEach(function(t3, e3) {
        t3.disconnect(e3);
      }), y2.clear(), M2 = null, S2 = null, t2.setRenderTarget(f2), u2 = null, h2 = null, c2 = null, i2 = null, g2 = null, I2.stop(), n2.isPresenting = false, n2.dispatchEvent({ type: "sessionend" });
    }
    function A2(t3) {
      const e3 = i2.inputSources;
      for (let t4 = 0; t4 < v2.length; t4++)
        y2.set(e3[t4], v2[t4]);
      for (let e4 = 0; e4 < t3.removed.length; e4++) {
        const n3 = t3.removed[e4], i3 = y2.get(n3);
        i3 && (i3.dispatchEvent({ type: "disconnected", data: n3 }), y2.delete(n3));
      }
      for (let e4 = 0; e4 < t3.added.length; e4++) {
        const n3 = t3.added[e4], i3 = y2.get(n3);
        i3 && i3.dispatchEvent({ type: "connected", data: n3 });
      }
    }
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(t3) {
      let e3 = v2[t3];
      return e3 === void 0 && (e3 = new Fs(), v2[t3] = e3), e3.getTargetRaySpace();
    }, this.getControllerGrip = function(t3) {
      let e3 = v2[t3];
      return e3 === void 0 && (e3 = new Fs(), v2[t3] = e3), e3.getGripSpace();
    }, this.getHand = function(t3) {
      let e3 = v2[t3];
      return e3 === void 0 && (e3 = new Fs(), v2[t3] = e3), e3.getHandSpace();
    }, this.setFramebufferScaleFactor = function(t3) {
      r2 = t3, n2.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(t3) {
      a2 = t3, n2.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return s2;
    }, this.getBaseLayer = function() {
      return h2 !== null ? h2 : u2;
    }, this.getBinding = function() {
      return c2;
    }, this.getFrame = function() {
      return p2;
    }, this.getSession = function() {
      return i2;
    }, this.setSession = async function(l3) {
      if (i2 = l3, i2 !== null) {
        if (f2 = t2.getRenderTarget(), i2.addEventListener("select", T2), i2.addEventListener("selectstart", T2), i2.addEventListener("selectend", T2), i2.addEventListener("squeeze", T2), i2.addEventListener("squeezestart", T2), i2.addEventListener("squeezeend", T2), i2.addEventListener("end", E2), i2.addEventListener("inputsourceschange", A2), m2.xrCompatible !== true && await e2.makeXRCompatible(), i2.renderState.layers === void 0 || t2.capabilities.isWebGL2 === false) {
          const n3 = { antialias: i2.renderState.layers !== void 0 || m2.antialias, alpha: m2.alpha, depth: m2.depth, stencil: m2.stencil, framebufferScaleFactor: r2 };
          u2 = new XRWebGLLayer(i2, e2, n3), i2.updateRenderState({ baseLayer: u2 }), g2 = new St(u2.framebufferWidth, u2.framebufferHeight, { format: 1023, type: 1009, encoding: t2.outputEncoding });
        } else {
          d2 = m2.antialias;
          let n3 = null, s3 = null, a3 = null;
          m2.depth && (a3 = m2.stencil ? 35056 : 33190, n3 = m2.stencil ? 1027 : 1026, s3 = m2.stencil ? 1020 : 1012);
          const l4 = { colorFormat: m2.alpha || d2 ? 32856 : 32849, depthFormat: a3, scaleFactor: r2 };
          c2 = new XRWebGLBinding(i2, e2), h2 = c2.createProjectionLayer(l4), i2.updateRenderState({ layers: [h2] }), g2 = d2 ? new Tt(h2.textureWidth, h2.textureHeight, { format: 1023, type: 1009, depthTexture: new Os(h2.textureWidth, h2.textureHeight, s3, void 0, void 0, void 0, void 0, void 0, void 0, n3), stencilBuffer: m2.stencil, ignoreDepth: h2.ignoreDepthValues, useRenderToTexture: o2, encoding: t2.outputEncoding }) : new St(h2.textureWidth, h2.textureHeight, { format: m2.alpha ? 1023 : 1022, type: 1009, depthTexture: new Os(h2.textureWidth, h2.textureHeight, s3, void 0, void 0, void 0, void 0, void 0, void 0, n3), stencilBuffer: m2.stencil, ignoreDepth: h2.ignoreDepthValues, encoding: t2.outputEncoding });
        }
        this.setFoveation(1), s2 = await i2.requestReferenceSpace(a2), I2.setContext(i2), I2.start(), n2.isPresenting = true, n2.dispatchEvent({ type: "sessionstart" });
      }
    };
    const R2 = new At(), L2 = new At();
    function C2(t3, e3) {
      e3 === null ? t3.matrixWorld.copy(t3.matrix) : t3.matrixWorld.multiplyMatrices(e3.matrixWorld, t3.matrix), t3.matrixWorldInverse.copy(t3.matrixWorld).invert();
    }
    this.updateCamera = function(t3) {
      if (i2 === null)
        return;
      _2.near = b2.near = x2.near = t3.near, _2.far = b2.far = x2.far = t3.far, M2 === _2.near && S2 === _2.far || (i2.updateRenderState({ depthNear: _2.near, depthFar: _2.far }), M2 = _2.near, S2 = _2.far);
      const e3 = t3.parent, n3 = _2.cameras;
      C2(_2, e3);
      for (let t4 = 0; t4 < n3.length; t4++)
        C2(n3[t4], e3);
      _2.matrixWorld.decompose(_2.position, _2.quaternion, _2.scale), t3.position.copy(_2.position), t3.quaternion.copy(_2.quaternion), t3.scale.copy(_2.scale), t3.matrix.copy(_2.matrix), t3.matrixWorld.copy(_2.matrixWorld);
      const r3 = t3.children;
      for (let t4 = 0, e4 = r3.length; t4 < e4; t4++)
        r3[t4].updateMatrixWorld(true);
      n3.length === 2 ? function(t4, e4, n4) {
        R2.setFromMatrixPosition(e4.matrixWorld), L2.setFromMatrixPosition(n4.matrixWorld);
        const i3 = R2.distanceTo(L2), r4 = e4.projectionMatrix.elements, s3 = n4.projectionMatrix.elements, a3 = r4[14] / (r4[10] - 1), o3 = r4[14] / (r4[10] + 1), l3 = (r4[9] + 1) / r4[5], c3 = (r4[9] - 1) / r4[5], h3 = (r4[8] - 1) / r4[0], u3 = (s3[8] + 1) / s3[0], d3 = a3 * h3, p3 = a3 * u3, m3 = i3 / (-h3 + u3), f3 = m3 * -h3;
        e4.matrixWorld.decompose(t4.position, t4.quaternion, t4.scale), t4.translateX(f3), t4.translateZ(m3), t4.matrixWorld.compose(t4.position, t4.quaternion, t4.scale), t4.matrixWorldInverse.copy(t4.matrixWorld).invert();
        const g3 = a3 + m3, v3 = o3 + m3, y3 = d3 - f3, x3 = p3 + (i3 - f3), b3 = l3 * o3 / v3 * g3, w3 = c3 * o3 / v3 * g3;
        t4.projectionMatrix.makePerspective(y3, x3, b3, w3, g3, v3);
      }(_2, x2, b2) : _2.projectionMatrix.copy(x2.projectionMatrix);
    }, this.getCamera = function() {
      return _2;
    }, this.getFoveation = function() {
      return h2 !== null ? h2.fixedFoveation : u2 !== null ? u2.fixedFoveation : void 0;
    }, this.setFoveation = function(t3) {
      h2 !== null && (h2.fixedFoveation = t3), u2 !== null && u2.fixedFoveation !== void 0 && (u2.fixedFoveation = t3);
    };
    let P2 = null;
    const I2 = new Yn();
    I2.setAnimationLoop(function(e3, n3) {
      if (l2 = n3.getViewerPose(s2), p2 = n3, l2 !== null) {
        const e4 = l2.views;
        u2 !== null && (t2.setRenderTargetFramebuffer(g2, u2.framebuffer), t2.setRenderTarget(g2));
        let n4 = false;
        e4.length !== _2.cameras.length && (_2.cameras.length = 0, n4 = true);
        for (let i3 = 0; i3 < e4.length; i3++) {
          const r4 = e4[i3];
          let s3 = null;
          if (u2 !== null)
            s3 = u2.getViewport(r4);
          else {
            const e5 = c2.getViewSubImage(h2, r4);
            s3 = e5.viewport, i3 === 0 && (t2.setRenderTargetTextures(g2, e5.colorTexture, h2.ignoreDepthValues ? void 0 : e5.depthStencilTexture), t2.setRenderTarget(g2));
          }
          const a3 = w2[i3];
          a3.matrix.fromArray(r4.transform.matrix), a3.projectionMatrix.fromArray(r4.projectionMatrix), a3.viewport.set(s3.x, s3.y, s3.width, s3.height), i3 === 0 && _2.matrix.copy(a3.matrix), n4 === true && _2.cameras.push(a3);
        }
      }
      const r3 = i2.inputSources;
      for (let t3 = 0; t3 < v2.length; t3++) {
        const e4 = v2[t3], i3 = r3[t3];
        e4.update(i3, n3, s2);
      }
      P2 && P2(e3, n3), p2 = null;
    }), this.setAnimationLoop = function(t3) {
      P2 = t3;
    }, this.dispose = function() {
    };
  }
}
function ks(t2) {
  function e2(e3, n3) {
    e3.opacity.value = n3.opacity, n3.color && e3.diffuse.value.copy(n3.color), n3.emissive && e3.emissive.value.copy(n3.emissive).multiplyScalar(n3.emissiveIntensity), n3.map && (e3.map.value = n3.map), n3.alphaMap && (e3.alphaMap.value = n3.alphaMap), n3.specularMap && (e3.specularMap.value = n3.specularMap), n3.alphaTest > 0 && (e3.alphaTest.value = n3.alphaTest);
    const i2 = t2.get(n3).envMap;
    let r2, s2;
    i2 && (e3.envMap.value = i2, e3.flipEnvMap.value = i2.isCubeTexture && i2.isRenderTargetTexture === false ? -1 : 1, e3.reflectivity.value = n3.reflectivity, e3.ior.value = n3.ior, e3.refractionRatio.value = n3.refractionRatio), n3.lightMap && (e3.lightMap.value = n3.lightMap, e3.lightMapIntensity.value = n3.lightMapIntensity), n3.aoMap && (e3.aoMap.value = n3.aoMap, e3.aoMapIntensity.value = n3.aoMapIntensity), n3.map ? r2 = n3.map : n3.specularMap ? r2 = n3.specularMap : n3.displacementMap ? r2 = n3.displacementMap : n3.normalMap ? r2 = n3.normalMap : n3.bumpMap ? r2 = n3.bumpMap : n3.roughnessMap ? r2 = n3.roughnessMap : n3.metalnessMap ? r2 = n3.metalnessMap : n3.alphaMap ? r2 = n3.alphaMap : n3.emissiveMap ? r2 = n3.emissiveMap : n3.clearcoatMap ? r2 = n3.clearcoatMap : n3.clearcoatNormalMap ? r2 = n3.clearcoatNormalMap : n3.clearcoatRoughnessMap ? r2 = n3.clearcoatRoughnessMap : n3.specularIntensityMap ? r2 = n3.specularIntensityMap : n3.specularColorMap ? r2 = n3.specularColorMap : n3.transmissionMap ? r2 = n3.transmissionMap : n3.thicknessMap ? r2 = n3.thicknessMap : n3.sheenColorMap ? r2 = n3.sheenColorMap : n3.sheenRoughnessMap && (r2 = n3.sheenRoughnessMap), r2 !== void 0 && (r2.isWebGLRenderTarget && (r2 = r2.texture), r2.matrixAutoUpdate === true && r2.updateMatrix(), e3.uvTransform.value.copy(r2.matrix)), n3.aoMap ? s2 = n3.aoMap : n3.lightMap && (s2 = n3.lightMap), s2 !== void 0 && (s2.isWebGLRenderTarget && (s2 = s2.texture), s2.matrixAutoUpdate === true && s2.updateMatrix(), e3.uv2Transform.value.copy(s2.matrix));
  }
  function n2(e3, n3) {
    e3.roughness.value = n3.roughness, e3.metalness.value = n3.metalness, n3.roughnessMap && (e3.roughnessMap.value = n3.roughnessMap), n3.metalnessMap && (e3.metalnessMap.value = n3.metalnessMap), n3.emissiveMap && (e3.emissiveMap.value = n3.emissiveMap), n3.bumpMap && (e3.bumpMap.value = n3.bumpMap, e3.bumpScale.value = n3.bumpScale, n3.side === 1 && (e3.bumpScale.value *= -1)), n3.normalMap && (e3.normalMap.value = n3.normalMap, e3.normalScale.value.copy(n3.normalScale), n3.side === 1 && e3.normalScale.value.negate()), n3.displacementMap && (e3.displacementMap.value = n3.displacementMap, e3.displacementScale.value = n3.displacementScale, e3.displacementBias.value = n3.displacementBias);
    t2.get(n3).envMap && (e3.envMapIntensity.value = n3.envMapIntensity);
  }
  return { refreshFogUniforms: function(t3, e3) {
    t3.fogColor.value.copy(e3.color), e3.isFog ? (t3.fogNear.value = e3.near, t3.fogFar.value = e3.far) : e3.isFogExp2 && (t3.fogDensity.value = e3.density);
  }, refreshMaterialUniforms: function(t3, i2, r2, s2, a2) {
    i2.isMeshBasicMaterial ? e2(t3, i2) : i2.isMeshLambertMaterial ? (e2(t3, i2), function(t4, e3) {
      e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
    }(t3, i2)) : i2.isMeshToonMaterial ? (e2(t3, i2), function(t4, e3) {
      e3.gradientMap && (t4.gradientMap.value = e3.gradientMap);
      e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
      e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === 1 && (t4.bumpScale.value *= -1));
      e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === 1 && t4.normalScale.value.negate());
      e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
    }(t3, i2)) : i2.isMeshPhongMaterial ? (e2(t3, i2), function(t4, e3) {
      t4.specular.value.copy(e3.specular), t4.shininess.value = Math.max(e3.shininess, 1e-4), e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
      e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === 1 && (t4.bumpScale.value *= -1));
      e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === 1 && t4.normalScale.value.negate());
      e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
    }(t3, i2)) : i2.isMeshStandardMaterial ? (e2(t3, i2), i2.isMeshPhysicalMaterial ? function(t4, e3, i3) {
      n2(t4, e3), t4.ior.value = e3.ior, e3.sheen > 0 && (t4.sheenColor.value.copy(e3.sheenColor).multiplyScalar(e3.sheen), t4.sheenRoughness.value = e3.sheenRoughness, e3.sheenColorMap && (t4.sheenColorMap.value = e3.sheenColorMap), e3.sheenRoughnessMap && (t4.sheenRoughnessMap.value = e3.sheenRoughnessMap));
      e3.clearcoat > 0 && (t4.clearcoat.value = e3.clearcoat, t4.clearcoatRoughness.value = e3.clearcoatRoughness, e3.clearcoatMap && (t4.clearcoatMap.value = e3.clearcoatMap), e3.clearcoatRoughnessMap && (t4.clearcoatRoughnessMap.value = e3.clearcoatRoughnessMap), e3.clearcoatNormalMap && (t4.clearcoatNormalScale.value.copy(e3.clearcoatNormalScale), t4.clearcoatNormalMap.value = e3.clearcoatNormalMap, e3.side === 1 && t4.clearcoatNormalScale.value.negate()));
      e3.transmission > 0 && (t4.transmission.value = e3.transmission, t4.transmissionSamplerMap.value = i3.texture, t4.transmissionSamplerSize.value.set(i3.width, i3.height), e3.transmissionMap && (t4.transmissionMap.value = e3.transmissionMap), t4.thickness.value = e3.thickness, e3.thicknessMap && (t4.thicknessMap.value = e3.thicknessMap), t4.attenuationDistance.value = e3.attenuationDistance, t4.attenuationColor.value.copy(e3.attenuationColor));
      t4.specularIntensity.value = e3.specularIntensity, t4.specularColor.value.copy(e3.specularColor), e3.specularIntensityMap && (t4.specularIntensityMap.value = e3.specularIntensityMap);
      e3.specularColorMap && (t4.specularColorMap.value = e3.specularColorMap);
    }(t3, i2, a2) : n2(t3, i2)) : i2.isMeshMatcapMaterial ? (e2(t3, i2), function(t4, e3) {
      e3.matcap && (t4.matcap.value = e3.matcap);
      e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === 1 && (t4.bumpScale.value *= -1));
      e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === 1 && t4.normalScale.value.negate());
      e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
    }(t3, i2)) : i2.isMeshDepthMaterial ? (e2(t3, i2), function(t4, e3) {
      e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
    }(t3, i2)) : i2.isMeshDistanceMaterial ? (e2(t3, i2), function(t4, e3) {
      e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
      t4.referencePosition.value.copy(e3.referencePosition), t4.nearDistance.value = e3.nearDistance, t4.farDistance.value = e3.farDistance;
    }(t3, i2)) : i2.isMeshNormalMaterial ? (e2(t3, i2), function(t4, e3) {
      e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, e3.side === 1 && (t4.bumpScale.value *= -1));
      e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), e3.side === 1 && t4.normalScale.value.negate());
      e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
    }(t3, i2)) : i2.isLineBasicMaterial ? (function(t4, e3) {
      t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity;
    }(t3, i2), i2.isLineDashedMaterial && function(t4, e3) {
      t4.dashSize.value = e3.dashSize, t4.totalSize.value = e3.dashSize + e3.gapSize, t4.scale.value = e3.scale;
    }(t3, i2)) : i2.isPointsMaterial ? function(t4, e3, n3, i3) {
      t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.size.value = e3.size * n3, t4.scale.value = 0.5 * i3, e3.map && (t4.map.value = e3.map);
      e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
      e3.alphaTest > 0 && (t4.alphaTest.value = e3.alphaTest);
      let r3;
      e3.map ? r3 = e3.map : e3.alphaMap && (r3 = e3.alphaMap);
      r3 !== void 0 && (r3.matrixAutoUpdate === true && r3.updateMatrix(), t4.uvTransform.value.copy(r3.matrix));
    }(t3, i2, r2, s2) : i2.isSpriteMaterial ? function(t4, e3) {
      t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.rotation.value = e3.rotation, e3.map && (t4.map.value = e3.map);
      e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
      e3.alphaTest > 0 && (t4.alphaTest.value = e3.alphaTest);
      let n3;
      e3.map ? n3 = e3.map : e3.alphaMap && (n3 = e3.alphaMap);
      n3 !== void 0 && (n3.matrixAutoUpdate === true && n3.updateMatrix(), t4.uvTransform.value.copy(n3.matrix));
    }(t3, i2) : i2.isShadowMaterial ? (t3.color.value.copy(i2.color), t3.opacity.value = i2.opacity) : i2.isShaderMaterial && (i2.uniformsNeedUpdate = false);
  } };
}
function zs(t2 = {}) {
  const e2 = t2.canvas !== void 0 ? t2.canvas : function() {
    const t3 = vt("canvas");
    return t3.style.display = "block", t3;
  }(), n2 = t2.context !== void 0 ? t2.context : null, i2 = t2.alpha !== void 0 && t2.alpha, r2 = t2.depth === void 0 || t2.depth, s2 = t2.stencil === void 0 || t2.stencil, a2 = t2.antialias !== void 0 && t2.antialias, o2 = t2.premultipliedAlpha === void 0 || t2.premultipliedAlpha, l2 = t2.preserveDrawingBuffer !== void 0 && t2.preserveDrawingBuffer, c2 = t2.powerPreference !== void 0 ? t2.powerPreference : "default", h2 = t2.failIfMajorPerformanceCaveat !== void 0 && t2.failIfMajorPerformanceCaveat;
  let u2 = null, d2 = null;
  const p2 = [], m2 = [];
  this.domElement = e2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = 3e3, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
  const f2 = this;
  let g2 = false, v2 = 0, y2 = 0, x2 = null, b2 = -1, w2 = null;
  const _2 = new Mt(), M2 = new Mt();
  let S2 = null, T2 = e2.width, E2 = e2.height, A2 = 1, R2 = null, L2 = null;
  const C2 = new Mt(0, 0, T2, E2), P2 = new Mt(0, 0, T2, E2);
  let I2 = false;
  const D2 = [], N2 = new Xn();
  let F2 = false, O2 = false, U2 = null;
  const k2 = new re(), z2 = new At(), B2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function H2() {
    return x2 === null ? A2 : 1;
  }
  let V2, G2, W2, j2, q2, X2, Y2, Z2, J2, $2, K2, Q2, tt2, et2, nt2, it2, rt2, st2, at2, ot2, lt2, ct2, ht2, ut2 = n2;
  function dt2(t3, n3) {
    for (let i3 = 0; i3 < t3.length; i3++) {
      const r3 = t3[i3], s3 = e2.getContext(r3, n3);
      if (s3 !== null)
        return s3;
    }
    return null;
  }
  try {
    const t3 = { alpha: i2, depth: r2, stencil: s2, antialias: a2, premultipliedAlpha: o2, preserveDrawingBuffer: l2, powerPreference: c2, failIfMajorPerformanceCaveat: h2 };
    if ("setAttribute" in e2 && e2.setAttribute("data-engine", "three.js r136"), e2.addEventListener("webglcontextlost", ft2, false), e2.addEventListener("webglcontextrestored", gt2, false), ut2 === null) {
      const e3 = ["webgl2", "webgl", "experimental-webgl"];
      if (f2.isWebGL1Renderer === true && e3.shift(), ut2 = dt2(e3, t3), ut2 === null)
        throw dt2(e3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    ut2.getShaderPrecisionFormat === void 0 && (ut2.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (t3) {
    throw console.error("THREE.WebGLRenderer: " + t3.message), t3;
  }
  function pt2() {
    V2 = new Ci(ut2), G2 = new ii(ut2, V2, t2), V2.init(G2), ct2 = new Ps(ut2, V2, G2), W2 = new Ls(ut2, V2, G2), D2[0] = 1029, j2 = new Di(ut2), q2 = new fs(), X2 = new Cs(ut2, V2, W2, q2, G2, ct2, j2), Y2 = new si(f2), Z2 = new Li(f2), J2 = new Zn(ut2, G2), ht2 = new ei(ut2, V2, J2, G2), $2 = new Pi(ut2, J2, j2, ht2), K2 = new zi(ut2, $2, J2, j2), at2 = new ki(ut2, G2, X2), it2 = new ri(q2), Q2 = new ms(f2, Y2, Z2, V2, G2, ht2, it2), tt2 = new ks(q2), et2 = new xs(), nt2 = new Ts(V2, G2), st2 = new ti(f2, Y2, W2, K2, o2), rt2 = new Rs(f2, K2, G2), ot2 = new ni(ut2, V2, j2, G2), lt2 = new Ii(ut2, V2, j2, G2), j2.programs = Q2.programs, f2.capabilities = G2, f2.extensions = V2, f2.properties = q2, f2.renderLists = et2, f2.shadowMap = rt2, f2.state = W2, f2.info = j2;
  }
  pt2();
  const mt2 = new Us(f2, ut2);
  function ft2(t3) {
    t3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g2 = true;
  }
  function gt2() {
    console.log("THREE.WebGLRenderer: Context Restored."), g2 = false;
    const t3 = j2.autoReset, e3 = rt2.enabled, n3 = rt2.autoUpdate, i3 = rt2.needsUpdate, r3 = rt2.type;
    pt2(), j2.autoReset = t3, rt2.enabled = e3, rt2.autoUpdate = n3, rt2.needsUpdate = i3, rt2.type = r3;
  }
  function yt2(t3) {
    const e3 = t3.target;
    e3.removeEventListener("dispose", yt2), function(t4) {
      (function(t5) {
        const e4 = q2.get(t5).programs;
        e4 !== void 0 && (e4.forEach(function(t6) {
          Q2.releaseProgram(t6);
        }), t5.isShaderMaterial && Q2.releaseShaderCache(t5));
      })(t4), q2.remove(t4);
    }(e3);
  }
  this.xr = mt2, this.getContext = function() {
    return ut2;
  }, this.getContextAttributes = function() {
    return ut2.getContextAttributes();
  }, this.forceContextLoss = function() {
    const t3 = V2.get("WEBGL_lose_context");
    t3 && t3.loseContext();
  }, this.forceContextRestore = function() {
    const t3 = V2.get("WEBGL_lose_context");
    t3 && t3.restoreContext();
  }, this.getPixelRatio = function() {
    return A2;
  }, this.setPixelRatio = function(t3) {
    t3 !== void 0 && (A2 = t3, this.setSize(T2, E2, false));
  }, this.getSize = function(t3) {
    return t3.set(T2, E2);
  }, this.setSize = function(t3, n3, i3) {
    mt2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T2 = t3, E2 = n3, e2.width = Math.floor(t3 * A2), e2.height = Math.floor(n3 * A2), i3 !== false && (e2.style.width = t3 + "px", e2.style.height = n3 + "px"), this.setViewport(0, 0, t3, n3));
  }, this.getDrawingBufferSize = function(t3) {
    return t3.set(T2 * A2, E2 * A2).floor();
  }, this.setDrawingBufferSize = function(t3, n3, i3) {
    T2 = t3, E2 = n3, A2 = i3, e2.width = Math.floor(t3 * i3), e2.height = Math.floor(n3 * i3), this.setViewport(0, 0, t3, n3);
  }, this.getCurrentViewport = function(t3) {
    return t3.copy(_2);
  }, this.getViewport = function(t3) {
    return t3.copy(C2);
  }, this.setViewport = function(t3, e3, n3, i3) {
    t3.isVector4 ? C2.set(t3.x, t3.y, t3.z, t3.w) : C2.set(t3, e3, n3, i3), W2.viewport(_2.copy(C2).multiplyScalar(A2).floor());
  }, this.getScissor = function(t3) {
    return t3.copy(P2);
  }, this.setScissor = function(t3, e3, n3, i3) {
    t3.isVector4 ? P2.set(t3.x, t3.y, t3.z, t3.w) : P2.set(t3, e3, n3, i3), W2.scissor(M2.copy(P2).multiplyScalar(A2).floor());
  }, this.getScissorTest = function() {
    return I2;
  }, this.setScissorTest = function(t3) {
    W2.setScissorTest(I2 = t3);
  }, this.setOpaqueSort = function(t3) {
    R2 = t3;
  }, this.setTransparentSort = function(t3) {
    L2 = t3;
  }, this.getClearColor = function(t3) {
    return t3.copy(st2.getClearColor());
  }, this.setClearColor = function() {
    st2.setClearColor.apply(st2, arguments);
  }, this.getClearAlpha = function() {
    return st2.getClearAlpha();
  }, this.setClearAlpha = function() {
    st2.setClearAlpha.apply(st2, arguments);
  }, this.clear = function(t3, e3, n3) {
    let i3 = 0;
    (t3 === void 0 || t3) && (i3 |= 16384), (e3 === void 0 || e3) && (i3 |= 256), (n3 === void 0 || n3) && (i3 |= 1024), ut2.clear(i3);
  }, this.clearColor = function() {
    this.clear(true, false, false);
  }, this.clearDepth = function() {
    this.clear(false, true, false);
  }, this.clearStencil = function() {
    this.clear(false, false, true);
  }, this.dispose = function() {
    e2.removeEventListener("webglcontextlost", ft2, false), e2.removeEventListener("webglcontextrestored", gt2, false), et2.dispose(), nt2.dispose(), q2.dispose(), Y2.dispose(), Z2.dispose(), K2.dispose(), ht2.dispose(), Q2.dispose(), mt2.dispose(), mt2.removeEventListener("sessionstart", bt2), mt2.removeEventListener("sessionend", wt2), U2 && (U2.dispose(), U2 = null), _t2.stop();
  }, this.renderBufferDirect = function(t3, e3, n3, i3, r3, s3) {
    e3 === null && (e3 = B2);
    const a3 = r3.isMesh && r3.matrixWorld.determinant() < 0, o3 = function(t4, e4, n4, i4, r4) {
      e4.isScene !== true && (e4 = B2);
      X2.resetTextureUnits();
      const s4 = e4.fog, a4 = i4.isMeshStandardMaterial ? e4.environment : null, o4 = x2 === null ? f2.outputEncoding : x2.texture.encoding, l4 = (i4.isMeshStandardMaterial ? Z2 : Y2).get(i4.envMap || a4), c4 = i4.vertexColors === true && !!n4.attributes.color && n4.attributes.color.itemSize === 4, h4 = !!i4.normalMap && !!n4.attributes.tangent, u4 = !!n4.morphAttributes.position, p4 = !!n4.morphAttributes.normal, m4 = n4.morphAttributes.position ? n4.morphAttributes.position.length : 0, g4 = i4.toneMapped ? f2.toneMapping : 0, v4 = q2.get(i4), y4 = d2.state.lights;
      if (F2 === true && (O2 === true || t4 !== w2)) {
        const e5 = t4 === w2 && i4.id === b2;
        it2.setState(i4, t4, e5);
      }
      let _4 = false;
      i4.version === v4.__version ? v4.needsLights && v4.lightsStateVersion !== y4.state.version || v4.outputEncoding !== o4 || r4.isInstancedMesh && v4.instancing === false ? _4 = true : r4.isInstancedMesh || v4.instancing !== true ? r4.isSkinnedMesh && v4.skinning === false ? _4 = true : r4.isSkinnedMesh || v4.skinning !== true ? v4.envMap !== l4 || i4.fog && v4.fog !== s4 ? _4 = true : v4.numClippingPlanes === void 0 || v4.numClippingPlanes === it2.numPlanes && v4.numIntersection === it2.numIntersection ? (v4.vertexAlphas !== c4 || v4.vertexTangents !== h4 || v4.morphTargets !== u4 || v4.morphNormals !== p4 || v4.toneMapping !== g4 || G2.isWebGL2 === true && v4.morphTargetsCount !== m4) && (_4 = true) : _4 = true : _4 = true : _4 = true : (_4 = true, v4.__version = i4.version);
      let M4 = v4.currentProgram;
      _4 === true && (M4 = Pt2(i4, e4, r4));
      let S4 = false, T4 = false, R3 = false;
      const L3 = M4.getUniforms(), C3 = v4.uniforms;
      W2.useProgram(M4.program) && (S4 = true, T4 = true, R3 = true);
      i4.id !== b2 && (b2 = i4.id, T4 = true);
      if (S4 || w2 !== t4) {
        if (L3.setValue(ut2, "projectionMatrix", t4.projectionMatrix), G2.logarithmicDepthBuffer && L3.setValue(ut2, "logDepthBufFC", 2 / (Math.log(t4.far + 1) / Math.LN2)), w2 !== t4 && (w2 = t4, T4 = true, R3 = true), i4.isShaderMaterial || i4.isMeshPhongMaterial || i4.isMeshToonMaterial || i4.isMeshStandardMaterial || i4.envMap) {
          const e5 = L3.map.cameraPosition;
          e5 !== void 0 && e5.setValue(ut2, z2.setFromMatrixPosition(t4.matrixWorld));
        }
        (i4.isMeshPhongMaterial || i4.isMeshToonMaterial || i4.isMeshLambertMaterial || i4.isMeshBasicMaterial || i4.isMeshStandardMaterial || i4.isShaderMaterial) && L3.setValue(ut2, "isOrthographic", t4.isOrthographicCamera === true), (i4.isMeshPhongMaterial || i4.isMeshToonMaterial || i4.isMeshLambertMaterial || i4.isMeshBasicMaterial || i4.isMeshStandardMaterial || i4.isShaderMaterial || i4.isShadowMaterial || r4.isSkinnedMesh) && L3.setValue(ut2, "viewMatrix", t4.matrixWorldInverse);
      }
      if (r4.isSkinnedMesh) {
        L3.setOptional(ut2, r4, "bindMatrix"), L3.setOptional(ut2, r4, "bindMatrixInverse");
        const t5 = r4.skeleton;
        t5 && (G2.floatVertexTextures ? (t5.boneTexture === null && t5.computeBoneTexture(), L3.setValue(ut2, "boneTexture", t5.boneTexture, X2), L3.setValue(ut2, "boneTextureSize", t5.boneTextureSize)) : L3.setOptional(ut2, t5, "boneMatrices"));
      }
      !n4 || n4.morphAttributes.position === void 0 && n4.morphAttributes.normal === void 0 || at2.update(r4, n4, i4, M4);
      (T4 || v4.receiveShadow !== r4.receiveShadow) && (v4.receiveShadow = r4.receiveShadow, L3.setValue(ut2, "receiveShadow", r4.receiveShadow));
      T4 && (L3.setValue(ut2, "toneMappingExposure", f2.toneMappingExposure), v4.needsLights && (I3 = R3, (P3 = C3).ambientLightColor.needsUpdate = I3, P3.lightProbe.needsUpdate = I3, P3.directionalLights.needsUpdate = I3, P3.directionalLightShadows.needsUpdate = I3, P3.pointLights.needsUpdate = I3, P3.pointLightShadows.needsUpdate = I3, P3.spotLights.needsUpdate = I3, P3.spotLightShadows.needsUpdate = I3, P3.rectAreaLights.needsUpdate = I3, P3.hemisphereLights.needsUpdate = I3), s4 && i4.fog && tt2.refreshFogUniforms(C3, s4), tt2.refreshMaterialUniforms(C3, i4, A2, E2, U2), Wr.upload(ut2, v4.uniformsList, C3, X2));
      var P3, I3;
      i4.isShaderMaterial && i4.uniformsNeedUpdate === true && (Wr.upload(ut2, v4.uniformsList, C3, X2), i4.uniformsNeedUpdate = false);
      i4.isSpriteMaterial && L3.setValue(ut2, "center", r4.center);
      return L3.setValue(ut2, "modelViewMatrix", r4.modelViewMatrix), L3.setValue(ut2, "normalMatrix", r4.normalMatrix), L3.setValue(ut2, "modelMatrix", r4.matrixWorld), M4;
    }(t3, e3, n3, i3, r3);
    W2.setMaterial(i3, a3);
    let l3 = n3.index;
    const c3 = n3.attributes.position;
    if (l3 === null) {
      if (c3 === void 0 || c3.count === 0)
        return;
    } else if (l3.count === 0)
      return;
    let h3, u3 = 1;
    i3.wireframe === true && (l3 = $2.getWireframeAttribute(n3), u3 = 2), ht2.setup(r3, i3, o3, n3, l3);
    let p3 = ot2;
    l3 !== null && (h3 = J2.get(l3), p3 = lt2, p3.setIndex(h3));
    const m3 = l3 !== null ? l3.count : c3.count, g3 = n3.drawRange.start * u3, v3 = n3.drawRange.count * u3, y3 = s3 !== null ? s3.start * u3 : 0, _3 = s3 !== null ? s3.count * u3 : 1 / 0, M3 = Math.max(g3, y3), S3 = Math.min(m3, g3 + v3, y3 + _3) - 1, T3 = Math.max(0, S3 - M3 + 1);
    if (T3 !== 0) {
      if (r3.isMesh)
        i3.wireframe === true ? (W2.setLineWidth(i3.wireframeLinewidth * H2()), p3.setMode(1)) : p3.setMode(4);
      else if (r3.isLine) {
        let t4 = i3.linewidth;
        t4 === void 0 && (t4 = 1), W2.setLineWidth(t4 * H2()), r3.isLineSegments ? p3.setMode(1) : r3.isLineLoop ? p3.setMode(2) : p3.setMode(3);
      } else
        r3.isPoints ? p3.setMode(0) : r3.isSprite && p3.setMode(4);
      if (r3.isInstancedMesh)
        p3.renderInstances(M3, T3, r3.count);
      else if (n3.isInstancedBufferGeometry) {
        const t4 = Math.min(n3.instanceCount, n3._maxInstanceCount);
        p3.renderInstances(M3, T3, t4);
      } else
        p3.render(M3, T3);
    }
  }, this.compile = function(t3, e3) {
    d2 = nt2.get(t3), d2.init(), m2.push(d2), t3.traverseVisible(function(t4) {
      t4.isLight && t4.layers.test(e3.layers) && (d2.pushLight(t4), t4.castShadow && d2.pushShadow(t4));
    }), d2.setupLights(f2.physicallyCorrectLights), t3.traverse(function(e4) {
      const n3 = e4.material;
      if (n3)
        if (Array.isArray(n3))
          for (let i3 = 0; i3 < n3.length; i3++) {
            Pt2(n3[i3], t3, e4);
          }
        else
          Pt2(n3, t3, e4);
    }), m2.pop(), d2 = null;
  };
  let xt2 = null;
  function bt2() {
    _t2.stop();
  }
  function wt2() {
    _t2.start();
  }
  const _t2 = new Yn();
  function Et2(t3, e3, n3, i3) {
    if (t3.visible === false)
      return;
    if (t3.layers.test(e3.layers)) {
      if (t3.isGroup)
        n3 = t3.renderOrder;
      else if (t3.isLOD)
        t3.autoUpdate === true && t3.update(e3);
      else if (t3.isLight)
        d2.pushLight(t3), t3.castShadow && d2.pushShadow(t3);
      else if (t3.isSprite) {
        if (!t3.frustumCulled || N2.intersectsSprite(t3)) {
          i3 && z2.setFromMatrixPosition(t3.matrixWorld).applyMatrix4(k2);
          const e4 = K2.update(t3), r4 = t3.material;
          r4.visible && u2.push(t3, e4, r4, n3, z2.z, null);
        }
      } else if ((t3.isMesh || t3.isLine || t3.isPoints) && (t3.isSkinnedMesh && t3.skeleton.frame !== j2.render.frame && (t3.skeleton.update(), t3.skeleton.frame = j2.render.frame), !t3.frustumCulled || N2.intersectsObject(t3))) {
        i3 && z2.setFromMatrixPosition(t3.matrixWorld).applyMatrix4(k2);
        const e4 = K2.update(t3), r4 = t3.material;
        if (Array.isArray(r4)) {
          const i4 = e4.groups;
          for (let s3 = 0, a3 = i4.length; s3 < a3; s3++) {
            const a4 = i4[s3], o3 = r4[a4.materialIndex];
            o3 && o3.visible && u2.push(t3, e4, o3, n3, z2.z, a4);
          }
        } else
          r4.visible && u2.push(t3, e4, r4, n3, z2.z, null);
      }
    }
    const r3 = t3.children;
    for (let t4 = 0, s3 = r3.length; t4 < s3; t4++)
      Et2(r3[t4], e3, n3, i3);
  }
  function Rt2(t3, e3, n3, i3) {
    const r3 = t3.opaque, s3 = t3.transmissive, o3 = t3.transparent;
    d2.setupLightsView(n3), s3.length > 0 && function(t4, e4, n4) {
      if (U2 === null) {
        const t5 = a2 === true && G2.isWebGL2 === true;
        U2 = new (t5 ? Tt : St)(1024, 1024, { generateMipmaps: true, type: ct2.convert(1016) !== null ? 1016 : 1009, minFilter: 1008, magFilter: 1003, wrapS: 1001, wrapT: 1001, useRenderToTexture: V2.has("WEBGL_multisampled_render_to_texture") });
      }
      const i4 = f2.getRenderTarget();
      f2.setRenderTarget(U2), f2.clear();
      const r4 = f2.toneMapping;
      f2.toneMapping = 0, Lt2(t4, e4, n4), f2.toneMapping = r4, X2.updateMultisampleRenderTarget(U2), X2.updateRenderTargetMipmap(U2), f2.setRenderTarget(i4);
    }(r3, e3, n3), i3 && W2.viewport(_2.copy(i3)), r3.length > 0 && Lt2(r3, e3, n3), s3.length > 0 && Lt2(s3, e3, n3), o3.length > 0 && Lt2(o3, e3, n3);
  }
  function Lt2(t3, e3, n3) {
    const i3 = e3.isScene === true ? e3.overrideMaterial : null;
    for (let r3 = 0, s3 = t3.length; r3 < s3; r3++) {
      const s4 = t3[r3], a3 = s4.object, o3 = s4.geometry, l3 = i3 === null ? s4.material : i3, c3 = s4.group;
      a3.layers.test(n3.layers) && Ct2(a3, e3, n3, o3, l3, c3);
    }
  }
  function Ct2(t3, e3, n3, i3, r3, s3) {
    t3.onBeforeRender(f2, e3, n3, i3, r3, s3), t3.modelViewMatrix.multiplyMatrices(n3.matrixWorldInverse, t3.matrixWorld), t3.normalMatrix.getNormalMatrix(t3.modelViewMatrix), r3.onBeforeRender(f2, e3, n3, i3, t3, s3), r3.transparent === true && r3.side === 2 ? (r3.side = 1, r3.needsUpdate = true, f2.renderBufferDirect(n3, e3, i3, r3, t3, s3), r3.side = 0, r3.needsUpdate = true, f2.renderBufferDirect(n3, e3, i3, r3, t3, s3), r3.side = 2) : f2.renderBufferDirect(n3, e3, i3, r3, t3, s3), t3.onAfterRender(f2, e3, n3, i3, r3, s3);
  }
  function Pt2(t3, e3, n3) {
    e3.isScene !== true && (e3 = B2);
    const i3 = q2.get(t3), r3 = d2.state.lights, s3 = d2.state.shadowsArray, a3 = r3.state.version, o3 = Q2.getParameters(t3, r3.state, s3, e3, n3), l3 = Q2.getProgramCacheKey(o3);
    let c3 = i3.programs;
    i3.environment = t3.isMeshStandardMaterial ? e3.environment : null, i3.fog = e3.fog, i3.envMap = (t3.isMeshStandardMaterial ? Z2 : Y2).get(t3.envMap || i3.environment), c3 === void 0 && (t3.addEventListener("dispose", yt2), c3 = /* @__PURE__ */ new Map(), i3.programs = c3);
    let h3 = c3.get(l3);
    if (h3 !== void 0) {
      if (i3.currentProgram === h3 && i3.lightsStateVersion === a3)
        return It2(t3, o3), h3;
    } else
      o3.uniforms = Q2.getUniforms(t3), t3.onBuild(n3, o3, f2), t3.onBeforeCompile(o3, f2), h3 = Q2.acquireProgram(o3, l3), c3.set(l3, h3), i3.uniforms = o3.uniforms;
    const u3 = i3.uniforms;
    (t3.isShaderMaterial || t3.isRawShaderMaterial) && t3.clipping !== true || (u3.clippingPlanes = it2.uniform), It2(t3, o3), i3.needsLights = function(t4) {
      return t4.isMeshLambertMaterial || t4.isMeshToonMaterial || t4.isMeshPhongMaterial || t4.isMeshStandardMaterial || t4.isShadowMaterial || t4.isShaderMaterial && t4.lights === true;
    }(t3), i3.lightsStateVersion = a3, i3.needsLights && (u3.ambientLightColor.value = r3.state.ambient, u3.lightProbe.value = r3.state.probe, u3.directionalLights.value = r3.state.directional, u3.directionalLightShadows.value = r3.state.directionalShadow, u3.spotLights.value = r3.state.spot, u3.spotLightShadows.value = r3.state.spotShadow, u3.rectAreaLights.value = r3.state.rectArea, u3.ltc_1.value = r3.state.rectAreaLTC1, u3.ltc_2.value = r3.state.rectAreaLTC2, u3.pointLights.value = r3.state.point, u3.pointLightShadows.value = r3.state.pointShadow, u3.hemisphereLights.value = r3.state.hemi, u3.directionalShadowMap.value = r3.state.directionalShadowMap, u3.directionalShadowMatrix.value = r3.state.directionalShadowMatrix, u3.spotShadowMap.value = r3.state.spotShadowMap, u3.spotShadowMatrix.value = r3.state.spotShadowMatrix, u3.pointShadowMap.value = r3.state.pointShadowMap, u3.pointShadowMatrix.value = r3.state.pointShadowMatrix);
    const p3 = h3.getUniforms(), m3 = Wr.seqWithValue(p3.seq, u3);
    return i3.currentProgram = h3, i3.uniformsList = m3, h3;
  }
  function It2(t3, e3) {
    const n3 = q2.get(t3);
    n3.outputEncoding = e3.outputEncoding, n3.instancing = e3.instancing, n3.skinning = e3.skinning, n3.morphTargets = e3.morphTargets, n3.morphNormals = e3.morphNormals, n3.morphTargetsCount = e3.morphTargetsCount, n3.numClippingPlanes = e3.numClippingPlanes, n3.numIntersection = e3.numClipIntersection, n3.vertexAlphas = e3.vertexAlphas, n3.vertexTangents = e3.vertexTangents, n3.toneMapping = e3.toneMapping;
  }
  _t2.setAnimationLoop(function(t3) {
    xt2 && xt2(t3);
  }), typeof window != "undefined" && _t2.setContext(window), this.setAnimationLoop = function(t3) {
    xt2 = t3, mt2.setAnimationLoop(t3), t3 === null ? _t2.stop() : _t2.start();
  }, mt2.addEventListener("sessionstart", bt2), mt2.addEventListener("sessionend", wt2), this.render = function(t3, e3) {
    if (e3 !== void 0 && e3.isCamera !== true)
      return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    if (g2 === true)
      return;
    t3.autoUpdate === true && t3.updateMatrixWorld(), e3.parent === null && e3.updateMatrixWorld(), mt2.enabled === true && mt2.isPresenting === true && (mt2.cameraAutoUpdate === true && mt2.updateCamera(e3), e3 = mt2.getCamera()), t3.isScene === true && t3.onBeforeRender(f2, t3, e3, x2), d2 = nt2.get(t3, m2.length), d2.init(), m2.push(d2), k2.multiplyMatrices(e3.projectionMatrix, e3.matrixWorldInverse), N2.setFromProjectionMatrix(k2), O2 = this.localClippingEnabled, F2 = it2.init(this.clippingPlanes, O2, e3), u2 = et2.get(t3, p2.length), u2.init(), p2.push(u2), Et2(t3, e3, 0, f2.sortObjects), u2.finish(), f2.sortObjects === true && u2.sort(R2, L2), F2 === true && it2.beginShadows();
    const n3 = d2.state.shadowsArray;
    if (rt2.render(n3, t3, e3), F2 === true && it2.endShadows(), this.info.autoReset === true && this.info.reset(), st2.render(u2, t3), d2.setupLights(f2.physicallyCorrectLights), e3.isArrayCamera) {
      const n4 = e3.cameras;
      for (let e4 = 0, i3 = n4.length; e4 < i3; e4++) {
        const i4 = n4[e4];
        Rt2(u2, t3, i4, i4.viewport);
      }
    } else
      Rt2(u2, t3, e3);
    x2 !== null && (X2.updateMultisampleRenderTarget(x2), X2.updateRenderTargetMipmap(x2)), t3.isScene === true && t3.onAfterRender(f2, t3, e3), W2.buffers.depth.setTest(true), W2.buffers.depth.setMask(true), W2.buffers.color.setMask(true), W2.setPolygonOffset(false), ht2.resetDefaultState(), b2 = -1, w2 = null, m2.pop(), d2 = m2.length > 0 ? m2[m2.length - 1] : null, p2.pop(), u2 = p2.length > 0 ? p2[p2.length - 1] : null;
  }, this.getActiveCubeFace = function() {
    return v2;
  }, this.getActiveMipmapLevel = function() {
    return y2;
  }, this.getRenderTarget = function() {
    return x2;
  }, this.setRenderTargetTextures = function(t3, e3, n3) {
    q2.get(t3.texture).__webglTexture = e3, q2.get(t3.depthTexture).__webglTexture = n3;
    const i3 = q2.get(t3);
    i3.__hasExternalTextures = true, i3.__hasExternalTextures && (i3.__autoAllocateDepthBuffer = n3 === void 0, i3.__autoAllocateDepthBuffer || t3.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), t3.useRenderToTexture = false, t3.useRenderbuffer = true));
  }, this.setRenderTargetFramebuffer = function(t3, e3) {
    const n3 = q2.get(t3);
    n3.__webglFramebuffer = e3, n3.__useDefaultFramebuffer = e3 === void 0;
  }, this.setRenderTarget = function(t3, e3 = 0, n3 = 0) {
    x2 = t3, v2 = e3, y2 = n3;
    let i3 = true;
    if (t3) {
      const e4 = q2.get(t3);
      e4.__useDefaultFramebuffer !== void 0 ? (W2.bindFramebuffer(36160, null), i3 = false) : e4.__webglFramebuffer === void 0 ? X2.setupRenderTarget(t3) : e4.__hasExternalTextures && X2.rebindTextures(t3, q2.get(t3.texture).__webglTexture, q2.get(t3.depthTexture).__webglTexture);
    }
    let r3 = null, s3 = false, a3 = false;
    if (t3) {
      const n4 = t3.texture;
      (n4.isDataTexture3D || n4.isDataTexture2DArray) && (a3 = true);
      const i4 = q2.get(t3).__webglFramebuffer;
      t3.isWebGLCubeRenderTarget ? (r3 = i4[e3], s3 = true) : r3 = t3.useRenderbuffer ? q2.get(t3).__webglMultisampledFramebuffer : i4, _2.copy(t3.viewport), M2.copy(t3.scissor), S2 = t3.scissorTest;
    } else
      _2.copy(C2).multiplyScalar(A2).floor(), M2.copy(P2).multiplyScalar(A2).floor(), S2 = I2;
    if (W2.bindFramebuffer(36160, r3) && G2.drawBuffers && i3) {
      let e4 = false;
      if (t3)
        if (t3.isWebGLMultipleRenderTargets) {
          const n4 = t3.texture;
          if (D2.length !== n4.length || D2[0] !== 36064) {
            for (let t4 = 0, e5 = n4.length; t4 < e5; t4++)
              D2[t4] = 36064 + t4;
            D2.length = n4.length, e4 = true;
          }
        } else
          D2.length === 1 && D2[0] === 36064 || (D2[0] = 36064, D2.length = 1, e4 = true);
      else
        D2.length === 1 && D2[0] === 1029 || (D2[0] = 1029, D2.length = 1, e4 = true);
      e4 && (G2.isWebGL2 ? ut2.drawBuffers(D2) : V2.get("WEBGL_draw_buffers").drawBuffersWEBGL(D2));
    }
    if (W2.viewport(_2), W2.scissor(M2), W2.setScissorTest(S2), s3) {
      const i4 = q2.get(t3.texture);
      ut2.framebufferTexture2D(36160, 36064, 34069 + e3, i4.__webglTexture, n3);
    } else if (a3) {
      const i4 = q2.get(t3.texture), r4 = e3 || 0;
      ut2.framebufferTextureLayer(36160, 36064, i4.__webglTexture, n3 || 0, r4);
    }
    b2 = -1;
  }, this.readRenderTargetPixels = function(t3, e3, n3, i3, r3, s3, a3) {
    if (!t3 || !t3.isWebGLRenderTarget)
      return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
    let o3 = q2.get(t3).__webglFramebuffer;
    if (t3.isWebGLCubeRenderTarget && a3 !== void 0 && (o3 = o3[a3]), o3) {
      W2.bindFramebuffer(36160, o3);
      try {
        const a4 = t3.texture, o4 = a4.format, l3 = a4.type;
        if (o4 !== 1023 && ct2.convert(o4) !== ut2.getParameter(35739))
          return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
        const c3 = l3 === 1016 && (V2.has("EXT_color_buffer_half_float") || G2.isWebGL2 && V2.has("EXT_color_buffer_float"));
        if (!(l3 === 1009 || ct2.convert(l3) === ut2.getParameter(35738) || l3 === 1015 && (G2.isWebGL2 || V2.has("OES_texture_float") || V2.has("WEBGL_color_buffer_float")) || c3))
          return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
        ut2.checkFramebufferStatus(36160) === 36053 ? e3 >= 0 && e3 <= t3.width - i3 && n3 >= 0 && n3 <= t3.height - r3 && ut2.readPixels(e3, n3, i3, r3, ct2.convert(o4), ct2.convert(l3), s3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        const t4 = x2 !== null ? q2.get(x2).__webglFramebuffer : null;
        W2.bindFramebuffer(36160, t4);
      }
    }
  }, this.copyFramebufferToTexture = function(t3, e3, n3 = 0) {
    if (e3.isFramebufferTexture !== true)
      return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
    const i3 = Math.pow(2, -n3), r3 = Math.floor(e3.image.width * i3), s3 = Math.floor(e3.image.height * i3);
    X2.setTexture2D(e3, 0), ut2.copyTexSubImage2D(3553, n3, 0, 0, t3.x, t3.y, r3, s3), W2.unbindTexture();
  }, this.copyTextureToTexture = function(t3, e3, n3, i3 = 0) {
    const r3 = e3.image.width, s3 = e3.image.height, a3 = ct2.convert(n3.format), o3 = ct2.convert(n3.type);
    X2.setTexture2D(n3, 0), ut2.pixelStorei(37440, n3.flipY), ut2.pixelStorei(37441, n3.premultiplyAlpha), ut2.pixelStorei(3317, n3.unpackAlignment), e3.isDataTexture ? ut2.texSubImage2D(3553, i3, t3.x, t3.y, r3, s3, a3, o3, e3.image.data) : e3.isCompressedTexture ? ut2.compressedTexSubImage2D(3553, i3, t3.x, t3.y, e3.mipmaps[0].width, e3.mipmaps[0].height, a3, e3.mipmaps[0].data) : ut2.texSubImage2D(3553, i3, t3.x, t3.y, a3, o3, e3.image), i3 === 0 && n3.generateMipmaps && ut2.generateMipmap(3553), W2.unbindTexture();
  }, this.copyTextureToTexture3D = function(t3, e3, n3, i3, r3 = 0) {
    if (f2.isWebGL1Renderer)
      return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
    const s3 = t3.max.x - t3.min.x + 1, a3 = t3.max.y - t3.min.y + 1, o3 = t3.max.z - t3.min.z + 1, l3 = ct2.convert(i3.format), c3 = ct2.convert(i3.type);
    let h3;
    if (i3.isDataTexture3D)
      X2.setTexture3D(i3, 0), h3 = 32879;
    else {
      if (!i3.isDataTexture2DArray)
        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      X2.setTexture2DArray(i3, 0), h3 = 35866;
    }
    ut2.pixelStorei(37440, i3.flipY), ut2.pixelStorei(37441, i3.premultiplyAlpha), ut2.pixelStorei(3317, i3.unpackAlignment);
    const u3 = ut2.getParameter(3314), d3 = ut2.getParameter(32878), p3 = ut2.getParameter(3316), m3 = ut2.getParameter(3315), g3 = ut2.getParameter(32877), v3 = n3.isCompressedTexture ? n3.mipmaps[0] : n3.image;
    ut2.pixelStorei(3314, v3.width), ut2.pixelStorei(32878, v3.height), ut2.pixelStorei(3316, t3.min.x), ut2.pixelStorei(3315, t3.min.y), ut2.pixelStorei(32877, t3.min.z), n3.isDataTexture || n3.isDataTexture3D ? ut2.texSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, a3, o3, l3, c3, v3.data) : n3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ut2.compressedTexSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, a3, o3, l3, v3.data)) : ut2.texSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, a3, o3, l3, c3, v3), ut2.pixelStorei(3314, u3), ut2.pixelStorei(32878, d3), ut2.pixelStorei(3316, p3), ut2.pixelStorei(3315, m3), ut2.pixelStorei(32877, g3), r3 === 0 && i3.generateMipmaps && ut2.generateMipmap(h3), W2.unbindTexture();
  }, this.initTexture = function(t3) {
    X2.setTexture2D(t3, 0), W2.unbindTexture();
  }, this.resetState = function() {
    v2 = 0, y2 = 0, x2 = null, W2.reset(), ht2.reset();
  }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
zs.prototype.isWebGLRenderer = true;
(class extends zs {
}).prototype.isWebGL1Renderer = true;
class Bs extends Le {
  constructor() {
    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t2, e2) {
    return super.copy(t2, e2), t2.background !== null && (this.background = t2.background.clone()), t2.environment !== null && (this.environment = t2.environment.clone()), t2.fog !== null && (this.fog = t2.fog.clone()), t2.overrideMaterial !== null && (this.overrideMaterial = t2.overrideMaterial.clone()), this.autoUpdate = t2.autoUpdate, this.matrixAutoUpdate = t2.matrixAutoUpdate, this;
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    return this.fog !== null && (e2.object.fog = this.fog.toJSON()), e2;
  }
}
Bs.prototype.isScene = true;
class Hs {
  constructor(t2, e2) {
    this.array = t2, this.stride = e2, this.count = t2 !== void 0 ? t2.length / e2 : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = at();
  }
  onUploadCallback() {
  }
  set needsUpdate(t2) {
    t2 === true && this.version++;
  }
  setUsage(t2) {
    return this.usage = t2, this;
  }
  copy(t2) {
    return this.array = new t2.array.constructor(t2.array), this.count = t2.count, this.stride = t2.stride, this.usage = t2.usage, this;
  }
  copyAt(t2, e2, n2) {
    t2 *= this.stride, n2 *= e2.stride;
    for (let i2 = 0, r2 = this.stride; i2 < r2; i2++)
      this.array[t2 + i2] = e2.array[n2 + i2];
    return this;
  }
  set(t2, e2 = 0) {
    return this.array.set(t2, e2), this;
  }
  clone(t2) {
    t2.arrayBuffers === void 0 && (t2.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = at()), t2.arrayBuffers[this.array.buffer._uuid] === void 0 && (t2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e2 = new this.array.constructor(t2.arrayBuffers[this.array.buffer._uuid]), n2 = new this.constructor(e2, this.stride);
    return n2.setUsage(this.usage), n2;
  }
  onUpload(t2) {
    return this.onUploadCallback = t2, this;
  }
  toJSON(t2) {
    return t2.arrayBuffers === void 0 && (t2.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = at()), t2.arrayBuffers[this.array.buffer._uuid] === void 0 && (t2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
}
Hs.prototype.isInterleavedBuffer = true;
const Vs = new At();
class Gs {
  constructor(t2, e2, n2, i2 = false) {
    this.name = "", this.data = t2, this.itemSize = e2, this.offset = n2, this.normalized = i2 === true;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(t2) {
    this.data.needsUpdate = t2;
  }
  applyMatrix4(t2) {
    for (let e2 = 0, n2 = this.data.count; e2 < n2; e2++)
      Vs.x = this.getX(e2), Vs.y = this.getY(e2), Vs.z = this.getZ(e2), Vs.applyMatrix4(t2), this.setXYZ(e2, Vs.x, Vs.y, Vs.z);
    return this;
  }
  applyNormalMatrix(t2) {
    for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
      Vs.x = this.getX(e2), Vs.y = this.getY(e2), Vs.z = this.getZ(e2), Vs.applyNormalMatrix(t2), this.setXYZ(e2, Vs.x, Vs.y, Vs.z);
    return this;
  }
  transformDirection(t2) {
    for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
      Vs.x = this.getX(e2), Vs.y = this.getY(e2), Vs.z = this.getZ(e2), Vs.transformDirection(t2), this.setXYZ(e2, Vs.x, Vs.y, Vs.z);
    return this;
  }
  setX(t2, e2) {
    return this.data.array[t2 * this.data.stride + this.offset] = e2, this;
  }
  setY(t2, e2) {
    return this.data.array[t2 * this.data.stride + this.offset + 1] = e2, this;
  }
  setZ(t2, e2) {
    return this.data.array[t2 * this.data.stride + this.offset + 2] = e2, this;
  }
  setW(t2, e2) {
    return this.data.array[t2 * this.data.stride + this.offset + 3] = e2, this;
  }
  getX(t2) {
    return this.data.array[t2 * this.data.stride + this.offset];
  }
  getY(t2) {
    return this.data.array[t2 * this.data.stride + this.offset + 1];
  }
  getZ(t2) {
    return this.data.array[t2 * this.data.stride + this.offset + 2];
  }
  getW(t2) {
    return this.data.array[t2 * this.data.stride + this.offset + 3];
  }
  setXY(t2, e2, n2) {
    return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this;
  }
  setXYZ(t2, e2, n2, i2) {
    return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this.data.array[t2 + 2] = i2, this;
  }
  setXYZW(t2, e2, n2, i2, r2) {
    return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this.data.array[t2 + 2] = i2, this.data.array[t2 + 3] = r2, this;
  }
  clone(t2) {
    if (t2 === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const t3 = [];
      for (let e2 = 0; e2 < this.count; e2++) {
        const n2 = e2 * this.data.stride + this.offset;
        for (let e3 = 0; e3 < this.itemSize; e3++)
          t3.push(this.data.array[n2 + e3]);
      }
      return new Qe(new this.array.constructor(t3), this.itemSize, this.normalized);
    }
    return t2.interleavedBuffers === void 0 && (t2.interleavedBuffers = {}), t2.interleavedBuffers[this.data.uuid] === void 0 && (t2.interleavedBuffers[this.data.uuid] = this.data.clone(t2)), new Gs(t2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(t2) {
    if (t2 === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const t3 = [];
      for (let e2 = 0; e2 < this.count; e2++) {
        const n2 = e2 * this.data.stride + this.offset;
        for (let e3 = 0; e3 < this.itemSize; e3++)
          t3.push(this.data.array[n2 + e3]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: t3, normalized: this.normalized };
    }
    return t2.interleavedBuffers === void 0 && (t2.interleavedBuffers = {}), t2.interleavedBuffers[this.data.uuid] === void 0 && (t2.interleavedBuffers[this.data.uuid] = this.data.toJSON(t2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
}
Gs.prototype.isInterleavedBufferAttribute = true;
class Ws extends Ve {
  constructor(t2) {
    super(), this.type = "SpriteMaterial", this.color = new Ze(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.rotation = t2.rotation, this.sizeAttenuation = t2.sizeAttenuation, this;
  }
}
let js;
Ws.prototype.isSpriteMaterial = true;
const qs = new At(), Xs = new At(), Ys = new At(), Zs = new mt(), Js = new mt(), $s = new re(), Ks = new At(), Qs = new At(), ta = new At(), ea = new mt(), na = new mt(), ia = new mt();
function ra(t2, e2, n2, i2, r2, s2) {
  Zs.subVectors(t2, n2).addScalar(0.5).multiply(i2), r2 !== void 0 ? (Js.x = s2 * Zs.x - r2 * Zs.y, Js.y = r2 * Zs.x + s2 * Zs.y) : Js.copy(Zs), t2.copy(e2), t2.x += Js.x, t2.y += Js.y, t2.applyMatrix4($s);
}
(class extends Le {
  constructor(t2) {
    if (super(), this.type = "Sprite", js === void 0) {
      js = new un();
      const t3 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e2 = new Hs(t3, 5);
      js.setIndex([0, 1, 2, 0, 2, 3]), js.setAttribute("position", new Gs(e2, 3, 0, false)), js.setAttribute("uv", new Gs(e2, 2, 3, false));
    }
    this.geometry = js, this.material = t2 !== void 0 ? t2 : new Ws(), this.center = new mt(0.5, 0.5);
  }
  raycast(t2, e2) {
    t2.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Xs.setFromMatrixScale(this.matrixWorld), $s.copy(t2.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t2.camera.matrixWorldInverse, this.matrixWorld), Ys.setFromMatrixPosition(this.modelViewMatrix), t2.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && Xs.multiplyScalar(-Ys.z);
    const n2 = this.material.rotation;
    let i2, r2;
    n2 !== 0 && (r2 = Math.cos(n2), i2 = Math.sin(n2));
    const s2 = this.center;
    ra(Ks.set(-0.5, -0.5, 0), Ys, s2, Xs, i2, r2), ra(Qs.set(0.5, -0.5, 0), Ys, s2, Xs, i2, r2), ra(ta.set(0.5, 0.5, 0), Ys, s2, Xs, i2, r2), ea.set(0, 0), na.set(1, 0), ia.set(1, 1);
    let a2 = t2.ray.intersectTriangle(Ks, Qs, ta, false, qs);
    if (a2 === null && (ra(Qs.set(-0.5, 0.5, 0), Ys, s2, Xs, i2, r2), na.set(0, 1), a2 = t2.ray.intersectTriangle(Ks, ta, Qs, false, qs), a2 === null))
      return;
    const o2 = t2.ray.origin.distanceTo(qs);
    o2 < t2.near || o2 > t2.far || e2.push({ distance: o2, point: qs.clone(), uv: Be.getUV(qs, Ks, Qs, ta, ea, na, ia, new mt()), face: null, object: this });
  }
  copy(t2) {
    return super.copy(t2), t2.center !== void 0 && this.center.copy(t2.center), this.material = t2.material, this;
  }
}).prototype.isSprite = true;
const sa = new At(), aa = new Mt(), oa = new Mt(), la = new At(), ca = new re();
class ha extends Ln {
  constructor(t2, e2) {
    super(t2, e2), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new re(), this.bindMatrixInverse = new re();
  }
  copy(t2) {
    return super.copy(t2), this.bindMode = t2.bindMode, this.bindMatrix.copy(t2.bindMatrix), this.bindMatrixInverse.copy(t2.bindMatrixInverse), this.skeleton = t2.skeleton, this;
  }
  bind(t2, e2) {
    this.skeleton = t2, e2 === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e2 = this.matrixWorld), this.bindMatrix.copy(e2), this.bindMatrixInverse.copy(e2).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const t2 = new Mt(), e2 = this.geometry.attributes.skinWeight;
    for (let n2 = 0, i2 = e2.count; n2 < i2; n2++) {
      t2.x = e2.getX(n2), t2.y = e2.getY(n2), t2.z = e2.getZ(n2), t2.w = e2.getW(n2);
      const i3 = 1 / t2.manhattanLength();
      i3 !== 1 / 0 ? t2.multiplyScalar(i3) : t2.set(1, 0, 0, 0), e2.setXYZW(n2, t2.x, t2.y, t2.z, t2.w);
    }
  }
  updateMatrixWorld(t2) {
    super.updateMatrixWorld(t2), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(t2, e2) {
    const n2 = this.skeleton, i2 = this.geometry;
    aa.fromBufferAttribute(i2.attributes.skinIndex, t2), oa.fromBufferAttribute(i2.attributes.skinWeight, t2), sa.copy(e2).applyMatrix4(this.bindMatrix), e2.set(0, 0, 0);
    for (let t3 = 0; t3 < 4; t3++) {
      const i3 = oa.getComponent(t3);
      if (i3 !== 0) {
        const r2 = aa.getComponent(t3);
        ca.multiplyMatrices(n2.bones[r2].matrixWorld, n2.boneInverses[r2]), e2.addScaledVector(la.copy(sa).applyMatrix4(ca), i3);
      }
    }
    return e2.applyMatrix4(this.bindMatrixInverse);
  }
}
ha.prototype.isSkinnedMesh = true;
class ua extends Le {
  constructor() {
    super(), this.type = "Bone";
  }
}
ua.prototype.isBone = true;
class da extends wt {
  constructor(t2 = null, e2 = 1, n2 = 1, i2, r2, s2, a2, o2, l2 = 1003, c2 = 1003, h2, u2) {
    super(null, s2, a2, o2, l2, c2, i2, r2, h2, u2), this.image = { data: t2, width: e2, height: n2 }, this.magFilter = l2, this.minFilter = c2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
da.prototype.isDataTexture = true;
const pa = new re(), ma = new re();
class fa {
  constructor(t2 = [], e2 = []) {
    this.uuid = at(), this.bones = t2.slice(0), this.boneInverses = e2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const t2 = this.bones, e2 = this.boneInverses;
    if (this.boneMatrices = new Float32Array(16 * t2.length), e2.length === 0)
      this.calculateInverses();
    else if (t2.length !== e2.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let t3 = 0, e3 = this.bones.length; t3 < e3; t3++)
        this.boneInverses.push(new re());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
      const e3 = new re();
      this.bones[t2] && e3.copy(this.bones[t2].matrixWorld).invert(), this.boneInverses.push(e3);
    }
  }
  pose() {
    for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
      const e3 = this.bones[t2];
      e3 && e3.matrixWorld.copy(this.boneInverses[t2]).invert();
    }
    for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
      const e3 = this.bones[t2];
      e3 && (e3.parent && e3.parent.isBone ? (e3.matrix.copy(e3.parent.matrixWorld).invert(), e3.matrix.multiply(e3.matrixWorld)) : e3.matrix.copy(e3.matrixWorld), e3.matrix.decompose(e3.position, e3.quaternion, e3.scale));
    }
  }
  update() {
    const t2 = this.bones, e2 = this.boneInverses, n2 = this.boneMatrices, i2 = this.boneTexture;
    for (let i3 = 0, r2 = t2.length; i3 < r2; i3++) {
      const r3 = t2[i3] ? t2[i3].matrixWorld : ma;
      pa.multiplyMatrices(r3, e2[i3]), pa.toArray(n2, 16 * i3);
    }
    i2 !== null && (i2.needsUpdate = true);
  }
  clone() {
    return new fa(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let t2 = Math.sqrt(4 * this.bones.length);
    t2 = ut(t2), t2 = Math.max(t2, 4);
    const e2 = new Float32Array(t2 * t2 * 4);
    e2.set(this.boneMatrices);
    const n2 = new da(e2, t2, t2, 1023, 1015);
    return n2.needsUpdate = true, this.boneMatrices = e2, this.boneTexture = n2, this.boneTextureSize = t2, this;
  }
  getBoneByName(t2) {
    for (let e2 = 0, n2 = this.bones.length; e2 < n2; e2++) {
      const n3 = this.bones[e2];
      if (n3.name === t2)
        return n3;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(t2, e2) {
    this.uuid = t2.uuid;
    for (let n2 = 0, i2 = t2.bones.length; n2 < i2; n2++) {
      const i3 = t2.bones[n2];
      let r2 = e2[i3];
      r2 === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", i3), r2 = new ua()), this.bones.push(r2), this.boneInverses.push(new re().fromArray(t2.boneInverses[n2]));
    }
    return this.init(), this;
  }
  toJSON() {
    const t2 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    t2.uuid = this.uuid;
    const e2 = this.bones, n2 = this.boneInverses;
    for (let i2 = 0, r2 = e2.length; i2 < r2; i2++) {
      const r3 = e2[i2];
      t2.bones.push(r3.uuid);
      const s2 = n2[i2];
      t2.boneInverses.push(s2.toArray());
    }
    return t2;
  }
}
class ga extends Qe {
  constructor(t2, e2, n2, i2 = 1) {
    typeof n2 == "number" && (i2 = n2, n2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t2, e2, n2), this.meshPerAttribute = i2;
  }
  copy(t2) {
    return super.copy(t2), this.meshPerAttribute = t2.meshPerAttribute, this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.meshPerAttribute = this.meshPerAttribute, t2.isInstancedBufferAttribute = true, t2;
  }
}
ga.prototype.isInstancedBufferAttribute = true;
const va = new re(), ya = new re(), xa = [], ba = new Ln();
(class extends Ln {
  constructor(t2, e2, n2) {
    super(t2, e2), this.instanceMatrix = new ga(new Float32Array(16 * n2), 16), this.instanceColor = null, this.count = n2, this.frustumCulled = false;
  }
  copy(t2) {
    return super.copy(t2), this.instanceMatrix.copy(t2.instanceMatrix), t2.instanceColor !== null && (this.instanceColor = t2.instanceColor.clone()), this.count = t2.count, this;
  }
  getColorAt(t2, e2) {
    e2.fromArray(this.instanceColor.array, 3 * t2);
  }
  getMatrixAt(t2, e2) {
    e2.fromArray(this.instanceMatrix.array, 16 * t2);
  }
  raycast(t2, e2) {
    const n2 = this.matrixWorld, i2 = this.count;
    if (ba.geometry = this.geometry, ba.material = this.material, ba.material !== void 0)
      for (let r2 = 0; r2 < i2; r2++) {
        this.getMatrixAt(r2, va), ya.multiplyMatrices(n2, va), ba.matrixWorld = ya, ba.raycast(t2, xa);
        for (let t3 = 0, n3 = xa.length; t3 < n3; t3++) {
          const n4 = xa[t3];
          n4.instanceId = r2, n4.object = this, e2.push(n4);
        }
        xa.length = 0;
      }
  }
  setColorAt(t2, e2) {
    this.instanceColor === null && (this.instanceColor = new ga(new Float32Array(3 * this.instanceMatrix.count), 3)), e2.toArray(this.instanceColor.array, 3 * t2);
  }
  setMatrixAt(t2, e2) {
    e2.toArray(this.instanceMatrix.array, 16 * t2);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}).prototype.isInstancedMesh = true;
class wa extends Ve {
  constructor(t2) {
    super(), this.type = "LineBasicMaterial", this.color = new Ze(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this.linewidth = t2.linewidth, this.linecap = t2.linecap, this.linejoin = t2.linejoin, this;
  }
}
wa.prototype.isLineBasicMaterial = true;
const _a = new At(), Ma = new At(), Sa = new re(), Ta = new ie(), Ea = new Zt();
class Aa extends Le {
  constructor(t2 = new un(), e2 = new wa()) {
    super(), this.type = "Line", this.geometry = t2, this.material = e2, this.updateMorphTargets();
  }
  copy(t2) {
    return super.copy(t2), this.material = t2.material, this.geometry = t2.geometry, this;
  }
  computeLineDistances() {
    const t2 = this.geometry;
    if (t2.isBufferGeometry)
      if (t2.index === null) {
        const e2 = t2.attributes.position, n2 = [0];
        for (let t3 = 1, i2 = e2.count; t3 < i2; t3++)
          _a.fromBufferAttribute(e2, t3 - 1), Ma.fromBufferAttribute(e2, t3), n2[t3] = n2[t3 - 1], n2[t3] += _a.distanceTo(Ma);
        t2.setAttribute("lineDistance", new nn(n2, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else
      t2.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    return this;
  }
  raycast(t2, e2) {
    const n2 = this.geometry, i2 = this.matrixWorld, r2 = t2.params.Line.threshold, s2 = n2.drawRange;
    if (n2.boundingSphere === null && n2.computeBoundingSphere(), Ea.copy(n2.boundingSphere), Ea.applyMatrix4(i2), Ea.radius += r2, t2.ray.intersectsSphere(Ea) === false)
      return;
    Sa.copy(i2).invert(), Ta.copy(t2.ray).applyMatrix4(Sa);
    const a2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o2 = a2 * a2, l2 = new At(), c2 = new At(), h2 = new At(), u2 = new At(), d2 = this.isLineSegments ? 2 : 1;
    if (n2.isBufferGeometry) {
      const i3 = n2.index, r3 = n2.attributes.position;
      if (i3 !== null) {
        for (let n3 = Math.max(0, s2.start), a3 = Math.min(i3.count, s2.start + s2.count) - 1; n3 < a3; n3 += d2) {
          const s3 = i3.getX(n3), a4 = i3.getX(n3 + 1);
          l2.fromBufferAttribute(r3, s3), c2.fromBufferAttribute(r3, a4);
          if (Ta.distanceSqToSegment(l2, c2, u2, h2) > o2)
            continue;
          u2.applyMatrix4(this.matrixWorld);
          const d3 = t2.ray.origin.distanceTo(u2);
          d3 < t2.near || d3 > t2.far || e2.push({ distance: d3, point: h2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
        }
      } else {
        for (let n3 = Math.max(0, s2.start), i4 = Math.min(r3.count, s2.start + s2.count) - 1; n3 < i4; n3 += d2) {
          l2.fromBufferAttribute(r3, n3), c2.fromBufferAttribute(r3, n3 + 1);
          if (Ta.distanceSqToSegment(l2, c2, u2, h2) > o2)
            continue;
          u2.applyMatrix4(this.matrixWorld);
          const i5 = t2.ray.origin.distanceTo(u2);
          i5 < t2.near || i5 > t2.far || e2.push({ distance: i5, point: h2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
        }
      }
    } else
      n2.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  updateMorphTargets() {
    const t2 = this.geometry;
    if (t2.isBufferGeometry) {
      const e2 = t2.morphAttributes, n2 = Object.keys(e2);
      if (n2.length > 0) {
        const t3 = e2[n2[0]];
        if (t3 !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
            const n4 = t3[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
          }
        }
      }
    } else {
      const e2 = t2.morphTargets;
      e2 !== void 0 && e2.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Aa.prototype.isLine = true;
const Ra = new At(), La = new At();
class Ca extends Aa {
  constructor(t2, e2) {
    super(t2, e2), this.type = "LineSegments";
  }
  computeLineDistances() {
    const t2 = this.geometry;
    if (t2.isBufferGeometry)
      if (t2.index === null) {
        const e2 = t2.attributes.position, n2 = [];
        for (let t3 = 0, i2 = e2.count; t3 < i2; t3 += 2)
          Ra.fromBufferAttribute(e2, t3), La.fromBufferAttribute(e2, t3 + 1), n2[t3] = t3 === 0 ? 0 : n2[t3 - 1], n2[t3 + 1] = n2[t3] + Ra.distanceTo(La);
        t2.setAttribute("lineDistance", new nn(n2, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else
      t2.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    return this;
  }
}
Ca.prototype.isLineSegments = true;
class Pa extends Aa {
  constructor(t2, e2) {
    super(t2, e2), this.type = "LineLoop";
  }
}
Pa.prototype.isLineLoop = true;
class Ia extends Ve {
  constructor(t2) {
    super(), this.type = "PointsMaterial", this.color = new Ze(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.size = t2.size, this.sizeAttenuation = t2.sizeAttenuation, this;
  }
}
Ia.prototype.isPointsMaterial = true;
const Da = new re(), Na = new ie(), Fa = new Zt(), Oa = new At();
class Ua extends Le {
  constructor(t2 = new un(), e2 = new Ia()) {
    super(), this.type = "Points", this.geometry = t2, this.material = e2, this.updateMorphTargets();
  }
  copy(t2) {
    return super.copy(t2), this.material = t2.material, this.geometry = t2.geometry, this;
  }
  raycast(t2, e2) {
    const n2 = this.geometry, i2 = this.matrixWorld, r2 = t2.params.Points.threshold, s2 = n2.drawRange;
    if (n2.boundingSphere === null && n2.computeBoundingSphere(), Fa.copy(n2.boundingSphere), Fa.applyMatrix4(i2), Fa.radius += r2, t2.ray.intersectsSphere(Fa) === false)
      return;
    Da.copy(i2).invert(), Na.copy(t2.ray).applyMatrix4(Da);
    const a2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o2 = a2 * a2;
    if (n2.isBufferGeometry) {
      const r3 = n2.index, a3 = n2.attributes.position;
      if (r3 !== null) {
        for (let n3 = Math.max(0, s2.start), l2 = Math.min(r3.count, s2.start + s2.count); n3 < l2; n3++) {
          const s3 = r3.getX(n3);
          Oa.fromBufferAttribute(a3, s3), ka(Oa, s3, o2, i2, t2, e2, this);
        }
      } else {
        for (let n3 = Math.max(0, s2.start), r4 = Math.min(a3.count, s2.start + s2.count); n3 < r4; n3++)
          Oa.fromBufferAttribute(a3, n3), ka(Oa, n3, o2, i2, t2, e2, this);
      }
    } else
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  updateMorphTargets() {
    const t2 = this.geometry;
    if (t2.isBufferGeometry) {
      const e2 = t2.morphAttributes, n2 = Object.keys(e2);
      if (n2.length > 0) {
        const t3 = e2[n2[0]];
        if (t3 !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
            const n4 = t3[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
          }
        }
      }
    } else {
      const e2 = t2.morphTargets;
      e2 !== void 0 && e2.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
function ka(t2, e2, n2, i2, r2, s2, a2) {
  const o2 = Na.distanceSqToPoint(t2);
  if (o2 < n2) {
    const n3 = new At();
    Na.closestPointToPoint(t2, n3), n3.applyMatrix4(i2);
    const l2 = r2.ray.origin.distanceTo(n3);
    if (l2 < r2.near || l2 > r2.far)
      return;
    s2.push({ distance: l2, distanceToRay: Math.sqrt(o2), point: n3, index: e2, face: null, object: a2 });
  }
}
Ua.prototype.isPoints = true;
(class extends wt {
  constructor(t2, e2, n2, i2, r2, s2, a2, o2, l2) {
    super(t2, e2, n2, i2, r2, s2, a2, o2, l2), this.format = a2 !== void 0 ? a2 : 1022, this.minFilter = s2 !== void 0 ? s2 : 1006, this.magFilter = r2 !== void 0 ? r2 : 1006, this.generateMipmaps = false;
    const c2 = this;
    "requestVideoFrameCallback" in t2 && t2.requestVideoFrameCallback(function e3() {
      c2.needsUpdate = true, t2.requestVideoFrameCallback(e3);
    });
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const t2 = this.image;
    "requestVideoFrameCallback" in t2 === false && t2.readyState >= t2.HAVE_CURRENT_DATA && (this.needsUpdate = true);
  }
}).prototype.isVideoTexture = true;
(class extends wt {
  constructor(t2, e2, n2) {
    super({ width: t2, height: e2 }), this.format = n2, this.magFilter = 1003, this.minFilter = 1003, this.generateMipmaps = false, this.needsUpdate = true;
  }
}).prototype.isFramebufferTexture = true;
class za extends wt {
  constructor(t2, e2, n2, i2, r2, s2, a2, o2, l2, c2, h2, u2) {
    super(null, s2, a2, o2, l2, c2, i2, r2, h2, u2), this.image = { width: e2, height: n2 }, this.mipmaps = t2, this.flipY = false, this.generateMipmaps = false;
  }
}
za.prototype.isCompressedTexture = true;
(class extends wt {
  constructor(t2, e2, n2, i2, r2, s2, a2, o2, l2) {
    super(t2, e2, n2, i2, r2, s2, a2, o2, l2), this.needsUpdate = true;
  }
}).prototype.isCanvasTexture = true, new At(), new At(), new At(), new Be();
class Ba {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(t2, e2) {
    const n2 = this.getUtoTmapping(t2);
    return this.getPoint(n2, e2);
  }
  getPoints(t2 = 5) {
    const e2 = [];
    for (let n2 = 0; n2 <= t2; n2++)
      e2.push(this.getPoint(n2 / t2));
    return e2;
  }
  getSpacedPoints(t2 = 5) {
    const e2 = [];
    for (let n2 = 0; n2 <= t2; n2++)
      e2.push(this.getPointAt(n2 / t2));
    return e2;
  }
  getLength() {
    const t2 = this.getLengths();
    return t2[t2.length - 1];
  }
  getLengths(t2 = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === t2 + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = false;
    const e2 = [];
    let n2, i2 = this.getPoint(0), r2 = 0;
    e2.push(0);
    for (let s2 = 1; s2 <= t2; s2++)
      n2 = this.getPoint(s2 / t2), r2 += n2.distanceTo(i2), e2.push(r2), i2 = n2;
    return this.cacheArcLengths = e2, e2;
  }
  updateArcLengths() {
    this.needsUpdate = true, this.getLengths();
  }
  getUtoTmapping(t2, e2) {
    const n2 = this.getLengths();
    let i2 = 0;
    const r2 = n2.length;
    let s2;
    s2 = e2 || t2 * n2[r2 - 1];
    let a2, o2 = 0, l2 = r2 - 1;
    for (; o2 <= l2; )
      if (i2 = Math.floor(o2 + (l2 - o2) / 2), a2 = n2[i2] - s2, a2 < 0)
        o2 = i2 + 1;
      else {
        if (!(a2 > 0)) {
          l2 = i2;
          break;
        }
        l2 = i2 - 1;
      }
    if (i2 = l2, n2[i2] === s2)
      return i2 / (r2 - 1);
    const c2 = n2[i2];
    return (i2 + (s2 - c2) / (n2[i2 + 1] - c2)) / (r2 - 1);
  }
  getTangent(t2, e2) {
    const n2 = 1e-4;
    let i2 = t2 - n2, r2 = t2 + n2;
    i2 < 0 && (i2 = 0), r2 > 1 && (r2 = 1);
    const s2 = this.getPoint(i2), a2 = this.getPoint(r2), o2 = e2 || (s2.isVector2 ? new mt() : new At());
    return o2.copy(a2).sub(s2).normalize(), o2;
  }
  getTangentAt(t2, e2) {
    const n2 = this.getUtoTmapping(t2);
    return this.getTangent(n2, e2);
  }
  computeFrenetFrames(t2, e2) {
    const n2 = new At(), i2 = [], r2 = [], s2 = [], a2 = new At(), o2 = new re();
    for (let e3 = 0; e3 <= t2; e3++) {
      const n3 = e3 / t2;
      i2[e3] = this.getTangentAt(n3, new At());
    }
    r2[0] = new At(), s2[0] = new At();
    let l2 = Number.MAX_VALUE;
    const c2 = Math.abs(i2[0].x), h2 = Math.abs(i2[0].y), u2 = Math.abs(i2[0].z);
    c2 <= l2 && (l2 = c2, n2.set(1, 0, 0)), h2 <= l2 && (l2 = h2, n2.set(0, 1, 0)), u2 <= l2 && n2.set(0, 0, 1), a2.crossVectors(i2[0], n2).normalize(), r2[0].crossVectors(i2[0], a2), s2[0].crossVectors(i2[0], r2[0]);
    for (let e3 = 1; e3 <= t2; e3++) {
      if (r2[e3] = r2[e3 - 1].clone(), s2[e3] = s2[e3 - 1].clone(), a2.crossVectors(i2[e3 - 1], i2[e3]), a2.length() > Number.EPSILON) {
        a2.normalize();
        const t3 = Math.acos(ot(i2[e3 - 1].dot(i2[e3]), -1, 1));
        r2[e3].applyMatrix4(o2.makeRotationAxis(a2, t3));
      }
      s2[e3].crossVectors(i2[e3], r2[e3]);
    }
    if (e2 === true) {
      let e3 = Math.acos(ot(r2[0].dot(r2[t2]), -1, 1));
      e3 /= t2, i2[0].dot(a2.crossVectors(r2[0], r2[t2])) > 0 && (e3 = -e3);
      for (let n3 = 1; n3 <= t2; n3++)
        r2[n3].applyMatrix4(o2.makeRotationAxis(i2[n3], e3 * n3)), s2[n3].crossVectors(i2[n3], r2[n3]);
    }
    return { tangents: i2, normals: r2, binormals: s2 };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t2) {
    return this.arcLengthDivisions = t2.arcLengthDivisions, this;
  }
  toJSON() {
    const t2 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
    return t2.arcLengthDivisions = this.arcLengthDivisions, t2.type = this.type, t2;
  }
  fromJSON(t2) {
    return this.arcLengthDivisions = t2.arcLengthDivisions, this;
  }
}
class Ha extends Ba {
  constructor(t2 = 0, e2 = 0, n2 = 1, i2 = 1, r2 = 0, s2 = 2 * Math.PI, a2 = false, o2 = 0) {
    super(), this.type = "EllipseCurve", this.aX = t2, this.aY = e2, this.xRadius = n2, this.yRadius = i2, this.aStartAngle = r2, this.aEndAngle = s2, this.aClockwise = a2, this.aRotation = o2;
  }
  getPoint(t2, e2) {
    const n2 = e2 || new mt(), i2 = 2 * Math.PI;
    let r2 = this.aEndAngle - this.aStartAngle;
    const s2 = Math.abs(r2) < Number.EPSILON;
    for (; r2 < 0; )
      r2 += i2;
    for (; r2 > i2; )
      r2 -= i2;
    r2 < Number.EPSILON && (r2 = s2 ? 0 : i2), this.aClockwise !== true || s2 || (r2 === i2 ? r2 = -i2 : r2 -= i2);
    const a2 = this.aStartAngle + t2 * r2;
    let o2 = this.aX + this.xRadius * Math.cos(a2), l2 = this.aY + this.yRadius * Math.sin(a2);
    if (this.aRotation !== 0) {
      const t3 = Math.cos(this.aRotation), e3 = Math.sin(this.aRotation), n3 = o2 - this.aX, i3 = l2 - this.aY;
      o2 = n3 * t3 - i3 * e3 + this.aX, l2 = n3 * e3 + i3 * t3 + this.aY;
    }
    return n2.set(o2, l2);
  }
  copy(t2) {
    return super.copy(t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.aX = this.aX, t2.aY = this.aY, t2.xRadius = this.xRadius, t2.yRadius = this.yRadius, t2.aStartAngle = this.aStartAngle, t2.aEndAngle = this.aEndAngle, t2.aClockwise = this.aClockwise, t2.aRotation = this.aRotation, t2;
  }
  fromJSON(t2) {
    return super.fromJSON(t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
  }
}
Ha.prototype.isEllipseCurve = true;
class Va extends Ha {
  constructor(t2, e2, n2, i2, r2, s2) {
    super(t2, e2, n2, n2, i2, r2, s2), this.type = "ArcCurve";
  }
}
function Ga() {
  let t2 = 0, e2 = 0, n2 = 0, i2 = 0;
  function r2(r3, s2, a2, o2) {
    t2 = r3, e2 = a2, n2 = -3 * r3 + 3 * s2 - 2 * a2 - o2, i2 = 2 * r3 - 2 * s2 + a2 + o2;
  }
  return { initCatmullRom: function(t3, e3, n3, i3, s2) {
    r2(e3, n3, s2 * (n3 - t3), s2 * (i3 - e3));
  }, initNonuniformCatmullRom: function(t3, e3, n3, i3, s2, a2, o2) {
    let l2 = (e3 - t3) / s2 - (n3 - t3) / (s2 + a2) + (n3 - e3) / a2, c2 = (n3 - e3) / a2 - (i3 - e3) / (a2 + o2) + (i3 - n3) / o2;
    l2 *= a2, c2 *= a2, r2(e3, n3, l2, c2);
  }, calc: function(r3) {
    const s2 = r3 * r3;
    return t2 + e2 * r3 + n2 * s2 + i2 * (s2 * r3);
  } };
}
Va.prototype.isArcCurve = true;
const Wa = new At(), ja = new Ga(), qa = new Ga(), Xa = new Ga();
class Ya extends Ba {
  constructor(t2 = [], e2 = false, n2 = "centripetal", i2 = 0.5) {
    super(), this.type = "CatmullRomCurve3", this.points = t2, this.closed = e2, this.curveType = n2, this.tension = i2;
  }
  getPoint(t2, e2 = new At()) {
    const n2 = e2, i2 = this.points, r2 = i2.length, s2 = (r2 - (this.closed ? 0 : 1)) * t2;
    let a2, o2, l2 = Math.floor(s2), c2 = s2 - l2;
    this.closed ? l2 += l2 > 0 ? 0 : (Math.floor(Math.abs(l2) / r2) + 1) * r2 : c2 === 0 && l2 === r2 - 1 && (l2 = r2 - 2, c2 = 1), this.closed || l2 > 0 ? a2 = i2[(l2 - 1) % r2] : (Wa.subVectors(i2[0], i2[1]).add(i2[0]), a2 = Wa);
    const h2 = i2[l2 % r2], u2 = i2[(l2 + 1) % r2];
    if (this.closed || l2 + 2 < r2 ? o2 = i2[(l2 + 2) % r2] : (Wa.subVectors(i2[r2 - 1], i2[r2 - 2]).add(i2[r2 - 1]), o2 = Wa), this.curveType === "centripetal" || this.curveType === "chordal") {
      const t3 = this.curveType === "chordal" ? 0.5 : 0.25;
      let e3 = Math.pow(a2.distanceToSquared(h2), t3), n3 = Math.pow(h2.distanceToSquared(u2), t3), i3 = Math.pow(u2.distanceToSquared(o2), t3);
      n3 < 1e-4 && (n3 = 1), e3 < 1e-4 && (e3 = n3), i3 < 1e-4 && (i3 = n3), ja.initNonuniformCatmullRom(a2.x, h2.x, u2.x, o2.x, e3, n3, i3), qa.initNonuniformCatmullRom(a2.y, h2.y, u2.y, o2.y, e3, n3, i3), Xa.initNonuniformCatmullRom(a2.z, h2.z, u2.z, o2.z, e3, n3, i3);
    } else
      this.curveType === "catmullrom" && (ja.initCatmullRom(a2.x, h2.x, u2.x, o2.x, this.tension), qa.initCatmullRom(a2.y, h2.y, u2.y, o2.y, this.tension), Xa.initCatmullRom(a2.z, h2.z, u2.z, o2.z, this.tension));
    return n2.set(ja.calc(c2), qa.calc(c2), Xa.calc(c2)), n2;
  }
  copy(t2) {
    super.copy(t2), this.points = [];
    for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
      const n3 = t2.points[e2];
      this.points.push(n3.clone());
    }
    return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
  }
  toJSON() {
    const t2 = super.toJSON();
    t2.points = [];
    for (let e2 = 0, n2 = this.points.length; e2 < n2; e2++) {
      const n3 = this.points[e2];
      t2.points.push(n3.toArray());
    }
    return t2.closed = this.closed, t2.curveType = this.curveType, t2.tension = this.tension, t2;
  }
  fromJSON(t2) {
    super.fromJSON(t2), this.points = [];
    for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
      const n3 = t2.points[e2];
      this.points.push(new At().fromArray(n3));
    }
    return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
  }
}
function Za(t2, e2, n2, i2, r2) {
  const s2 = 0.5 * (i2 - e2), a2 = 0.5 * (r2 - n2), o2 = t2 * t2;
  return (2 * n2 - 2 * i2 + s2 + a2) * (t2 * o2) + (-3 * n2 + 3 * i2 - 2 * s2 - a2) * o2 + s2 * t2 + n2;
}
function Ja(t2, e2, n2, i2) {
  return function(t3, e3) {
    const n3 = 1 - t3;
    return n3 * n3 * e3;
  }(t2, e2) + function(t3, e3) {
    return 2 * (1 - t3) * t3 * e3;
  }(t2, n2) + function(t3, e3) {
    return t3 * t3 * e3;
  }(t2, i2);
}
function $a(t2, e2, n2, i2, r2) {
  return function(t3, e3) {
    const n3 = 1 - t3;
    return n3 * n3 * n3 * e3;
  }(t2, e2) + function(t3, e3) {
    const n3 = 1 - t3;
    return 3 * n3 * n3 * t3 * e3;
  }(t2, n2) + function(t3, e3) {
    return 3 * (1 - t3) * t3 * t3 * e3;
  }(t2, i2) + function(t3, e3) {
    return t3 * t3 * t3 * e3;
  }(t2, r2);
}
Ya.prototype.isCatmullRomCurve3 = true;
class Ka extends Ba {
  constructor(t2 = new mt(), e2 = new mt(), n2 = new mt(), i2 = new mt()) {
    super(), this.type = "CubicBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = n2, this.v3 = i2;
  }
  getPoint(t2, e2 = new mt()) {
    const n2 = e2, i2 = this.v0, r2 = this.v1, s2 = this.v2, a2 = this.v3;
    return n2.set($a(t2, i2.x, r2.x, s2.x, a2.x), $a(t2, i2.y, r2.y, s2.y, a2.y)), n2;
  }
  copy(t2) {
    return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
  }
  fromJSON(t2) {
    return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
  }
}
Ka.prototype.isCubicBezierCurve = true;
class Qa extends Ba {
  constructor(t2 = new At(), e2 = new At(), n2 = new At(), i2 = new At()) {
    super(), this.type = "CubicBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = n2, this.v3 = i2;
  }
  getPoint(t2, e2 = new At()) {
    const n2 = e2, i2 = this.v0, r2 = this.v1, s2 = this.v2, a2 = this.v3;
    return n2.set($a(t2, i2.x, r2.x, s2.x, a2.x), $a(t2, i2.y, r2.y, s2.y, a2.y), $a(t2, i2.z, r2.z, s2.z, a2.z)), n2;
  }
  copy(t2) {
    return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
  }
  fromJSON(t2) {
    return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
  }
}
Qa.prototype.isCubicBezierCurve3 = true;
class to extends Ba {
  constructor(t2 = new mt(), e2 = new mt()) {
    super(), this.type = "LineCurve", this.v1 = t2, this.v2 = e2;
  }
  getPoint(t2, e2 = new mt()) {
    const n2 = e2;
    return t2 === 1 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(t2).add(this.v1)), n2;
  }
  getPointAt(t2, e2) {
    return this.getPoint(t2, e2);
  }
  getTangent(t2, e2) {
    const n2 = e2 || new mt();
    return n2.copy(this.v2).sub(this.v1).normalize(), n2;
  }
  copy(t2) {
    return super.copy(t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
  }
  fromJSON(t2) {
    return super.fromJSON(t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
  }
}
to.prototype.isLineCurve = true;
class eo extends Ba {
  constructor(t2 = new mt(), e2 = new mt(), n2 = new mt()) {
    super(), this.type = "QuadraticBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = n2;
  }
  getPoint(t2, e2 = new mt()) {
    const n2 = e2, i2 = this.v0, r2 = this.v1, s2 = this.v2;
    return n2.set(Ja(t2, i2.x, r2.x, s2.x), Ja(t2, i2.y, r2.y, s2.y)), n2;
  }
  copy(t2) {
    return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
  }
  fromJSON(t2) {
    return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
  }
}
eo.prototype.isQuadraticBezierCurve = true;
class no extends Ba {
  constructor(t2 = new At(), e2 = new At(), n2 = new At()) {
    super(), this.type = "QuadraticBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = n2;
  }
  getPoint(t2, e2 = new At()) {
    const n2 = e2, i2 = this.v0, r2 = this.v1, s2 = this.v2;
    return n2.set(Ja(t2, i2.x, r2.x, s2.x), Ja(t2, i2.y, r2.y, s2.y), Ja(t2, i2.z, r2.z, s2.z)), n2;
  }
  copy(t2) {
    return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
  }
  fromJSON(t2) {
    return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
  }
}
no.prototype.isQuadraticBezierCurve3 = true;
class io extends Ba {
  constructor(t2 = []) {
    super(), this.type = "SplineCurve", this.points = t2;
  }
  getPoint(t2, e2 = new mt()) {
    const n2 = e2, i2 = this.points, r2 = (i2.length - 1) * t2, s2 = Math.floor(r2), a2 = r2 - s2, o2 = i2[s2 === 0 ? s2 : s2 - 1], l2 = i2[s2], c2 = i2[s2 > i2.length - 2 ? i2.length - 1 : s2 + 1], h2 = i2[s2 > i2.length - 3 ? i2.length - 1 : s2 + 2];
    return n2.set(Za(a2, o2.x, l2.x, c2.x, h2.x), Za(a2, o2.y, l2.y, c2.y, h2.y)), n2;
  }
  copy(t2) {
    super.copy(t2), this.points = [];
    for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
      const n3 = t2.points[e2];
      this.points.push(n3.clone());
    }
    return this;
  }
  toJSON() {
    const t2 = super.toJSON();
    t2.points = [];
    for (let e2 = 0, n2 = this.points.length; e2 < n2; e2++) {
      const n3 = this.points[e2];
      t2.points.push(n3.toArray());
    }
    return t2;
  }
  fromJSON(t2) {
    super.fromJSON(t2), this.points = [];
    for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
      const n3 = t2.points[e2];
      this.points.push(new mt().fromArray(n3));
    }
    return this;
  }
}
io.prototype.isSplineCurve = true;
var ro = Object.freeze({ __proto__: null, ArcCurve: Va, CatmullRomCurve3: Ya, CubicBezierCurve: Ka, CubicBezierCurve3: Qa, EllipseCurve: Ha, LineCurve: to, LineCurve3: class extends Ba {
  constructor(t2 = new At(), e2 = new At()) {
    super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t2, this.v2 = e2;
  }
  getPoint(t2, e2 = new At()) {
    const n2 = e2;
    return t2 === 1 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(t2).add(this.v1)), n2;
  }
  getPointAt(t2, e2) {
    return this.getPoint(t2, e2);
  }
  copy(t2) {
    return super.copy(t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
  }
  fromJSON(t2) {
    return super.fromJSON(t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
  }
}, QuadraticBezierCurve: eo, QuadraticBezierCurve3: no, SplineCurve: io });
class so extends Ba {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
  }
  add(t2) {
    this.curves.push(t2);
  }
  closePath() {
    const t2 = this.curves[0].getPoint(0), e2 = this.curves[this.curves.length - 1].getPoint(1);
    t2.equals(e2) || this.curves.push(new to(e2, t2));
  }
  getPoint(t2, e2) {
    const n2 = t2 * this.getLength(), i2 = this.getCurveLengths();
    let r2 = 0;
    for (; r2 < i2.length; ) {
      if (i2[r2] >= n2) {
        const t3 = i2[r2] - n2, s2 = this.curves[r2], a2 = s2.getLength(), o2 = a2 === 0 ? 0 : 1 - t3 / a2;
        return s2.getPointAt(o2, e2);
      }
      r2++;
    }
    return null;
  }
  getLength() {
    const t2 = this.getCurveLengths();
    return t2[t2.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t2 = [];
    let e2 = 0;
    for (let n2 = 0, i2 = this.curves.length; n2 < i2; n2++)
      e2 += this.curves[n2].getLength(), t2.push(e2);
    return this.cacheLengths = t2, t2;
  }
  getSpacedPoints(t2 = 40) {
    const e2 = [];
    for (let n2 = 0; n2 <= t2; n2++)
      e2.push(this.getPoint(n2 / t2));
    return this.autoClose && e2.push(e2[0]), e2;
  }
  getPoints(t2 = 12) {
    const e2 = [];
    let n2;
    for (let i2 = 0, r2 = this.curves; i2 < r2.length; i2++) {
      const s2 = r2[i2], a2 = s2 && s2.isEllipseCurve ? 2 * t2 : s2 && (s2.isLineCurve || s2.isLineCurve3) ? 1 : s2 && s2.isSplineCurve ? t2 * s2.points.length : t2, o2 = s2.getPoints(a2);
      for (let t3 = 0; t3 < o2.length; t3++) {
        const i3 = o2[t3];
        n2 && n2.equals(i3) || (e2.push(i3), n2 = i3);
      }
    }
    return this.autoClose && e2.length > 1 && !e2[e2.length - 1].equals(e2[0]) && e2.push(e2[0]), e2;
  }
  copy(t2) {
    super.copy(t2), this.curves = [];
    for (let e2 = 0, n2 = t2.curves.length; e2 < n2; e2++) {
      const n3 = t2.curves[e2];
      this.curves.push(n3.clone());
    }
    return this.autoClose = t2.autoClose, this;
  }
  toJSON() {
    const t2 = super.toJSON();
    t2.autoClose = this.autoClose, t2.curves = [];
    for (let e2 = 0, n2 = this.curves.length; e2 < n2; e2++) {
      const n3 = this.curves[e2];
      t2.curves.push(n3.toJSON());
    }
    return t2;
  }
  fromJSON(t2) {
    super.fromJSON(t2), this.autoClose = t2.autoClose, this.curves = [];
    for (let e2 = 0, n2 = t2.curves.length; e2 < n2; e2++) {
      const n3 = t2.curves[e2];
      this.curves.push(new ro[n3.type]().fromJSON(n3));
    }
    return this;
  }
}
class ao extends so {
  constructor(t2) {
    super(), this.type = "Path", this.currentPoint = new mt(), t2 && this.setFromPoints(t2);
  }
  setFromPoints(t2) {
    this.moveTo(t2[0].x, t2[0].y);
    for (let e2 = 1, n2 = t2.length; e2 < n2; e2++)
      this.lineTo(t2[e2].x, t2[e2].y);
    return this;
  }
  moveTo(t2, e2) {
    return this.currentPoint.set(t2, e2), this;
  }
  lineTo(t2, e2) {
    const n2 = new to(this.currentPoint.clone(), new mt(t2, e2));
    return this.curves.push(n2), this.currentPoint.set(t2, e2), this;
  }
  quadraticCurveTo(t2, e2, n2, i2) {
    const r2 = new eo(this.currentPoint.clone(), new mt(t2, e2), new mt(n2, i2));
    return this.curves.push(r2), this.currentPoint.set(n2, i2), this;
  }
  bezierCurveTo(t2, e2, n2, i2, r2, s2) {
    const a2 = new Ka(this.currentPoint.clone(), new mt(t2, e2), new mt(n2, i2), new mt(r2, s2));
    return this.curves.push(a2), this.currentPoint.set(r2, s2), this;
  }
  splineThru(t2) {
    const e2 = [this.currentPoint.clone()].concat(t2), n2 = new io(e2);
    return this.curves.push(n2), this.currentPoint.copy(t2[t2.length - 1]), this;
  }
  arc(t2, e2, n2, i2, r2, s2) {
    const a2 = this.currentPoint.x, o2 = this.currentPoint.y;
    return this.absarc(t2 + a2, e2 + o2, n2, i2, r2, s2), this;
  }
  absarc(t2, e2, n2, i2, r2, s2) {
    return this.absellipse(t2, e2, n2, n2, i2, r2, s2), this;
  }
  ellipse(t2, e2, n2, i2, r2, s2, a2, o2) {
    const l2 = this.currentPoint.x, c2 = this.currentPoint.y;
    return this.absellipse(t2 + l2, e2 + c2, n2, i2, r2, s2, a2, o2), this;
  }
  absellipse(t2, e2, n2, i2, r2, s2, a2, o2) {
    const l2 = new Ha(t2, e2, n2, i2, r2, s2, a2, o2);
    if (this.curves.length > 0) {
      const t3 = l2.getPoint(0);
      t3.equals(this.currentPoint) || this.lineTo(t3.x, t3.y);
    }
    this.curves.push(l2);
    const c2 = l2.getPoint(1);
    return this.currentPoint.copy(c2), this;
  }
  copy(t2) {
    return super.copy(t2), this.currentPoint.copy(t2.currentPoint), this;
  }
  toJSON() {
    const t2 = super.toJSON();
    return t2.currentPoint = this.currentPoint.toArray(), t2;
  }
  fromJSON(t2) {
    return super.fromJSON(t2), this.currentPoint.fromArray(t2.currentPoint), this;
  }
}
class oo extends ao {
  constructor(t2) {
    super(t2), this.uuid = at(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(t2) {
    const e2 = [];
    for (let n2 = 0, i2 = this.holes.length; n2 < i2; n2++)
      e2[n2] = this.holes[n2].getPoints(t2);
    return e2;
  }
  extractPoints(t2) {
    return { shape: this.getPoints(t2), holes: this.getPointsHoles(t2) };
  }
  copy(t2) {
    super.copy(t2), this.holes = [];
    for (let e2 = 0, n2 = t2.holes.length; e2 < n2; e2++) {
      const n3 = t2.holes[e2];
      this.holes.push(n3.clone());
    }
    return this;
  }
  toJSON() {
    const t2 = super.toJSON();
    t2.uuid = this.uuid, t2.holes = [];
    for (let e2 = 0, n2 = this.holes.length; e2 < n2; e2++) {
      const n3 = this.holes[e2];
      t2.holes.push(n3.toJSON());
    }
    return t2;
  }
  fromJSON(t2) {
    super.fromJSON(t2), this.uuid = t2.uuid, this.holes = [];
    for (let e2 = 0, n2 = t2.holes.length; e2 < n2; e2++) {
      const n3 = t2.holes[e2];
      this.holes.push(new ao().fromJSON(n3));
    }
    return this;
  }
}
const lo = function(t2, e2, n2 = 2) {
  const i2 = e2 && e2.length, r2 = i2 ? e2[0] * n2 : t2.length;
  let s2 = co(t2, 0, r2, n2, true);
  const a2 = [];
  if (!s2 || s2.next === s2.prev)
    return a2;
  let o2, l2, c2, h2, u2, d2, p2;
  if (i2 && (s2 = function(t3, e3, n3, i3) {
    const r3 = [];
    let s3, a3, o3, l3, c3;
    for (s3 = 0, a3 = e3.length; s3 < a3; s3++)
      o3 = e3[s3] * i3, l3 = s3 < a3 - 1 ? e3[s3 + 1] * i3 : t3.length, c3 = co(t3, o3, l3, i3, false), c3 === c3.next && (c3.steiner = true), r3.push(wo(c3));
    for (r3.sort(vo), s3 = 0; s3 < r3.length; s3++)
      yo(r3[s3], n3), n3 = ho(n3, n3.next);
    return n3;
  }(t2, e2, s2, n2)), t2.length > 80 * n2) {
    o2 = c2 = t2[0], l2 = h2 = t2[1];
    for (let e3 = n2; e3 < r2; e3 += n2)
      u2 = t2[e3], d2 = t2[e3 + 1], u2 < o2 && (o2 = u2), d2 < l2 && (l2 = d2), u2 > c2 && (c2 = u2), d2 > h2 && (h2 = d2);
    p2 = Math.max(c2 - o2, h2 - l2), p2 = p2 !== 0 ? 1 / p2 : 0;
  }
  return uo(s2, a2, n2, o2, l2, p2), a2;
};
function co(t2, e2, n2, i2, r2) {
  let s2, a2;
  if (r2 === function(t3, e3, n3, i3) {
    let r3 = 0;
    for (let s3 = e3, a3 = n3 - i3; s3 < n3; s3 += i3)
      r3 += (t3[a3] - t3[s3]) * (t3[s3 + 1] + t3[a3 + 1]), a3 = s3;
    return r3;
  }(t2, e2, n2, i2) > 0)
    for (s2 = e2; s2 < n2; s2 += i2)
      a2 = Po(s2, t2[s2], t2[s2 + 1], a2);
  else
    for (s2 = n2 - i2; s2 >= e2; s2 -= i2)
      a2 = Po(s2, t2[s2], t2[s2 + 1], a2);
  return a2 && To(a2, a2.next) && (Io(a2), a2 = a2.next), a2;
}
function ho(t2, e2) {
  if (!t2)
    return t2;
  e2 || (e2 = t2);
  let n2, i2 = t2;
  do {
    if (n2 = false, i2.steiner || !To(i2, i2.next) && So(i2.prev, i2, i2.next) !== 0)
      i2 = i2.next;
    else {
      if (Io(i2), i2 = e2 = i2.prev, i2 === i2.next)
        break;
      n2 = true;
    }
  } while (n2 || i2 !== e2);
  return e2;
}
function uo(t2, e2, n2, i2, r2, s2, a2) {
  if (!t2)
    return;
  !a2 && s2 && function(t3, e3, n3, i3) {
    let r3 = t3;
    do {
      r3.z === null && (r3.z = bo(r3.x, r3.y, e3, n3, i3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
    } while (r3 !== t3);
    r3.prevZ.nextZ = null, r3.prevZ = null, function(t4) {
      let e4, n4, i4, r4, s3, a3, o3, l3, c3 = 1;
      do {
        for (n4 = t4, t4 = null, s3 = null, a3 = 0; n4; ) {
          for (a3++, i4 = n4, o3 = 0, e4 = 0; e4 < c3 && (o3++, i4 = i4.nextZ, i4); e4++)
            ;
          for (l3 = c3; o3 > 0 || l3 > 0 && i4; )
            o3 !== 0 && (l3 === 0 || !i4 || n4.z <= i4.z) ? (r4 = n4, n4 = n4.nextZ, o3--) : (r4 = i4, i4 = i4.nextZ, l3--), s3 ? s3.nextZ = r4 : t4 = r4, r4.prevZ = s3, s3 = r4;
          n4 = i4;
        }
        s3.nextZ = null, c3 *= 2;
      } while (a3 > 1);
    }(r3);
  }(t2, i2, r2, s2);
  let o2, l2, c2 = t2;
  for (; t2.prev !== t2.next; )
    if (o2 = t2.prev, l2 = t2.next, s2 ? mo(t2, i2, r2, s2) : po(t2))
      e2.push(o2.i / n2), e2.push(t2.i / n2), e2.push(l2.i / n2), Io(t2), t2 = l2.next, c2 = l2.next;
    else if ((t2 = l2) === c2) {
      a2 ? a2 === 1 ? uo(t2 = fo(ho(t2), e2, n2), e2, n2, i2, r2, s2, 2) : a2 === 2 && go(t2, e2, n2, i2, r2, s2) : uo(ho(t2), e2, n2, i2, r2, s2, 1);
      break;
    }
}
function po(t2) {
  const e2 = t2.prev, n2 = t2, i2 = t2.next;
  if (So(e2, n2, i2) >= 0)
    return false;
  let r2 = t2.next.next;
  for (; r2 !== t2.prev; ) {
    if (_o(e2.x, e2.y, n2.x, n2.y, i2.x, i2.y, r2.x, r2.y) && So(r2.prev, r2, r2.next) >= 0)
      return false;
    r2 = r2.next;
  }
  return true;
}
function mo(t2, e2, n2, i2) {
  const r2 = t2.prev, s2 = t2, a2 = t2.next;
  if (So(r2, s2, a2) >= 0)
    return false;
  const o2 = r2.x < s2.x ? r2.x < a2.x ? r2.x : a2.x : s2.x < a2.x ? s2.x : a2.x, l2 = r2.y < s2.y ? r2.y < a2.y ? r2.y : a2.y : s2.y < a2.y ? s2.y : a2.y, c2 = r2.x > s2.x ? r2.x > a2.x ? r2.x : a2.x : s2.x > a2.x ? s2.x : a2.x, h2 = r2.y > s2.y ? r2.y > a2.y ? r2.y : a2.y : s2.y > a2.y ? s2.y : a2.y, u2 = bo(o2, l2, e2, n2, i2), d2 = bo(c2, h2, e2, n2, i2);
  let p2 = t2.prevZ, m2 = t2.nextZ;
  for (; p2 && p2.z >= u2 && m2 && m2.z <= d2; ) {
    if (p2 !== t2.prev && p2 !== t2.next && _o(r2.x, r2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && So(p2.prev, p2, p2.next) >= 0)
      return false;
    if (p2 = p2.prevZ, m2 !== t2.prev && m2 !== t2.next && _o(r2.x, r2.y, s2.x, s2.y, a2.x, a2.y, m2.x, m2.y) && So(m2.prev, m2, m2.next) >= 0)
      return false;
    m2 = m2.nextZ;
  }
  for (; p2 && p2.z >= u2; ) {
    if (p2 !== t2.prev && p2 !== t2.next && _o(r2.x, r2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && So(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  for (; m2 && m2.z <= d2; ) {
    if (m2 !== t2.prev && m2 !== t2.next && _o(r2.x, r2.y, s2.x, s2.y, a2.x, a2.y, m2.x, m2.y) && So(m2.prev, m2, m2.next) >= 0)
      return false;
    m2 = m2.nextZ;
  }
  return true;
}
function fo(t2, e2, n2) {
  let i2 = t2;
  do {
    const r2 = i2.prev, s2 = i2.next.next;
    !To(r2, s2) && Eo(r2, i2, i2.next, s2) && Lo(r2, s2) && Lo(s2, r2) && (e2.push(r2.i / n2), e2.push(i2.i / n2), e2.push(s2.i / n2), Io(i2), Io(i2.next), i2 = t2 = s2), i2 = i2.next;
  } while (i2 !== t2);
  return ho(i2);
}
function go(t2, e2, n2, i2, r2, s2) {
  let a2 = t2;
  do {
    let t3 = a2.next.next;
    for (; t3 !== a2.prev; ) {
      if (a2.i !== t3.i && Mo(a2, t3)) {
        let o2 = Co(a2, t3);
        return a2 = ho(a2, a2.next), o2 = ho(o2, o2.next), uo(a2, e2, n2, i2, r2, s2), void uo(o2, e2, n2, i2, r2, s2);
      }
      t3 = t3.next;
    }
    a2 = a2.next;
  } while (a2 !== t2);
}
function vo(t2, e2) {
  return t2.x - e2.x;
}
function yo(t2, e2) {
  if (e2 = function(t3, e3) {
    let n2 = e3;
    const i2 = t3.x, r2 = t3.y;
    let s2, a2 = -1 / 0;
    do {
      if (r2 <= n2.y && r2 >= n2.next.y && n2.next.y !== n2.y) {
        const t4 = n2.x + (r2 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
        if (t4 <= i2 && t4 > a2) {
          if (a2 = t4, t4 === i2) {
            if (r2 === n2.y)
              return n2;
            if (r2 === n2.next.y)
              return n2.next;
          }
          s2 = n2.x < n2.next.x ? n2 : n2.next;
        }
      }
      n2 = n2.next;
    } while (n2 !== e3);
    if (!s2)
      return null;
    if (i2 === a2)
      return s2;
    const o2 = s2, l2 = s2.x, c2 = s2.y;
    let h2, u2 = 1 / 0;
    n2 = s2;
    do {
      i2 >= n2.x && n2.x >= l2 && i2 !== n2.x && _o(r2 < c2 ? i2 : a2, r2, l2, c2, r2 < c2 ? a2 : i2, r2, n2.x, n2.y) && (h2 = Math.abs(r2 - n2.y) / (i2 - n2.x), Lo(n2, t3) && (h2 < u2 || h2 === u2 && (n2.x > s2.x || n2.x === s2.x && xo(s2, n2))) && (s2 = n2, u2 = h2)), n2 = n2.next;
    } while (n2 !== o2);
    return s2;
  }(t2, e2), e2) {
    const n2 = Co(e2, t2);
    ho(e2, e2.next), ho(n2, n2.next);
  }
}
function xo(t2, e2) {
  return So(t2.prev, t2, e2.prev) < 0 && So(e2.next, t2, t2.next) < 0;
}
function bo(t2, e2, n2, i2, r2) {
  return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - n2) * r2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - i2) * r2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
}
function wo(t2) {
  let e2 = t2, n2 = t2;
  do {
    (e2.x < n2.x || e2.x === n2.x && e2.y < n2.y) && (n2 = e2), e2 = e2.next;
  } while (e2 !== t2);
  return n2;
}
function _o(t2, e2, n2, i2, r2, s2, a2, o2) {
  return (r2 - a2) * (e2 - o2) - (t2 - a2) * (s2 - o2) >= 0 && (t2 - a2) * (i2 - o2) - (n2 - a2) * (e2 - o2) >= 0 && (n2 - a2) * (s2 - o2) - (r2 - a2) * (i2 - o2) >= 0;
}
function Mo(t2, e2) {
  return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
    let n2 = t3;
    do {
      if (n2.i !== t3.i && n2.next.i !== t3.i && n2.i !== e3.i && n2.next.i !== e3.i && Eo(n2, n2.next, t3, e3))
        return true;
      n2 = n2.next;
    } while (n2 !== t3);
    return false;
  }(t2, e2) && (Lo(t2, e2) && Lo(e2, t2) && function(t3, e3) {
    let n2 = t3, i2 = false;
    const r2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
    do {
      n2.y > s2 != n2.next.y > s2 && n2.next.y !== n2.y && r2 < (n2.next.x - n2.x) * (s2 - n2.y) / (n2.next.y - n2.y) + n2.x && (i2 = !i2), n2 = n2.next;
    } while (n2 !== t3);
    return i2;
  }(t2, e2) && (So(t2.prev, t2, e2.prev) || So(t2, e2.prev, e2)) || To(t2, e2) && So(t2.prev, t2, t2.next) > 0 && So(e2.prev, e2, e2.next) > 0);
}
function So(t2, e2, n2) {
  return (e2.y - t2.y) * (n2.x - e2.x) - (e2.x - t2.x) * (n2.y - e2.y);
}
function To(t2, e2) {
  return t2.x === e2.x && t2.y === e2.y;
}
function Eo(t2, e2, n2, i2) {
  const r2 = Ro(So(t2, e2, n2)), s2 = Ro(So(t2, e2, i2)), a2 = Ro(So(n2, i2, t2)), o2 = Ro(So(n2, i2, e2));
  return r2 !== s2 && a2 !== o2 || (!(r2 !== 0 || !Ao(t2, n2, e2)) || (!(s2 !== 0 || !Ao(t2, i2, e2)) || (!(a2 !== 0 || !Ao(n2, t2, i2)) || !(o2 !== 0 || !Ao(n2, e2, i2)))));
}
function Ao(t2, e2, n2) {
  return e2.x <= Math.max(t2.x, n2.x) && e2.x >= Math.min(t2.x, n2.x) && e2.y <= Math.max(t2.y, n2.y) && e2.y >= Math.min(t2.y, n2.y);
}
function Ro(t2) {
  return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
}
function Lo(t2, e2) {
  return So(t2.prev, t2, t2.next) < 0 ? So(t2, e2, t2.next) >= 0 && So(t2, t2.prev, e2) >= 0 : So(t2, e2, t2.prev) < 0 || So(t2, t2.next, e2) < 0;
}
function Co(t2, e2) {
  const n2 = new Do(t2.i, t2.x, t2.y), i2 = new Do(e2.i, e2.x, e2.y), r2 = t2.next, s2 = e2.prev;
  return t2.next = e2, e2.prev = t2, n2.next = r2, r2.prev = n2, i2.next = n2, n2.prev = i2, s2.next = i2, i2.prev = s2, i2;
}
function Po(t2, e2, n2, i2) {
  const r2 = new Do(t2, e2, n2);
  return i2 ? (r2.next = i2.next, r2.prev = i2, i2.next.prev = r2, i2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
}
function Io(t2) {
  t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
}
function Do(t2, e2, n2) {
  this.i = t2, this.x = e2, this.y = n2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
class No {
  static area(t2) {
    const e2 = t2.length;
    let n2 = 0;
    for (let i2 = e2 - 1, r2 = 0; r2 < e2; i2 = r2++)
      n2 += t2[i2].x * t2[r2].y - t2[r2].x * t2[i2].y;
    return 0.5 * n2;
  }
  static isClockWise(t2) {
    return No.area(t2) < 0;
  }
  static triangulateShape(t2, e2) {
    const n2 = [], i2 = [], r2 = [];
    Fo(t2), Oo(n2, t2);
    let s2 = t2.length;
    e2.forEach(Fo);
    for (let t3 = 0; t3 < e2.length; t3++)
      i2.push(s2), s2 += e2[t3].length, Oo(n2, e2[t3]);
    const a2 = lo(n2, i2);
    for (let t3 = 0; t3 < a2.length; t3 += 3)
      r2.push(a2.slice(t3, t3 + 3));
    return r2;
  }
}
function Fo(t2) {
  const e2 = t2.length;
  e2 > 2 && t2[e2 - 1].equals(t2[0]) && t2.pop();
}
function Oo(t2, e2) {
  for (let n2 = 0; n2 < e2.length; n2++)
    t2.push(e2[n2].x), t2.push(e2[n2].y);
}
class Uo extends un {
  constructor(t2 = new oo([new mt(0.5, 0.5), new mt(-0.5, 0.5), new mt(-0.5, -0.5), new mt(0.5, -0.5)]), e2 = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t2, options: e2 }, t2 = Array.isArray(t2) ? t2 : [t2];
    const n2 = this, i2 = [], r2 = [];
    for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
      s2(t2[e3]);
    }
    function s2(t3) {
      const s3 = [], a2 = e2.curveSegments !== void 0 ? e2.curveSegments : 12, o2 = e2.steps !== void 0 ? e2.steps : 1;
      let l2 = e2.depth !== void 0 ? e2.depth : 1, c2 = e2.bevelEnabled === void 0 || e2.bevelEnabled, h2 = e2.bevelThickness !== void 0 ? e2.bevelThickness : 0.2, u2 = e2.bevelSize !== void 0 ? e2.bevelSize : h2 - 0.1, d2 = e2.bevelOffset !== void 0 ? e2.bevelOffset : 0, p2 = e2.bevelSegments !== void 0 ? e2.bevelSegments : 3;
      const m2 = e2.extrudePath, f2 = e2.UVGenerator !== void 0 ? e2.UVGenerator : ko;
      e2.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l2 = e2.amount);
      let g2, v2, y2, x2, b2, w2 = false;
      m2 && (g2 = m2.getSpacedPoints(o2), w2 = true, c2 = false, v2 = m2.computeFrenetFrames(o2, false), y2 = new At(), x2 = new At(), b2 = new At()), c2 || (p2 = 0, h2 = 0, u2 = 0, d2 = 0);
      const _2 = t3.extractPoints(a2);
      let M2 = _2.shape;
      const S2 = _2.holes;
      if (!No.isClockWise(M2)) {
        M2 = M2.reverse();
        for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
          const e4 = S2[t4];
          No.isClockWise(e4) && (S2[t4] = e4.reverse());
        }
      }
      const T2 = No.triangulateShape(M2, S2), E2 = M2;
      for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
        const e4 = S2[t4];
        M2 = M2.concat(e4);
      }
      function A2(t4, e3, n3) {
        return e3 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e3.clone().multiplyScalar(n3).add(t4);
      }
      const R2 = M2.length, L2 = T2.length;
      function C2(t4, e3, n3) {
        let i3, r3, s4;
        const a3 = t4.x - e3.x, o3 = t4.y - e3.y, l3 = n3.x - t4.x, c3 = n3.y - t4.y, h3 = a3 * a3 + o3 * o3, u3 = a3 * c3 - o3 * l3;
        if (Math.abs(u3) > Number.EPSILON) {
          const u4 = Math.sqrt(h3), d3 = Math.sqrt(l3 * l3 + c3 * c3), p3 = e3.x - o3 / u4, m3 = e3.y + a3 / u4, f3 = ((n3.x - c3 / d3 - p3) * c3 - (n3.y + l3 / d3 - m3) * l3) / (a3 * c3 - o3 * l3);
          i3 = p3 + a3 * f3 - t4.x, r3 = m3 + o3 * f3 - t4.y;
          const g3 = i3 * i3 + r3 * r3;
          if (g3 <= 2)
            return new mt(i3, r3);
          s4 = Math.sqrt(g3 / 2);
        } else {
          let t5 = false;
          a3 > Number.EPSILON ? l3 > Number.EPSILON && (t5 = true) : a3 < -Number.EPSILON ? l3 < -Number.EPSILON && (t5 = true) : Math.sign(o3) === Math.sign(c3) && (t5 = true), t5 ? (i3 = -o3, r3 = a3, s4 = Math.sqrt(h3)) : (i3 = a3, r3 = o3, s4 = Math.sqrt(h3 / 2));
        }
        return new mt(i3 / s4, r3 / s4);
      }
      const P2 = [];
      for (let t4 = 0, e3 = E2.length, n3 = e3 - 1, i3 = t4 + 1; t4 < e3; t4++, n3++, i3++)
        n3 === e3 && (n3 = 0), i3 === e3 && (i3 = 0), P2[t4] = C2(E2[t4], E2[n3], E2[i3]);
      const I2 = [];
      let D2, N2 = P2.concat();
      for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
        const e4 = S2[t4];
        D2 = [];
        for (let t5 = 0, n3 = e4.length, i3 = n3 - 1, r3 = t5 + 1; t5 < n3; t5++, i3++, r3++)
          i3 === n3 && (i3 = 0), r3 === n3 && (r3 = 0), D2[t5] = C2(e4[t5], e4[i3], e4[r3]);
        I2.push(D2), N2 = N2.concat(D2);
      }
      for (let t4 = 0; t4 < p2; t4++) {
        const e3 = t4 / p2, n3 = h2 * Math.cos(e3 * Math.PI / 2), i3 = u2 * Math.sin(e3 * Math.PI / 2) + d2;
        for (let t5 = 0, e4 = E2.length; t5 < e4; t5++) {
          const e5 = A2(E2[t5], P2[t5], i3);
          U2(e5.x, e5.y, -n3);
        }
        for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
          const e5 = S2[t5];
          D2 = I2[t5];
          for (let t6 = 0, r3 = e5.length; t6 < r3; t6++) {
            const r4 = A2(e5[t6], D2[t6], i3);
            U2(r4.x, r4.y, -n3);
          }
        }
      }
      const F2 = u2 + d2;
      for (let t4 = 0; t4 < R2; t4++) {
        const e3 = c2 ? A2(M2[t4], N2[t4], F2) : M2[t4];
        w2 ? (x2.copy(v2.normals[0]).multiplyScalar(e3.x), y2.copy(v2.binormals[0]).multiplyScalar(e3.y), b2.copy(g2[0]).add(x2).add(y2), U2(b2.x, b2.y, b2.z)) : U2(e3.x, e3.y, 0);
      }
      for (let t4 = 1; t4 <= o2; t4++)
        for (let e3 = 0; e3 < R2; e3++) {
          const n3 = c2 ? A2(M2[e3], N2[e3], F2) : M2[e3];
          w2 ? (x2.copy(v2.normals[t4]).multiplyScalar(n3.x), y2.copy(v2.binormals[t4]).multiplyScalar(n3.y), b2.copy(g2[t4]).add(x2).add(y2), U2(b2.x, b2.y, b2.z)) : U2(n3.x, n3.y, l2 / o2 * t4);
        }
      for (let t4 = p2 - 1; t4 >= 0; t4--) {
        const e3 = t4 / p2, n3 = h2 * Math.cos(e3 * Math.PI / 2), i3 = u2 * Math.sin(e3 * Math.PI / 2) + d2;
        for (let t5 = 0, e4 = E2.length; t5 < e4; t5++) {
          const e5 = A2(E2[t5], P2[t5], i3);
          U2(e5.x, e5.y, l2 + n3);
        }
        for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
          const e5 = S2[t5];
          D2 = I2[t5];
          for (let t6 = 0, r3 = e5.length; t6 < r3; t6++) {
            const r4 = A2(e5[t6], D2[t6], i3);
            w2 ? U2(r4.x, r4.y + g2[o2 - 1].y, g2[o2 - 1].x + n3) : U2(r4.x, r4.y, l2 + n3);
          }
        }
      }
      function O2(t4, e3) {
        let n3 = t4.length;
        for (; --n3 >= 0; ) {
          const i3 = n3;
          let r3 = n3 - 1;
          r3 < 0 && (r3 = t4.length - 1);
          for (let t5 = 0, n4 = o2 + 2 * p2; t5 < n4; t5++) {
            const n5 = R2 * t5, s4 = R2 * (t5 + 1);
            z2(e3 + i3 + n5, e3 + r3 + n5, e3 + r3 + s4, e3 + i3 + s4);
          }
        }
      }
      function U2(t4, e3, n3) {
        s3.push(t4), s3.push(e3), s3.push(n3);
      }
      function k2(t4, e3, r3) {
        B2(t4), B2(e3), B2(r3);
        const s4 = i2.length / 3, a3 = f2.generateTopUV(n2, i2, s4 - 3, s4 - 2, s4 - 1);
        H2(a3[0]), H2(a3[1]), H2(a3[2]);
      }
      function z2(t4, e3, r3, s4) {
        B2(t4), B2(e3), B2(s4), B2(e3), B2(r3), B2(s4);
        const a3 = i2.length / 3, o3 = f2.generateSideWallUV(n2, i2, a3 - 6, a3 - 3, a3 - 2, a3 - 1);
        H2(o3[0]), H2(o3[1]), H2(o3[3]), H2(o3[1]), H2(o3[2]), H2(o3[3]);
      }
      function B2(t4) {
        i2.push(s3[3 * t4 + 0]), i2.push(s3[3 * t4 + 1]), i2.push(s3[3 * t4 + 2]);
      }
      function H2(t4) {
        r2.push(t4.x), r2.push(t4.y);
      }
      !function() {
        const t4 = i2.length / 3;
        if (c2) {
          let t5 = 0, e3 = R2 * t5;
          for (let t6 = 0; t6 < L2; t6++) {
            const n3 = T2[t6];
            k2(n3[2] + e3, n3[1] + e3, n3[0] + e3);
          }
          t5 = o2 + 2 * p2, e3 = R2 * t5;
          for (let t6 = 0; t6 < L2; t6++) {
            const n3 = T2[t6];
            k2(n3[0] + e3, n3[1] + e3, n3[2] + e3);
          }
        } else {
          for (let t5 = 0; t5 < L2; t5++) {
            const e3 = T2[t5];
            k2(e3[2], e3[1], e3[0]);
          }
          for (let t5 = 0; t5 < L2; t5++) {
            const e3 = T2[t5];
            k2(e3[0] + R2 * o2, e3[1] + R2 * o2, e3[2] + R2 * o2);
          }
        }
        n2.addGroup(t4, i2.length / 3 - t4, 0);
      }(), function() {
        const t4 = i2.length / 3;
        let e3 = 0;
        O2(E2, e3), e3 += E2.length;
        for (let t5 = 0, n3 = S2.length; t5 < n3; t5++) {
          const n4 = S2[t5];
          O2(n4, e3), e3 += n4.length;
        }
        n2.addGroup(t4, i2.length / 3 - t4, 1);
      }();
    }
    this.setAttribute("position", new nn(i2, 3)), this.setAttribute("uv", new nn(r2, 2)), this.computeVertexNormals();
  }
  toJSON() {
    const t2 = super.toJSON();
    return function(t3, e2, n2) {
      if (n2.shapes = [], Array.isArray(t3))
        for (let e3 = 0, i2 = t3.length; e3 < i2; e3++) {
          const i3 = t3[e3];
          n2.shapes.push(i3.uuid);
        }
      else
        n2.shapes.push(t3.uuid);
      e2.extrudePath !== void 0 && (n2.options.extrudePath = e2.extrudePath.toJSON());
      return n2;
    }(this.parameters.shapes, this.parameters.options, t2);
  }
  static fromJSON(t2, e2) {
    const n2 = [];
    for (let i3 = 0, r2 = t2.shapes.length; i3 < r2; i3++) {
      const r3 = e2[t2.shapes[i3]];
      n2.push(r3);
    }
    const i2 = t2.options.extrudePath;
    return i2 !== void 0 && (t2.options.extrudePath = new ro[i2.type]().fromJSON(i2)), new Uo(n2, t2.options);
  }
}
const ko = { generateTopUV: function(t2, e2, n2, i2, r2) {
  const s2 = e2[3 * n2], a2 = e2[3 * n2 + 1], o2 = e2[3 * i2], l2 = e2[3 * i2 + 1], c2 = e2[3 * r2], h2 = e2[3 * r2 + 1];
  return [new mt(s2, a2), new mt(o2, l2), new mt(c2, h2)];
}, generateSideWallUV: function(t2, e2, n2, i2, r2, s2) {
  const a2 = e2[3 * n2], o2 = e2[3 * n2 + 1], l2 = e2[3 * n2 + 2], c2 = e2[3 * i2], h2 = e2[3 * i2 + 1], u2 = e2[3 * i2 + 2], d2 = e2[3 * r2], p2 = e2[3 * r2 + 1], m2 = e2[3 * r2 + 2], f2 = e2[3 * s2], g2 = e2[3 * s2 + 1], v2 = e2[3 * s2 + 2];
  return Math.abs(o2 - h2) < Math.abs(a2 - c2) ? [new mt(a2, 1 - l2), new mt(c2, 1 - u2), new mt(d2, 1 - m2), new mt(f2, 1 - v2)] : [new mt(o2, 1 - l2), new mt(h2, 1 - u2), new mt(p2, 1 - m2), new mt(g2, 1 - v2)];
} };
class zo extends un {
  constructor(t2 = new oo([new mt(0, 0.5), new mt(-0.5, -0.5), new mt(0.5, -0.5)]), e2 = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: t2, curveSegments: e2 };
    const n2 = [], i2 = [], r2 = [], s2 = [];
    let a2 = 0, o2 = 0;
    if (Array.isArray(t2) === false)
      l2(t2);
    else
      for (let e3 = 0; e3 < t2.length; e3++)
        l2(t2[e3]), this.addGroup(a2, o2, e3), a2 += o2, o2 = 0;
    function l2(t3) {
      const a3 = i2.length / 3, l3 = t3.extractPoints(e2);
      let c2 = l3.shape;
      const h2 = l3.holes;
      No.isClockWise(c2) === false && (c2 = c2.reverse());
      for (let t4 = 0, e3 = h2.length; t4 < e3; t4++) {
        const e4 = h2[t4];
        No.isClockWise(e4) === true && (h2[t4] = e4.reverse());
      }
      const u2 = No.triangulateShape(c2, h2);
      for (let t4 = 0, e3 = h2.length; t4 < e3; t4++) {
        const e4 = h2[t4];
        c2 = c2.concat(e4);
      }
      for (let t4 = 0, e3 = c2.length; t4 < e3; t4++) {
        const e4 = c2[t4];
        i2.push(e4.x, e4.y, 0), r2.push(0, 0, 1), s2.push(e4.x, e4.y);
      }
      for (let t4 = 0, e3 = u2.length; t4 < e3; t4++) {
        const e4 = u2[t4], i3 = e4[0] + a3, r3 = e4[1] + a3, s3 = e4[2] + a3;
        n2.push(i3, r3, s3), o2 += 3;
      }
    }
    this.setIndex(n2), this.setAttribute("position", new nn(i2, 3)), this.setAttribute("normal", new nn(r2, 3)), this.setAttribute("uv", new nn(s2, 2));
  }
  toJSON() {
    const t2 = super.toJSON();
    return function(t3, e2) {
      if (e2.shapes = [], Array.isArray(t3))
        for (let n2 = 0, i2 = t3.length; n2 < i2; n2++) {
          const i3 = t3[n2];
          e2.shapes.push(i3.uuid);
        }
      else
        e2.shapes.push(t3.uuid);
      return e2;
    }(this.parameters.shapes, t2);
  }
  static fromJSON(t2, e2) {
    const n2 = [];
    for (let i2 = 0, r2 = t2.shapes.length; i2 < r2; i2++) {
      const r3 = e2[t2.shapes[i2]];
      n2.push(r3);
    }
    return new zo(n2, t2.curveSegments);
  }
}
class Bo extends Ve {
  constructor(t2) {
    super(), this.type = "ShadowMaterial", this.color = new Ze(0), this.transparent = true, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this;
  }
}
Bo.prototype.isShadowMaterial = true;
class Ho extends Ve {
  constructor(t2) {
    super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ze(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new mt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.defines = { STANDARD: "" }, this.color.copy(t2.color), this.roughness = t2.roughness, this.metalness = t2.metalness, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.roughnessMap = t2.roughnessMap, this.metalnessMap = t2.metalnessMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.envMapIntensity = t2.envMapIntensity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.flatShading = t2.flatShading, this;
  }
}
Ho.prototype.isMeshStandardMaterial = true;
class Vo extends Ho {
  constructor(t2) {
    super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new mt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return ot(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(t3) {
      this.ior = (1 + 0.4 * t3) / (1 - 0.4 * t3);
    } }), this.sheenColor = new Ze(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Ze(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ze(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t2);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(t2) {
    this._sheen > 0 != t2 > 0 && this.version++, this._sheen = t2;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t2) {
    this._clearcoat > 0 != t2 > 0 && this.version++, this._clearcoat = t2;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t2) {
    this._transmission > 0 != t2 > 0 && this.version++, this._transmission = t2;
  }
  copy(t2) {
    return super.copy(t2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t2.clearcoat, this.clearcoatMap = t2.clearcoatMap, this.clearcoatRoughness = t2.clearcoatRoughness, this.clearcoatRoughnessMap = t2.clearcoatRoughnessMap, this.clearcoatNormalMap = t2.clearcoatNormalMap, this.clearcoatNormalScale.copy(t2.clearcoatNormalScale), this.ior = t2.ior, this.sheen = t2.sheen, this.sheenColor.copy(t2.sheenColor), this.sheenColorMap = t2.sheenColorMap, this.sheenRoughness = t2.sheenRoughness, this.sheenRoughnessMap = t2.sheenRoughnessMap, this.transmission = t2.transmission, this.transmissionMap = t2.transmissionMap, this.thickness = t2.thickness, this.thicknessMap = t2.thicknessMap, this.attenuationDistance = t2.attenuationDistance, this.attenuationColor.copy(t2.attenuationColor), this.specularIntensity = t2.specularIntensity, this.specularIntensityMap = t2.specularIntensityMap, this.specularColor.copy(t2.specularColor), this.specularColorMap = t2.specularColorMap, this;
  }
}
Vo.prototype.isMeshPhysicalMaterial = true;
(class extends Ve {
  constructor(t2) {
    super(), this.type = "MeshPhongMaterial", this.color = new Ze(16777215), this.specular = new Ze(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new mt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this.specular.copy(t2.specular), this.shininess = t2.shininess, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.flatShading = t2.flatShading, this;
  }
}).prototype.isMeshPhongMaterial = true;
(class extends Ve {
  constructor(t2) {
    super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Ze(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new mt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.gradientMap = t2.gradientMap, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this;
  }
}).prototype.isMeshToonMaterial = true;
(class extends Ve {
  constructor(t2) {
    super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new mt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.flatShading = false, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.flatShading = t2.flatShading, this;
  }
}).prototype.isMeshNormalMaterial = true;
(class extends Ve {
  constructor(t2) {
    super(), this.type = "MeshLambertMaterial", this.color = new Ze(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this;
  }
}).prototype.isMeshLambertMaterial = true;
(class extends Ve {
  constructor(t2) {
    super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Ze(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new mt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.defines = { MATCAP: "" }, this.color.copy(t2.color), this.matcap = t2.matcap, this.map = t2.map, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.flatShading = t2.flatShading, this;
  }
}).prototype.isMeshMatcapMaterial = true;
(class extends wa {
  constructor(t2) {
    super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.scale = t2.scale, this.dashSize = t2.dashSize, this.gapSize = t2.gapSize, this;
  }
}).prototype.isLineDashedMaterial = true;
const Go = { arraySlice: function(t2, e2, n2) {
  return Go.isTypedArray(t2) ? new t2.constructor(t2.subarray(e2, n2 !== void 0 ? n2 : t2.length)) : t2.slice(e2, n2);
}, convertArray: function(t2, e2, n2) {
  return !t2 || !n2 && t2.constructor === e2 ? t2 : typeof e2.BYTES_PER_ELEMENT == "number" ? new e2(t2) : Array.prototype.slice.call(t2);
}, isTypedArray: function(t2) {
  return ArrayBuffer.isView(t2) && !(t2 instanceof DataView);
}, getKeyframeOrder: function(t2) {
  const e2 = t2.length, n2 = new Array(e2);
  for (let t3 = 0; t3 !== e2; ++t3)
    n2[t3] = t3;
  return n2.sort(function(e3, n3) {
    return t2[e3] - t2[n3];
  }), n2;
}, sortedArray: function(t2, e2, n2) {
  const i2 = t2.length, r2 = new t2.constructor(i2);
  for (let s2 = 0, a2 = 0; a2 !== i2; ++s2) {
    const i3 = n2[s2] * e2;
    for (let n3 = 0; n3 !== e2; ++n3)
      r2[a2++] = t2[i3 + n3];
  }
  return r2;
}, flattenJSON: function(t2, e2, n2, i2) {
  let r2 = 1, s2 = t2[0];
  for (; s2 !== void 0 && s2[i2] === void 0; )
    s2 = t2[r2++];
  if (s2 === void 0)
    return;
  let a2 = s2[i2];
  if (a2 !== void 0)
    if (Array.isArray(a2))
      do {
        a2 = s2[i2], a2 !== void 0 && (e2.push(s2.time), n2.push.apply(n2, a2)), s2 = t2[r2++];
      } while (s2 !== void 0);
    else if (a2.toArray !== void 0)
      do {
        a2 = s2[i2], a2 !== void 0 && (e2.push(s2.time), a2.toArray(n2, n2.length)), s2 = t2[r2++];
      } while (s2 !== void 0);
    else
      do {
        a2 = s2[i2], a2 !== void 0 && (e2.push(s2.time), n2.push(a2)), s2 = t2[r2++];
      } while (s2 !== void 0);
}, subclip: function(t2, e2, n2, i2, r2 = 30) {
  const s2 = t2.clone();
  s2.name = e2;
  const a2 = [];
  for (let t3 = 0; t3 < s2.tracks.length; ++t3) {
    const e3 = s2.tracks[t3], o3 = e3.getValueSize(), l2 = [], c2 = [];
    for (let t4 = 0; t4 < e3.times.length; ++t4) {
      const s3 = e3.times[t4] * r2;
      if (!(s3 < n2 || s3 >= i2)) {
        l2.push(e3.times[t4]);
        for (let n3 = 0; n3 < o3; ++n3)
          c2.push(e3.values[t4 * o3 + n3]);
      }
    }
    l2.length !== 0 && (e3.times = Go.convertArray(l2, e3.times.constructor), e3.values = Go.convertArray(c2, e3.values.constructor), a2.push(e3));
  }
  s2.tracks = a2;
  let o2 = 1 / 0;
  for (let t3 = 0; t3 < s2.tracks.length; ++t3)
    o2 > s2.tracks[t3].times[0] && (o2 = s2.tracks[t3].times[0]);
  for (let t3 = 0; t3 < s2.tracks.length; ++t3)
    s2.tracks[t3].shift(-1 * o2);
  return s2.resetDuration(), s2;
}, makeClipAdditive: function(t2, e2 = 0, n2 = t2, i2 = 30) {
  i2 <= 0 && (i2 = 30);
  const r2 = n2.tracks.length, s2 = e2 / i2;
  for (let e3 = 0; e3 < r2; ++e3) {
    const i3 = n2.tracks[e3], r3 = i3.ValueTypeName;
    if (r3 === "bool" || r3 === "string")
      continue;
    const a2 = t2.tracks.find(function(t3) {
      return t3.name === i3.name && t3.ValueTypeName === r3;
    });
    if (a2 === void 0)
      continue;
    let o2 = 0;
    const l2 = i3.getValueSize();
    i3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o2 = l2 / 3);
    let c2 = 0;
    const h2 = a2.getValueSize();
    a2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c2 = h2 / 3);
    const u2 = i3.times.length - 1;
    let d2;
    if (s2 <= i3.times[0]) {
      const t3 = o2, e4 = l2 - o2;
      d2 = Go.arraySlice(i3.values, t3, e4);
    } else if (s2 >= i3.times[u2]) {
      const t3 = u2 * l2 + o2, e4 = t3 + l2 - o2;
      d2 = Go.arraySlice(i3.values, t3, e4);
    } else {
      const t3 = i3.createInterpolant(), e4 = o2, n3 = l2 - o2;
      t3.evaluate(s2), d2 = Go.arraySlice(t3.resultBuffer, e4, n3);
    }
    if (r3 === "quaternion") {
      new Et().fromArray(d2).normalize().conjugate().toArray(d2);
    }
    const p2 = a2.times.length;
    for (let t3 = 0; t3 < p2; ++t3) {
      const e4 = t3 * h2 + c2;
      if (r3 === "quaternion")
        Et.multiplyQuaternionsFlat(a2.values, e4, d2, 0, a2.values, e4);
      else {
        const t4 = h2 - 2 * c2;
        for (let n3 = 0; n3 < t4; ++n3)
          a2.values[e4 + n3] -= d2[n3];
      }
    }
  }
  return t2.blendMode = 2501, t2;
} };
class Wo {
  constructor(t2, e2, n2, i2) {
    this.parameterPositions = t2, this._cachedIndex = 0, this.resultBuffer = i2 !== void 0 ? i2 : new e2.constructor(n2), this.sampleValues = e2, this.valueSize = n2, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(t2) {
    const e2 = this.parameterPositions;
    let n2 = this._cachedIndex, i2 = e2[n2], r2 = e2[n2 - 1];
    t: {
      e: {
        let s2;
        n: {
          i:
            if (!(t2 < i2)) {
              for (let s3 = n2 + 2; ; ) {
                if (i2 === void 0) {
                  if (t2 < r2)
                    break i;
                  return n2 = e2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, t2, r2);
                }
                if (n2 === s3)
                  break;
                if (r2 = i2, i2 = e2[++n2], t2 < i2)
                  break e;
              }
              s2 = e2.length;
              break n;
            }
          if (t2 >= r2)
            break t;
          {
            const a2 = e2[1];
            t2 < a2 && (n2 = 2, r2 = a2);
            for (let s3 = n2 - 2; ; ) {
              if (r2 === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, t2, i2);
              if (n2 === s3)
                break;
              if (i2 = r2, r2 = e2[--n2 - 1], t2 >= r2)
                break e;
            }
            s2 = n2, n2 = 0;
          }
        }
        for (; n2 < s2; ) {
          const i3 = n2 + s2 >>> 1;
          t2 < e2[i3] ? s2 = i3 : n2 = i3 + 1;
        }
        if (i2 = e2[n2], r2 = e2[n2 - 1], r2 === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, t2, i2);
        if (i2 === void 0)
          return n2 = e2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, r2, t2);
      }
      this._cachedIndex = n2, this.intervalChanged_(n2, r2, i2);
    }
    return this.interpolate_(n2, r2, t2, i2);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(t2) {
    const e2 = this.resultBuffer, n2 = this.sampleValues, i2 = this.valueSize, r2 = t2 * i2;
    for (let t3 = 0; t3 !== i2; ++t3)
      e2[t3] = n2[r2 + t3];
    return e2;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
Wo.prototype.beforeStart_ = Wo.prototype.copySampleValue_, Wo.prototype.afterEnd_ = Wo.prototype.copySampleValue_;
class jo extends Wo {
  constructor(t2, e2, n2, i2) {
    super(t2, e2, n2, i2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 };
  }
  intervalChanged_(t2, e2, n2) {
    const i2 = this.parameterPositions;
    let r2 = t2 - 2, s2 = t2 + 1, a2 = i2[r2], o2 = i2[s2];
    if (a2 === void 0)
      switch (this.getSettings_().endingStart) {
        case 2401:
          r2 = t2, a2 = 2 * e2 - n2;
          break;
        case 2402:
          r2 = i2.length - 2, a2 = e2 + i2[r2] - i2[r2 + 1];
          break;
        default:
          r2 = t2, a2 = n2;
      }
    if (o2 === void 0)
      switch (this.getSettings_().endingEnd) {
        case 2401:
          s2 = t2, o2 = 2 * n2 - e2;
          break;
        case 2402:
          s2 = 1, o2 = n2 + i2[1] - i2[0];
          break;
        default:
          s2 = t2 - 1, o2 = e2;
      }
    const l2 = 0.5 * (n2 - e2), c2 = this.valueSize;
    this._weightPrev = l2 / (e2 - a2), this._weightNext = l2 / (o2 - n2), this._offsetPrev = r2 * c2, this._offsetNext = s2 * c2;
  }
  interpolate_(t2, e2, n2, i2) {
    const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o2 = t2 * a2, l2 = o2 - a2, c2 = this._offsetPrev, h2 = this._offsetNext, u2 = this._weightPrev, d2 = this._weightNext, p2 = (n2 - e2) / (i2 - e2), m2 = p2 * p2, f2 = m2 * p2, g2 = -u2 * f2 + 2 * u2 * m2 - u2 * p2, v2 = (1 + u2) * f2 + (-1.5 - 2 * u2) * m2 + (-0.5 + u2) * p2 + 1, y2 = (-1 - d2) * f2 + (1.5 + d2) * m2 + 0.5 * p2, x2 = d2 * f2 - d2 * m2;
    for (let t3 = 0; t3 !== a2; ++t3)
      r2[t3] = g2 * s2[c2 + t3] + v2 * s2[l2 + t3] + y2 * s2[o2 + t3] + x2 * s2[h2 + t3];
    return r2;
  }
}
class qo extends Wo {
  constructor(t2, e2, n2, i2) {
    super(t2, e2, n2, i2);
  }
  interpolate_(t2, e2, n2, i2) {
    const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o2 = t2 * a2, l2 = o2 - a2, c2 = (n2 - e2) / (i2 - e2), h2 = 1 - c2;
    for (let t3 = 0; t3 !== a2; ++t3)
      r2[t3] = s2[l2 + t3] * h2 + s2[o2 + t3] * c2;
    return r2;
  }
}
class Xo extends Wo {
  constructor(t2, e2, n2, i2) {
    super(t2, e2, n2, i2);
  }
  interpolate_(t2) {
    return this.copySampleValue_(t2 - 1);
  }
}
class Yo {
  constructor(t2, e2, n2, i2) {
    if (t2 === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (e2 === void 0 || e2.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t2);
    this.name = t2, this.times = Go.convertArray(e2, this.TimeBufferType), this.values = Go.convertArray(n2, this.ValueBufferType), this.setInterpolation(i2 || this.DefaultInterpolation);
  }
  static toJSON(t2) {
    const e2 = t2.constructor;
    let n2;
    if (e2.toJSON !== this.toJSON)
      n2 = e2.toJSON(t2);
    else {
      n2 = { name: t2.name, times: Go.convertArray(t2.times, Array), values: Go.convertArray(t2.values, Array) };
      const e3 = t2.getInterpolation();
      e3 !== t2.DefaultInterpolation && (n2.interpolation = e3);
    }
    return n2.type = t2.ValueTypeName, n2;
  }
  InterpolantFactoryMethodDiscrete(t2) {
    return new Xo(this.times, this.values, this.getValueSize(), t2);
  }
  InterpolantFactoryMethodLinear(t2) {
    return new qo(this.times, this.values, this.getValueSize(), t2);
  }
  InterpolantFactoryMethodSmooth(t2) {
    return new jo(this.times, this.values, this.getValueSize(), t2);
  }
  setInterpolation(t2) {
    let e2;
    switch (t2) {
      case 2300:
        e2 = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        e2 = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        e2 = this.InterpolantFactoryMethodSmooth;
    }
    if (e2 === void 0) {
      const e3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (t2 === this.DefaultInterpolation)
          throw new Error(e3);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("THREE.KeyframeTrack:", e3), this;
    }
    return this.createInterpolant = e2, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(t2) {
    if (t2 !== 0) {
      const e2 = this.times;
      for (let n2 = 0, i2 = e2.length; n2 !== i2; ++n2)
        e2[n2] += t2;
    }
    return this;
  }
  scale(t2) {
    if (t2 !== 1) {
      const e2 = this.times;
      for (let n2 = 0, i2 = e2.length; n2 !== i2; ++n2)
        e2[n2] *= t2;
    }
    return this;
  }
  trim(t2, e2) {
    const n2 = this.times, i2 = n2.length;
    let r2 = 0, s2 = i2 - 1;
    for (; r2 !== i2 && n2[r2] < t2; )
      ++r2;
    for (; s2 !== -1 && n2[s2] > e2; )
      --s2;
    if (++s2, r2 !== 0 || s2 !== i2) {
      r2 >= s2 && (s2 = Math.max(s2, 1), r2 = s2 - 1);
      const t3 = this.getValueSize();
      this.times = Go.arraySlice(n2, r2, s2), this.values = Go.arraySlice(this.values, r2 * t3, s2 * t3);
    }
    return this;
  }
  validate() {
    let t2 = true;
    const e2 = this.getValueSize();
    e2 - Math.floor(e2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t2 = false);
    const n2 = this.times, i2 = this.values, r2 = n2.length;
    r2 === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t2 = false);
    let s2 = null;
    for (let e3 = 0; e3 !== r2; e3++) {
      const i3 = n2[e3];
      if (typeof i3 == "number" && isNaN(i3)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e3, i3), t2 = false;
        break;
      }
      if (s2 !== null && s2 > i3) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, e3, i3, s2), t2 = false;
        break;
      }
      s2 = i3;
    }
    if (i2 !== void 0 && Go.isTypedArray(i2))
      for (let e3 = 0, n3 = i2.length; e3 !== n3; ++e3) {
        const n4 = i2[e3];
        if (isNaN(n4)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e3, n4), t2 = false;
          break;
        }
      }
    return t2;
  }
  optimize() {
    const t2 = Go.arraySlice(this.times), e2 = Go.arraySlice(this.values), n2 = this.getValueSize(), i2 = this.getInterpolation() === 2302, r2 = t2.length - 1;
    let s2 = 1;
    for (let a2 = 1; a2 < r2; ++a2) {
      let r3 = false;
      const o2 = t2[a2];
      if (o2 !== t2[a2 + 1] && (a2 !== 1 || o2 !== t2[0]))
        if (i2)
          r3 = true;
        else {
          const t3 = a2 * n2, i3 = t3 - n2, s3 = t3 + n2;
          for (let a3 = 0; a3 !== n2; ++a3) {
            const n3 = e2[t3 + a3];
            if (n3 !== e2[i3 + a3] || n3 !== e2[s3 + a3]) {
              r3 = true;
              break;
            }
          }
        }
      if (r3) {
        if (a2 !== s2) {
          t2[s2] = t2[a2];
          const i3 = a2 * n2, r4 = s2 * n2;
          for (let t3 = 0; t3 !== n2; ++t3)
            e2[r4 + t3] = e2[i3 + t3];
        }
        ++s2;
      }
    }
    if (r2 > 0) {
      t2[s2] = t2[r2];
      for (let t3 = r2 * n2, i3 = s2 * n2, a2 = 0; a2 !== n2; ++a2)
        e2[i3 + a2] = e2[t3 + a2];
      ++s2;
    }
    return s2 !== t2.length ? (this.times = Go.arraySlice(t2, 0, s2), this.values = Go.arraySlice(e2, 0, s2 * n2)) : (this.times = t2, this.values = e2), this;
  }
  clone() {
    const t2 = Go.arraySlice(this.times, 0), e2 = Go.arraySlice(this.values, 0), n2 = new this.constructor(this.name, t2, e2);
    return n2.createInterpolant = this.createInterpolant, n2;
  }
}
Yo.prototype.TimeBufferType = Float32Array, Yo.prototype.ValueBufferType = Float32Array, Yo.prototype.DefaultInterpolation = 2301;
class Zo extends Yo {
}
Zo.prototype.ValueTypeName = "bool", Zo.prototype.ValueBufferType = Array, Zo.prototype.DefaultInterpolation = 2300, Zo.prototype.InterpolantFactoryMethodLinear = void 0, Zo.prototype.InterpolantFactoryMethodSmooth = void 0;
class Jo extends Yo {
}
Jo.prototype.ValueTypeName = "color";
class $o extends Yo {
}
$o.prototype.ValueTypeName = "number";
class Ko extends Wo {
  constructor(t2, e2, n2, i2) {
    super(t2, e2, n2, i2);
  }
  interpolate_(t2, e2, n2, i2) {
    const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o2 = (n2 - e2) / (i2 - e2);
    let l2 = t2 * a2;
    for (let t3 = l2 + a2; l2 !== t3; l2 += 4)
      Et.slerpFlat(r2, 0, s2, l2 - a2, s2, l2, o2);
    return r2;
  }
}
class Qo extends Yo {
  InterpolantFactoryMethodLinear(t2) {
    return new Ko(this.times, this.values, this.getValueSize(), t2);
  }
}
Qo.prototype.ValueTypeName = "quaternion", Qo.prototype.DefaultInterpolation = 2301, Qo.prototype.InterpolantFactoryMethodSmooth = void 0;
class tl extends Yo {
}
tl.prototype.ValueTypeName = "string", tl.prototype.ValueBufferType = Array, tl.prototype.DefaultInterpolation = 2300, tl.prototype.InterpolantFactoryMethodLinear = void 0, tl.prototype.InterpolantFactoryMethodSmooth = void 0;
class el extends Yo {
}
el.prototype.ValueTypeName = "vector";
class nl {
  constructor(t2, e2 = -1, n2, i2 = 2500) {
    this.name = t2, this.tracks = n2, this.duration = e2, this.blendMode = i2, this.uuid = at(), this.duration < 0 && this.resetDuration();
  }
  static parse(t2) {
    const e2 = [], n2 = t2.tracks, i2 = 1 / (t2.fps || 1);
    for (let t3 = 0, r3 = n2.length; t3 !== r3; ++t3)
      e2.push(il(n2[t3]).scale(i2));
    const r2 = new this(t2.name, t2.duration, e2, t2.blendMode);
    return r2.uuid = t2.uuid, r2;
  }
  static toJSON(t2) {
    const e2 = [], n2 = t2.tracks, i2 = { name: t2.name, duration: t2.duration, tracks: e2, uuid: t2.uuid, blendMode: t2.blendMode };
    for (let t3 = 0, i3 = n2.length; t3 !== i3; ++t3)
      e2.push(Yo.toJSON(n2[t3]));
    return i2;
  }
  static CreateFromMorphTargetSequence(t2, e2, n2, i2) {
    const r2 = e2.length, s2 = [];
    for (let t3 = 0; t3 < r2; t3++) {
      let a2 = [], o2 = [];
      a2.push((t3 + r2 - 1) % r2, t3, (t3 + 1) % r2), o2.push(0, 1, 0);
      const l2 = Go.getKeyframeOrder(a2);
      a2 = Go.sortedArray(a2, 1, l2), o2 = Go.sortedArray(o2, 1, l2), i2 || a2[0] !== 0 || (a2.push(r2), o2.push(o2[0])), s2.push(new $o(".morphTargetInfluences[" + e2[t3].name + "]", a2, o2).scale(1 / n2));
    }
    return new this(t2, -1, s2);
  }
  static findByName(t2, e2) {
    let n2 = t2;
    if (!Array.isArray(t2)) {
      const e3 = t2;
      n2 = e3.geometry && e3.geometry.animations || e3.animations;
    }
    for (let t3 = 0; t3 < n2.length; t3++)
      if (n2[t3].name === e2)
        return n2[t3];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(t2, e2, n2) {
    const i2 = {}, r2 = /^([\w-]*?)([\d]+)$/;
    for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
      const n4 = t2[e3], s3 = n4.name.match(r2);
      if (s3 && s3.length > 1) {
        const t3 = s3[1];
        let e4 = i2[t3];
        e4 || (i2[t3] = e4 = []), e4.push(n4);
      }
    }
    const s2 = [];
    for (const t3 in i2)
      s2.push(this.CreateFromMorphTargetSequence(t3, i2[t3], e2, n2));
    return s2;
  }
  static parseAnimation(t2, e2) {
    if (!t2)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n2 = function(t3, e3, n3, i3, r3) {
      if (n3.length !== 0) {
        const s3 = [], a3 = [];
        Go.flattenJSON(n3, s3, a3, i3), s3.length !== 0 && r3.push(new t3(e3, s3, a3));
      }
    }, i2 = [], r2 = t2.name || "default", s2 = t2.fps || 30, a2 = t2.blendMode;
    let o2 = t2.length || -1;
    const l2 = t2.hierarchy || [];
    for (let t3 = 0; t3 < l2.length; t3++) {
      const r3 = l2[t3].keys;
      if (r3 && r3.length !== 0)
        if (r3[0].morphTargets) {
          const t4 = {};
          let e3;
          for (e3 = 0; e3 < r3.length; e3++)
            if (r3[e3].morphTargets)
              for (let n3 = 0; n3 < r3[e3].morphTargets.length; n3++)
                t4[r3[e3].morphTargets[n3]] = -1;
          for (const n3 in t4) {
            const t5 = [], s3 = [];
            for (let i3 = 0; i3 !== r3[e3].morphTargets.length; ++i3) {
              const i4 = r3[e3];
              t5.push(i4.time), s3.push(i4.morphTarget === n3 ? 1 : 0);
            }
            i2.push(new $o(".morphTargetInfluence[" + n3 + "]", t5, s3));
          }
          o2 = t4.length * (s2 || 1);
        } else {
          const s3 = ".bones[" + e2[t3].name + "]";
          n2(el, s3 + ".position", r3, "pos", i2), n2(Qo, s3 + ".quaternion", r3, "rot", i2), n2(el, s3 + ".scale", r3, "scl", i2);
        }
    }
    if (i2.length === 0)
      return null;
    return new this(r2, o2, i2, a2);
  }
  resetDuration() {
    let t2 = 0;
    for (let e2 = 0, n2 = this.tracks.length; e2 !== n2; ++e2) {
      const n3 = this.tracks[e2];
      t2 = Math.max(t2, n3.times[n3.times.length - 1]);
    }
    return this.duration = t2, this;
  }
  trim() {
    for (let t2 = 0; t2 < this.tracks.length; t2++)
      this.tracks[t2].trim(0, this.duration);
    return this;
  }
  validate() {
    let t2 = true;
    for (let e2 = 0; e2 < this.tracks.length; e2++)
      t2 = t2 && this.tracks[e2].validate();
    return t2;
  }
  optimize() {
    for (let t2 = 0; t2 < this.tracks.length; t2++)
      this.tracks[t2].optimize();
    return this;
  }
  clone() {
    const t2 = [];
    for (let e2 = 0; e2 < this.tracks.length; e2++)
      t2.push(this.tracks[e2].clone());
    return new this.constructor(this.name, this.duration, t2, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function il(t2) {
  if (t2.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e2 = function(t3) {
    switch (t3.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return $o;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return el;
      case "color":
        return Jo;
      case "quaternion":
        return Qo;
      case "bool":
      case "boolean":
        return Zo;
      case "string":
        return tl;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t3);
  }(t2.type);
  if (t2.times === void 0) {
    const e3 = [], n2 = [];
    Go.flattenJSON(t2.keys, e3, n2, "value"), t2.times = e3, t2.values = n2;
  }
  return e2.parse !== void 0 ? e2.parse(t2) : new e2(t2.name, t2.times, t2.values, t2.interpolation);
}
const rl = { enabled: false, files: {}, add: function(t2, e2) {
  this.enabled !== false && (this.files[t2] = e2);
}, get: function(t2) {
  if (this.enabled !== false)
    return this.files[t2];
}, remove: function(t2) {
  delete this.files[t2];
}, clear: function() {
  this.files = {};
} };
const sl = new class {
  constructor(t2, e2, n2) {
    const i2 = this;
    let r2, s2 = false, a2 = 0, o2 = 0;
    const l2 = [];
    this.onStart = void 0, this.onLoad = t2, this.onProgress = e2, this.onError = n2, this.itemStart = function(t3) {
      o2++, s2 === false && i2.onStart !== void 0 && i2.onStart(t3, a2, o2), s2 = true;
    }, this.itemEnd = function(t3) {
      a2++, i2.onProgress !== void 0 && i2.onProgress(t3, a2, o2), a2 === o2 && (s2 = false, i2.onLoad !== void 0 && i2.onLoad());
    }, this.itemError = function(t3) {
      i2.onError !== void 0 && i2.onError(t3);
    }, this.resolveURL = function(t3) {
      return r2 ? r2(t3) : t3;
    }, this.setURLModifier = function(t3) {
      return r2 = t3, this;
    }, this.addHandler = function(t3, e3) {
      return l2.push(t3, e3), this;
    }, this.removeHandler = function(t3) {
      const e3 = l2.indexOf(t3);
      return e3 !== -1 && l2.splice(e3, 2), this;
    }, this.getHandler = function(t3) {
      for (let e3 = 0, n3 = l2.length; e3 < n3; e3 += 2) {
        const n4 = l2[e3], i3 = l2[e3 + 1];
        if (n4.global && (n4.lastIndex = 0), n4.test(t3))
          return i3;
      }
      return null;
    };
  }
}();
class al {
  constructor(t2) {
    this.manager = t2 !== void 0 ? t2 : sl, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(t2, e2) {
    const n2 = this;
    return new Promise(function(i2, r2) {
      n2.load(t2, i2, e2, r2);
    });
  }
  parse() {
  }
  setCrossOrigin(t2) {
    return this.crossOrigin = t2, this;
  }
  setWithCredentials(t2) {
    return this.withCredentials = t2, this;
  }
  setPath(t2) {
    return this.path = t2, this;
  }
  setResourcePath(t2) {
    return this.resourcePath = t2, this;
  }
  setRequestHeader(t2) {
    return this.requestHeader = t2, this;
  }
}
const ol = {};
class ll extends al {
  constructor(t2) {
    super(t2);
  }
  load(t2, e2, n2, i2) {
    t2 === void 0 && (t2 = ""), this.path !== void 0 && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
    const r2 = rl.get(t2);
    if (r2 !== void 0)
      return this.manager.itemStart(t2), setTimeout(() => {
        e2 && e2(r2), this.manager.itemEnd(t2);
      }, 0), r2;
    if (ol[t2] !== void 0)
      return void ol[t2].push({ onLoad: e2, onProgress: n2, onError: i2 });
    ol[t2] = [], ol[t2].push({ onLoad: e2, onProgress: n2, onError: i2 });
    const s2 = new Request(t2, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" });
    fetch(s2).then((e3) => {
      if (e3.status === 200 || e3.status === 0) {
        if (e3.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream == "undefined" || e3.body.getReader === void 0)
          return e3;
        const n3 = ol[t2], i3 = e3.body.getReader(), r3 = e3.headers.get("Content-Length"), s3 = r3 ? parseInt(r3) : 0, a2 = s3 !== 0;
        let o2 = 0;
        const l2 = new ReadableStream({ start(t3) {
          !function e4() {
            i3.read().then(({ done: i4, value: r4 }) => {
              if (i4)
                t3.close();
              else {
                o2 += r4.byteLength;
                const i5 = new ProgressEvent("progress", { lengthComputable: a2, loaded: o2, total: s3 });
                for (let t4 = 0, e5 = n3.length; t4 < e5; t4++) {
                  const e6 = n3[t4];
                  e6.onProgress && e6.onProgress(i5);
                }
                t3.enqueue(r4), e4();
              }
            });
          }();
        } });
        return new Response(l2);
      }
      throw Error(`fetch for "${e3.url}" responded with ${e3.status}: ${e3.statusText}`);
    }).then((t3) => {
      switch (this.responseType) {
        case "arraybuffer":
          return t3.arrayBuffer();
        case "blob":
          return t3.blob();
        case "document":
          return t3.text().then((t4) => new DOMParser().parseFromString(t4, this.mimeType));
        case "json":
          return t3.json();
        default:
          return t3.text();
      }
    }).then((e3) => {
      rl.add(t2, e3);
      const n3 = ol[t2];
      delete ol[t2];
      for (let t3 = 0, i3 = n3.length; t3 < i3; t3++) {
        const i4 = n3[t3];
        i4.onLoad && i4.onLoad(e3);
      }
    }).catch((e3) => {
      const n3 = ol[t2];
      if (n3 === void 0)
        throw this.manager.itemError(t2), e3;
      delete ol[t2];
      for (let t3 = 0, i3 = n3.length; t3 < i3; t3++) {
        const i4 = n3[t3];
        i4.onError && i4.onError(e3);
      }
      this.manager.itemError(t2);
    }).finally(() => {
      this.manager.itemEnd(t2);
    }), this.manager.itemStart(t2);
  }
  setResponseType(t2) {
    return this.responseType = t2, this;
  }
  setMimeType(t2) {
    return this.mimeType = t2, this;
  }
}
class cl extends al {
  constructor(t2) {
    super(t2);
  }
  load(t2, e2, n2, i2) {
    this.path !== void 0 && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
    const r2 = this, s2 = rl.get(t2);
    if (s2 !== void 0)
      return r2.manager.itemStart(t2), setTimeout(function() {
        e2 && e2(s2), r2.manager.itemEnd(t2);
      }, 0), s2;
    const a2 = vt("img");
    function o2() {
      c2(), rl.add(t2, this), e2 && e2(this), r2.manager.itemEnd(t2);
    }
    function l2(e3) {
      c2(), i2 && i2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
    }
    function c2() {
      a2.removeEventListener("load", o2, false), a2.removeEventListener("error", l2, false);
    }
    return a2.addEventListener("load", o2, false), a2.addEventListener("error", l2, false), t2.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a2.crossOrigin = this.crossOrigin), r2.manager.itemStart(t2), a2.src = t2, a2;
  }
}
class hl extends al {
  constructor(t2) {
    super(t2);
  }
  load(t2, e2, n2, i2) {
    const r2 = new zn(), s2 = new cl(this.manager);
    s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path);
    let a2 = 0;
    function o2(n3) {
      s2.load(t2[n3], function(t3) {
        r2.images[n3] = t3, a2++, a2 === 6 && (r2.needsUpdate = true, e2 && e2(r2));
      }, void 0, i2);
    }
    for (let e3 = 0; e3 < t2.length; ++e3)
      o2(e3);
    return r2;
  }
}
class ul extends al {
  constructor(t2) {
    super(t2);
  }
  load(t2, e2, n2, i2) {
    const r2 = this, s2 = new da(), a2 = new ll(this.manager);
    return a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setPath(this.path), a2.setWithCredentials(r2.withCredentials), a2.load(t2, function(t3) {
      const n3 = r2.parse(t3);
      n3 && (n3.image !== void 0 ? s2.image = n3.image : n3.data !== void 0 && (s2.image.width = n3.width, s2.image.height = n3.height, s2.image.data = n3.data), s2.wrapS = n3.wrapS !== void 0 ? n3.wrapS : 1001, s2.wrapT = n3.wrapT !== void 0 ? n3.wrapT : 1001, s2.magFilter = n3.magFilter !== void 0 ? n3.magFilter : 1006, s2.minFilter = n3.minFilter !== void 0 ? n3.minFilter : 1006, s2.anisotropy = n3.anisotropy !== void 0 ? n3.anisotropy : 1, n3.encoding !== void 0 && (s2.encoding = n3.encoding), n3.flipY !== void 0 && (s2.flipY = n3.flipY), n3.format !== void 0 && (s2.format = n3.format), n3.type !== void 0 && (s2.type = n3.type), n3.mipmaps !== void 0 && (s2.mipmaps = n3.mipmaps, s2.minFilter = 1008), n3.mipmapCount === 1 && (s2.minFilter = 1006), n3.generateMipmaps !== void 0 && (s2.generateMipmaps = n3.generateMipmaps), s2.needsUpdate = true, e2 && e2(s2, n3));
    }, n2, i2), s2;
  }
}
class dl extends al {
  constructor(t2) {
    super(t2);
  }
  load(t2, e2, n2, i2) {
    const r2 = new wt(), s2 = new cl(this.manager);
    return s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path), s2.load(t2, function(t3) {
      r2.image = t3, r2.needsUpdate = true, e2 !== void 0 && e2(r2);
    }, n2, i2), r2;
  }
}
class pl extends Le {
  constructor(t2, e2 = 1) {
    super(), this.type = "Light", this.color = new Ze(t2), this.intensity = e2;
  }
  dispose() {
  }
  copy(t2) {
    return super.copy(t2), this.color.copy(t2.color), this.intensity = t2.intensity, this;
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    return e2.object.color = this.color.getHex(), e2.object.intensity = this.intensity, this.groundColor !== void 0 && (e2.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e2.object.distance = this.distance), this.angle !== void 0 && (e2.object.angle = this.angle), this.decay !== void 0 && (e2.object.decay = this.decay), this.penumbra !== void 0 && (e2.object.penumbra = this.penumbra), this.shadow !== void 0 && (e2.object.shadow = this.shadow.toJSON()), e2;
  }
}
pl.prototype.isLight = true;
(class extends pl {
  constructor(t2, e2, n2) {
    super(t2, n2), this.type = "HemisphereLight", this.position.copy(Le.DefaultUp), this.updateMatrix(), this.groundColor = new Ze(e2);
  }
  copy(t2) {
    return pl.prototype.copy.call(this, t2), this.groundColor.copy(t2.groundColor), this;
  }
}).prototype.isHemisphereLight = true;
const ml = new re(), fl = new At(), gl = new At();
class vl {
  constructor(t2) {
    this.camera = t2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new mt(512, 512), this.map = null, this.mapPass = null, this.matrix = new re(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Xn(), this._frameExtents = new mt(1, 1), this._viewportCount = 1, this._viewports = [new Mt(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t2) {
    const e2 = this.camera, n2 = this.matrix;
    fl.setFromMatrixPosition(t2.matrixWorld), e2.position.copy(fl), gl.setFromMatrixPosition(t2.target.matrixWorld), e2.lookAt(gl), e2.updateMatrixWorld(), ml.multiplyMatrices(e2.projectionMatrix, e2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ml), n2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n2.multiply(e2.projectionMatrix), n2.multiply(e2.matrixWorldInverse);
  }
  getViewport(t2) {
    return this._viewports[t2];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t2) {
    return this.camera = t2.camera.clone(), this.bias = t2.bias, this.radius = t2.radius, this.mapSize.copy(t2.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t2 = {};
    return this.bias !== 0 && (t2.bias = this.bias), this.normalBias !== 0 && (t2.normalBias = this.normalBias), this.radius !== 1 && (t2.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (t2.mapSize = this.mapSize.toArray()), t2.camera = this.camera.toJSON(false).object, delete t2.camera.matrix, t2;
  }
}
class yl extends vl {
  constructor() {
    super(new Un(50, 1, 0.5, 500)), this.focus = 1;
  }
  updateMatrices(t2) {
    const e2 = this.camera, n2 = 2 * st * t2.angle * this.focus, i2 = this.mapSize.width / this.mapSize.height, r2 = t2.distance || e2.far;
    n2 === e2.fov && i2 === e2.aspect && r2 === e2.far || (e2.fov = n2, e2.aspect = i2, e2.far = r2, e2.updateProjectionMatrix()), super.updateMatrices(t2);
  }
  copy(t2) {
    return super.copy(t2), this.focus = t2.focus, this;
  }
}
yl.prototype.isSpotLightShadow = true;
class xl extends pl {
  constructor(t2, e2, n2 = 0, i2 = Math.PI / 3, r2 = 0, s2 = 1) {
    super(t2, e2), this.type = "SpotLight", this.position.copy(Le.DefaultUp), this.updateMatrix(), this.target = new Le(), this.distance = n2, this.angle = i2, this.penumbra = r2, this.decay = s2, this.shadow = new yl();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(t2) {
    this.intensity = t2 / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t2) {
    return super.copy(t2), this.distance = t2.distance, this.angle = t2.angle, this.penumbra = t2.penumbra, this.decay = t2.decay, this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
  }
}
xl.prototype.isSpotLight = true;
const bl = new re(), wl = new At(), _l = new At();
class Ml extends vl {
  constructor() {
    super(new Un(90, 1, 0.5, 500)), this._frameExtents = new mt(4, 2), this._viewportCount = 6, this._viewports = [new Mt(2, 1, 1, 1), new Mt(0, 1, 1, 1), new Mt(3, 1, 1, 1), new Mt(1, 1, 1, 1), new Mt(3, 0, 1, 1), new Mt(1, 0, 1, 1)], this._cubeDirections = [new At(1, 0, 0), new At(-1, 0, 0), new At(0, 0, 1), new At(0, 0, -1), new At(0, 1, 0), new At(0, -1, 0)], this._cubeUps = [new At(0, 1, 0), new At(0, 1, 0), new At(0, 1, 0), new At(0, 1, 0), new At(0, 0, 1), new At(0, 0, -1)];
  }
  updateMatrices(t2, e2 = 0) {
    const n2 = this.camera, i2 = this.matrix, r2 = t2.distance || n2.far;
    r2 !== n2.far && (n2.far = r2, n2.updateProjectionMatrix()), wl.setFromMatrixPosition(t2.matrixWorld), n2.position.copy(wl), _l.copy(n2.position), _l.add(this._cubeDirections[e2]), n2.up.copy(this._cubeUps[e2]), n2.lookAt(_l), n2.updateMatrixWorld(), i2.makeTranslation(-wl.x, -wl.y, -wl.z), bl.multiplyMatrices(n2.projectionMatrix, n2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(bl);
  }
}
Ml.prototype.isPointLightShadow = true;
class Sl extends pl {
  constructor(t2, e2, n2 = 0, i2 = 1) {
    super(t2, e2), this.type = "PointLight", this.distance = n2, this.decay = i2, this.shadow = new Ml();
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(t2) {
    this.intensity = t2 / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t2) {
    return super.copy(t2), this.distance = t2.distance, this.decay = t2.decay, this.shadow = t2.shadow.clone(), this;
  }
}
Sl.prototype.isPointLight = true;
class Tl extends vl {
  constructor() {
    super(new ai(-5, 5, 5, -5, 0.5, 500));
  }
}
Tl.prototype.isDirectionalLightShadow = true;
class El extends pl {
  constructor(t2, e2) {
    super(t2, e2), this.type = "DirectionalLight", this.position.copy(Le.DefaultUp), this.updateMatrix(), this.target = new Le(), this.shadow = new Tl();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t2) {
    return super.copy(t2), this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
  }
}
El.prototype.isDirectionalLight = true;
(class extends pl {
  constructor(t2, e2) {
    super(t2, e2), this.type = "AmbientLight";
  }
}).prototype.isAmbientLight = true;
(class extends pl {
  constructor(t2, e2, n2 = 10, i2 = 10) {
    super(t2, e2), this.type = "RectAreaLight", this.width = n2, this.height = i2;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(t2) {
    this.intensity = t2 / (this.width * this.height * Math.PI);
  }
  copy(t2) {
    return super.copy(t2), this.width = t2.width, this.height = t2.height, this;
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    return e2.object.width = this.width, e2.object.height = this.height, e2;
  }
}).prototype.isRectAreaLight = true;
class Al {
  constructor() {
    this.coefficients = [];
    for (let t2 = 0; t2 < 9; t2++)
      this.coefficients.push(new At());
  }
  set(t2) {
    for (let e2 = 0; e2 < 9; e2++)
      this.coefficients[e2].copy(t2[e2]);
    return this;
  }
  zero() {
    for (let t2 = 0; t2 < 9; t2++)
      this.coefficients[t2].set(0, 0, 0);
    return this;
  }
  getAt(t2, e2) {
    const n2 = t2.x, i2 = t2.y, r2 = t2.z, s2 = this.coefficients;
    return e2.copy(s2[0]).multiplyScalar(0.282095), e2.addScaledVector(s2[1], 0.488603 * i2), e2.addScaledVector(s2[2], 0.488603 * r2), e2.addScaledVector(s2[3], 0.488603 * n2), e2.addScaledVector(s2[4], n2 * i2 * 1.092548), e2.addScaledVector(s2[5], i2 * r2 * 1.092548), e2.addScaledVector(s2[6], 0.315392 * (3 * r2 * r2 - 1)), e2.addScaledVector(s2[7], n2 * r2 * 1.092548), e2.addScaledVector(s2[8], 0.546274 * (n2 * n2 - i2 * i2)), e2;
  }
  getIrradianceAt(t2, e2) {
    const n2 = t2.x, i2 = t2.y, r2 = t2.z, s2 = this.coefficients;
    return e2.copy(s2[0]).multiplyScalar(0.886227), e2.addScaledVector(s2[1], 1.023328 * i2), e2.addScaledVector(s2[2], 1.023328 * r2), e2.addScaledVector(s2[3], 1.023328 * n2), e2.addScaledVector(s2[4], 0.858086 * n2 * i2), e2.addScaledVector(s2[5], 0.858086 * i2 * r2), e2.addScaledVector(s2[6], 0.743125 * r2 * r2 - 0.247708), e2.addScaledVector(s2[7], 0.858086 * n2 * r2), e2.addScaledVector(s2[8], 0.429043 * (n2 * n2 - i2 * i2)), e2;
  }
  add(t2) {
    for (let e2 = 0; e2 < 9; e2++)
      this.coefficients[e2].add(t2.coefficients[e2]);
    return this;
  }
  addScaledSH(t2, e2) {
    for (let n2 = 0; n2 < 9; n2++)
      this.coefficients[n2].addScaledVector(t2.coefficients[n2], e2);
    return this;
  }
  scale(t2) {
    for (let e2 = 0; e2 < 9; e2++)
      this.coefficients[e2].multiplyScalar(t2);
    return this;
  }
  lerp(t2, e2) {
    for (let n2 = 0; n2 < 9; n2++)
      this.coefficients[n2].lerp(t2.coefficients[n2], e2);
    return this;
  }
  equals(t2) {
    for (let e2 = 0; e2 < 9; e2++)
      if (!this.coefficients[e2].equals(t2.coefficients[e2]))
        return false;
    return true;
  }
  copy(t2) {
    return this.set(t2.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(t2, e2 = 0) {
    const n2 = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++)
      n2[i2].fromArray(t2, e2 + 3 * i2);
    return this;
  }
  toArray(t2 = [], e2 = 0) {
    const n2 = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++)
      n2[i2].toArray(t2, e2 + 3 * i2);
    return t2;
  }
  static getBasisAt(t2, e2) {
    const n2 = t2.x, i2 = t2.y, r2 = t2.z;
    e2[0] = 0.282095, e2[1] = 0.488603 * i2, e2[2] = 0.488603 * r2, e2[3] = 0.488603 * n2, e2[4] = 1.092548 * n2 * i2, e2[5] = 1.092548 * i2 * r2, e2[6] = 0.315392 * (3 * r2 * r2 - 1), e2[7] = 1.092548 * n2 * r2, e2[8] = 0.546274 * (n2 * n2 - i2 * i2);
  }
}
Al.prototype.isSphericalHarmonics3 = true;
class Rl extends pl {
  constructor(t2 = new Al(), e2 = 1) {
    super(void 0, e2), this.sh = t2;
  }
  copy(t2) {
    return super.copy(t2), this.sh.copy(t2.sh), this;
  }
  fromJSON(t2) {
    return this.intensity = t2.intensity, this.sh.fromArray(t2.sh), this;
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    return e2.object.sh = this.sh.toArray(), e2;
  }
}
Rl.prototype.isLightProbe = true;
class Ll {
  static decodeText(t2) {
    if (typeof TextDecoder != "undefined")
      return new TextDecoder().decode(t2);
    let e2 = "";
    for (let n2 = 0, i2 = t2.length; n2 < i2; n2++)
      e2 += String.fromCharCode(t2[n2]);
    try {
      return decodeURIComponent(escape(e2));
    } catch (t3) {
      return e2;
    }
  }
  static extractUrlBase(t2) {
    const e2 = t2.lastIndexOf("/");
    return e2 === -1 ? "./" : t2.substr(0, e2 + 1);
  }
  static resolveURL(t2, e2) {
    return typeof t2 != "string" || t2 === "" ? "" : (/^https?:\/\//i.test(e2) && /^\//.test(t2) && (e2 = e2.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t2) || /^data:.*,.*$/i.test(t2) || /^blob:.*$/i.test(t2) ? t2 : e2 + t2);
  }
}
(class extends un {
  constructor() {
    super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(t2) {
    return super.copy(t2), this.instanceCount = t2.instanceCount, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t2 = super.toJSON(this);
    return t2.instanceCount = this.instanceCount, t2.isInstancedBufferGeometry = true, t2;
  }
}).prototype.isInstancedBufferGeometry = true;
class Cl extends al {
  constructor(t2) {
    super(t2), typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(t2) {
    return this.options = t2, this;
  }
  load(t2, e2, n2, i2) {
    t2 === void 0 && (t2 = ""), this.path !== void 0 && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
    const r2 = this, s2 = rl.get(t2);
    if (s2 !== void 0)
      return r2.manager.itemStart(t2), setTimeout(function() {
        e2 && e2(s2), r2.manager.itemEnd(t2);
      }, 0), s2;
    const a2 = {};
    a2.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a2.headers = this.requestHeader, fetch(t2, a2).then(function(t3) {
      return t3.blob();
    }).then(function(t3) {
      return createImageBitmap(t3, Object.assign(r2.options, { colorSpaceConversion: "none" }));
    }).then(function(n3) {
      rl.add(t2, n3), e2 && e2(n3), r2.manager.itemEnd(t2);
    }).catch(function(e3) {
      i2 && i2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
    }), r2.manager.itemStart(t2);
  }
}
let Pl;
Cl.prototype.isImageBitmapLoader = true;
const Il = function() {
  return Pl === void 0 && (Pl = new (window.AudioContext || window.webkitAudioContext)()), Pl;
};
class Dl extends al {
  constructor(t2) {
    super(t2);
  }
  load(t2, e2, n2, i2) {
    const r2 = this, s2 = new ll(this.manager);
    s2.setResponseType("arraybuffer"), s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(t2, function(n3) {
      try {
        const t3 = n3.slice(0);
        Il().decodeAudioData(t3, function(t4) {
          e2(t4);
        });
      } catch (e3) {
        i2 ? i2(e3) : console.error(e3), r2.manager.itemError(t2);
      }
    }, n2, i2);
  }
}
(class extends Rl {
  constructor(t2, e2, n2 = 1) {
    super(void 0, n2);
    const i2 = new Ze().set(t2), r2 = new Ze().set(e2), s2 = new At(i2.r, i2.g, i2.b), a2 = new At(r2.r, r2.g, r2.b), o2 = Math.sqrt(Math.PI), l2 = o2 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(s2).add(a2).multiplyScalar(o2), this.sh.coefficients[1].copy(s2).sub(a2).multiplyScalar(l2);
  }
}).prototype.isHemisphereLightProbe = true;
(class extends Rl {
  constructor(t2, e2 = 1) {
    super(void 0, e2);
    const n2 = new Ze().set(t2);
    this.sh.coefficients[0].set(n2.r, n2.g, n2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}).prototype.isAmbientLightProbe = true;
class Nl {
  constructor(t2, e2, n2) {
    let i2, r2, s2;
    switch (this.binding = t2, this.valueSize = n2, e2) {
      case "quaternion":
        i2 = this._slerp, r2 = this._slerpAdditive, s2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n2), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i2 = this._select, r2 = this._select, s2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n2);
        break;
      default:
        i2 = this._lerp, r2 = this._lerpAdditive, s2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n2);
    }
    this._mixBufferRegion = i2, this._mixBufferRegionAdditive = r2, this._setIdentity = s2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(t2, e2) {
    const n2 = this.buffer, i2 = this.valueSize, r2 = t2 * i2 + i2;
    let s2 = this.cumulativeWeight;
    if (s2 === 0) {
      for (let t3 = 0; t3 !== i2; ++t3)
        n2[r2 + t3] = n2[t3];
      s2 = e2;
    } else {
      s2 += e2;
      const t3 = e2 / s2;
      this._mixBufferRegion(n2, r2, 0, t3, i2);
    }
    this.cumulativeWeight = s2;
  }
  accumulateAdditive(t2) {
    const e2 = this.buffer, n2 = this.valueSize, i2 = n2 * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e2, i2, 0, t2, n2), this.cumulativeWeightAdditive += t2;
  }
  apply(t2) {
    const e2 = this.valueSize, n2 = this.buffer, i2 = t2 * e2 + e2, r2 = this.cumulativeWeight, s2 = this.cumulativeWeightAdditive, a2 = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r2 < 1) {
      const t3 = e2 * this._origIndex;
      this._mixBufferRegion(n2, i2, t3, 1 - r2, e2);
    }
    s2 > 0 && this._mixBufferRegionAdditive(n2, i2, this._addIndex * e2, 1, e2);
    for (let t3 = e2, r3 = e2 + e2; t3 !== r3; ++t3)
      if (n2[t3] !== n2[t3 + e2]) {
        a2.setValue(n2, i2);
        break;
      }
  }
  saveOriginalState() {
    const t2 = this.binding, e2 = this.buffer, n2 = this.valueSize, i2 = n2 * this._origIndex;
    t2.getValue(e2, i2);
    for (let t3 = n2, r2 = i2; t3 !== r2; ++t3)
      e2[t3] = e2[i2 + t3 % n2];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const t2 = 3 * this.valueSize;
    this.binding.setValue(this.buffer, t2);
  }
  _setAdditiveIdentityNumeric() {
    const t2 = this._addIndex * this.valueSize, e2 = t2 + this.valueSize;
    for (let n2 = t2; n2 < e2; n2++)
      this.buffer[n2] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const t2 = this._origIndex * this.valueSize, e2 = this._addIndex * this.valueSize;
    for (let n2 = 0; n2 < this.valueSize; n2++)
      this.buffer[e2 + n2] = this.buffer[t2 + n2];
  }
  _select(t2, e2, n2, i2, r2) {
    if (i2 >= 0.5)
      for (let i3 = 0; i3 !== r2; ++i3)
        t2[e2 + i3] = t2[n2 + i3];
  }
  _slerp(t2, e2, n2, i2) {
    Et.slerpFlat(t2, e2, t2, e2, t2, n2, i2);
  }
  _slerpAdditive(t2, e2, n2, i2, r2) {
    const s2 = this._workIndex * r2;
    Et.multiplyQuaternionsFlat(t2, s2, t2, e2, t2, n2), Et.slerpFlat(t2, e2, t2, e2, t2, s2, i2);
  }
  _lerp(t2, e2, n2, i2, r2) {
    const s2 = 1 - i2;
    for (let a2 = 0; a2 !== r2; ++a2) {
      const r3 = e2 + a2;
      t2[r3] = t2[r3] * s2 + t2[n2 + a2] * i2;
    }
  }
  _lerpAdditive(t2, e2, n2, i2, r2) {
    for (let s2 = 0; s2 !== r2; ++s2) {
      const r3 = e2 + s2;
      t2[r3] = t2[r3] + t2[n2 + s2] * i2;
    }
  }
}
const Fl = new RegExp("[\\[\\]\\.:\\/]", "g"), Ol = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Ul = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), kl = /(WCOD+)?/.source.replace("WCOD", Ol), zl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Bl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Hl = new RegExp("^" + Ul + kl + zl + Bl + "$"), Vl = ["material", "materials", "bones"];
class Gl {
  constructor(t2, e2, n2) {
    this.path = e2, this.parsedPath = n2 || Gl.parseTrackName(e2), this.node = Gl.findNode(t2, this.parsedPath.nodeName) || t2, this.rootNode = t2, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(t2, e2, n2) {
    return t2 && t2.isAnimationObjectGroup ? new Gl.Composite(t2, e2, n2) : new Gl(t2, e2, n2);
  }
  static sanitizeNodeName(t2) {
    return t2.replace(/\s/g, "_").replace(Fl, "");
  }
  static parseTrackName(t2) {
    const e2 = Hl.exec(t2);
    if (!e2)
      throw new Error("PropertyBinding: Cannot parse trackName: " + t2);
    const n2 = { nodeName: e2[2], objectName: e2[3], objectIndex: e2[4], propertyName: e2[5], propertyIndex: e2[6] }, i2 = n2.nodeName && n2.nodeName.lastIndexOf(".");
    if (i2 !== void 0 && i2 !== -1) {
      const t3 = n2.nodeName.substring(i2 + 1);
      Vl.indexOf(t3) !== -1 && (n2.nodeName = n2.nodeName.substring(0, i2), n2.objectName = t3);
    }
    if (n2.propertyName === null || n2.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t2);
    return n2;
  }
  static findNode(t2, e2) {
    if (!e2 || e2 === "" || e2 === "." || e2 === -1 || e2 === t2.name || e2 === t2.uuid)
      return t2;
    if (t2.skeleton) {
      const n2 = t2.skeleton.getBoneByName(e2);
      if (n2 !== void 0)
        return n2;
    }
    if (t2.children) {
      const n2 = function(t3) {
        for (let i3 = 0; i3 < t3.length; i3++) {
          const r2 = t3[i3];
          if (r2.name === e2 || r2.uuid === e2)
            return r2;
          const s2 = n2(r2.children);
          if (s2)
            return s2;
        }
        return null;
      }, i2 = n2(t2.children);
      if (i2)
        return i2;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(t2, e2) {
    t2[e2] = this.targetObject[this.propertyName];
  }
  _getValue_array(t2, e2) {
    const n2 = this.resolvedProperty;
    for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2)
      t2[e2++] = n2[i2];
  }
  _getValue_arrayElement(t2, e2) {
    t2[e2] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t2, e2) {
    this.resolvedProperty.toArray(t2, e2);
  }
  _setValue_direct(t2, e2) {
    this.targetObject[this.propertyName] = t2[e2];
  }
  _setValue_direct_setNeedsUpdate(t2, e2) {
    this.targetObject[this.propertyName] = t2[e2], this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t2, e2) {
    this.targetObject[this.propertyName] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(t2, e2) {
    const n2 = this.resolvedProperty;
    for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2)
      n2[i2] = t2[e2++];
  }
  _setValue_array_setNeedsUpdate(t2, e2) {
    const n2 = this.resolvedProperty;
    for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2)
      n2[i2] = t2[e2++];
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t2, e2) {
    const n2 = this.resolvedProperty;
    for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2)
      n2[i2] = t2[e2++];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(t2, e2) {
    this.resolvedProperty[this.propertyIndex] = t2[e2];
  }
  _setValue_arrayElement_setNeedsUpdate(t2, e2) {
    this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t2, e2) {
    this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(t2, e2) {
    this.resolvedProperty.fromArray(t2, e2);
  }
  _setValue_fromArray_setNeedsUpdate(t2, e2) {
    this.resolvedProperty.fromArray(t2, e2), this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t2, e2) {
    this.resolvedProperty.fromArray(t2, e2), this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(t2, e2) {
    this.bind(), this.getValue(t2, e2);
  }
  _setValue_unbound(t2, e2) {
    this.bind(), this.setValue(t2, e2);
  }
  bind() {
    let t2 = this.node;
    const e2 = this.parsedPath, n2 = e2.objectName, i2 = e2.propertyName;
    let r2 = e2.propertyIndex;
    if (t2 || (t2 = Gl.findNode(this.rootNode, e2.nodeName) || this.rootNode, this.node = t2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t2)
      return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    if (n2) {
      let i3 = e2.objectIndex;
      switch (n2) {
        case "materials":
          if (!t2.material)
            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!t2.material.materials)
            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
          t2 = t2.material.materials;
          break;
        case "bones":
          if (!t2.skeleton)
            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
          t2 = t2.skeleton.bones;
          for (let e3 = 0; e3 < t2.length; e3++)
            if (t2[e3].name === i3) {
              i3 = e3;
              break;
            }
          break;
        default:
          if (t2[n2] === void 0)
            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
          t2 = t2[n2];
      }
      if (i3 !== void 0) {
        if (t2[i3] === void 0)
          return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t2);
        t2 = t2[i3];
      }
    }
    const s2 = t2[i2];
    if (s2 === void 0) {
      const n3 = e2.nodeName;
      return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n3 + "." + i2 + " but it wasn't found.", t2);
    }
    let a2 = this.Versioning.None;
    this.targetObject = t2, t2.needsUpdate !== void 0 ? a2 = this.Versioning.NeedsUpdate : t2.matrixWorldNeedsUpdate !== void 0 && (a2 = this.Versioning.MatrixWorldNeedsUpdate);
    let o2 = this.BindingType.Direct;
    if (r2 !== void 0) {
      if (i2 === "morphTargetInfluences") {
        if (!t2.geometry)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
        if (!t2.geometry.isBufferGeometry)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
        if (!t2.geometry.morphAttributes)
          return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
        t2.morphTargetDictionary[r2] !== void 0 && (r2 = t2.morphTargetDictionary[r2]);
      }
      o2 = this.BindingType.ArrayElement, this.resolvedProperty = s2, this.propertyIndex = r2;
    } else
      s2.fromArray !== void 0 && s2.toArray !== void 0 ? (o2 = this.BindingType.HasFromToArray, this.resolvedProperty = s2) : Array.isArray(s2) ? (o2 = this.BindingType.EntireArray, this.resolvedProperty = s2) : this.propertyName = i2;
    this.getValue = this.GetterByBindingType[o2], this.setValue = this.SetterByBindingTypeAndVersioning[o2][a2];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Gl.Composite = class {
  constructor(t2, e2, n2) {
    const i2 = n2 || Gl.parseTrackName(e2);
    this._targetGroup = t2, this._bindings = t2.subscribe_(e2, i2);
  }
  getValue(t2, e2) {
    this.bind();
    const n2 = this._targetGroup.nCachedObjects_, i2 = this._bindings[n2];
    i2 !== void 0 && i2.getValue(t2, e2);
  }
  setValue(t2, e2) {
    const n2 = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, r2 = n2.length; i2 !== r2; ++i2)
      n2[i2].setValue(t2, e2);
  }
  bind() {
    const t2 = this._bindings;
    for (let e2 = this._targetGroup.nCachedObjects_, n2 = t2.length; e2 !== n2; ++e2)
      t2[e2].bind();
  }
  unbind() {
    const t2 = this._bindings;
    for (let e2 = this._targetGroup.nCachedObjects_, n2 = t2.length; e2 !== n2; ++e2)
      t2[e2].unbind();
  }
}, Gl.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Gl.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Gl.prototype.GetterByBindingType = [Gl.prototype._getValue_direct, Gl.prototype._getValue_array, Gl.prototype._getValue_arrayElement, Gl.prototype._getValue_toArray], Gl.prototype.SetterByBindingTypeAndVersioning = [[Gl.prototype._setValue_direct, Gl.prototype._setValue_direct_setNeedsUpdate, Gl.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Gl.prototype._setValue_array, Gl.prototype._setValue_array_setNeedsUpdate, Gl.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Gl.prototype._setValue_arrayElement, Gl.prototype._setValue_arrayElement_setNeedsUpdate, Gl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Gl.prototype._setValue_fromArray, Gl.prototype._setValue_fromArray_setNeedsUpdate, Gl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class Wl {
  constructor(t2, e2, n2 = null, i2 = e2.blendMode) {
    this._mixer = t2, this._clip = e2, this._localRoot = n2, this.blendMode = i2;
    const r2 = e2.tracks, s2 = r2.length, a2 = new Array(s2), o2 = { endingStart: 2400, endingEnd: 2400 };
    for (let t3 = 0; t3 !== s2; ++t3) {
      const e3 = r2[t3].createInterpolant(null);
      a2[t3] = e3, e3.settings = o2;
    }
    this._interpolantSettings = o2, this._interpolants = a2, this._propertyBindings = new Array(s2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(t2) {
    return this._startTime = t2, this;
  }
  setLoop(t2, e2) {
    return this.loop = t2, this.repetitions = e2, this;
  }
  setEffectiveWeight(t2) {
    return this.weight = t2, this._effectiveWeight = this.enabled ? t2 : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(t2) {
    return this._scheduleFading(t2, 0, 1);
  }
  fadeOut(t2) {
    return this._scheduleFading(t2, 1, 0);
  }
  crossFadeFrom(t2, e2, n2) {
    if (t2.fadeOut(e2), this.fadeIn(e2), n2) {
      const n3 = this._clip.duration, i2 = t2._clip.duration, r2 = i2 / n3, s2 = n3 / i2;
      t2.warp(1, r2, e2), this.warp(s2, 1, e2);
    }
    return this;
  }
  crossFadeTo(t2, e2, n2) {
    return t2.crossFadeFrom(this, e2, n2);
  }
  stopFading() {
    const t2 = this._weightInterpolant;
    return t2 !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
  }
  setEffectiveTimeScale(t2) {
    return this.timeScale = t2, this._effectiveTimeScale = this.paused ? 0 : t2, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(t2) {
    return this.timeScale = this._clip.duration / t2, this.stopWarping();
  }
  syncWith(t2) {
    return this.time = t2.time, this.timeScale = t2.timeScale, this.stopWarping();
  }
  halt(t2) {
    return this.warp(this._effectiveTimeScale, 0, t2);
  }
  warp(t2, e2, n2) {
    const i2 = this._mixer, r2 = i2.time, s2 = this.timeScale;
    let a2 = this._timeScaleInterpolant;
    a2 === null && (a2 = i2._lendControlInterpolant(), this._timeScaleInterpolant = a2);
    const o2 = a2.parameterPositions, l2 = a2.sampleValues;
    return o2[0] = r2, o2[1] = r2 + n2, l2[0] = t2 / s2, l2[1] = e2 / s2, this;
  }
  stopWarping() {
    const t2 = this._timeScaleInterpolant;
    return t2 !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(t2, e2, n2, i2) {
    if (!this.enabled)
      return void this._updateWeight(t2);
    const r2 = this._startTime;
    if (r2 !== null) {
      const i3 = (t2 - r2) * n2;
      if (i3 < 0 || n2 === 0)
        return;
      this._startTime = null, e2 = n2 * i3;
    }
    e2 *= this._updateTimeScale(t2);
    const s2 = this._updateTime(e2), a2 = this._updateWeight(t2);
    if (a2 > 0) {
      const t3 = this._interpolants, e3 = this._propertyBindings;
      if (this.blendMode === 2501)
        for (let n3 = 0, i3 = t3.length; n3 !== i3; ++n3)
          t3[n3].evaluate(s2), e3[n3].accumulateAdditive(a2);
      else
        for (let n3 = 0, r3 = t3.length; n3 !== r3; ++n3)
          t3[n3].evaluate(s2), e3[n3].accumulate(i2, a2);
    }
  }
  _updateWeight(t2) {
    let e2 = 0;
    if (this.enabled) {
      e2 = this.weight;
      const n2 = this._weightInterpolant;
      if (n2 !== null) {
        const i2 = n2.evaluate(t2)[0];
        e2 *= i2, t2 > n2.parameterPositions[1] && (this.stopFading(), i2 === 0 && (this.enabled = false));
      }
    }
    return this._effectiveWeight = e2, e2;
  }
  _updateTimeScale(t2) {
    let e2 = 0;
    if (!this.paused) {
      e2 = this.timeScale;
      const n2 = this._timeScaleInterpolant;
      if (n2 !== null) {
        e2 *= n2.evaluate(t2)[0], t2 > n2.parameterPositions[1] && (this.stopWarping(), e2 === 0 ? this.paused = true : this.timeScale = e2);
      }
    }
    return this._effectiveTimeScale = e2, e2;
  }
  _updateTime(t2) {
    const e2 = this._clip.duration, n2 = this.loop;
    let i2 = this.time + t2, r2 = this._loopCount;
    const s2 = n2 === 2202;
    if (t2 === 0)
      return r2 === -1 ? i2 : s2 && (1 & r2) == 1 ? e2 - i2 : i2;
    if (n2 === 2200) {
      r2 === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
      t: {
        if (i2 >= e2)
          i2 = e2;
        else {
          if (!(i2 < 0)) {
            this.time = i2;
            break t;
          }
          i2 = 0;
        }
        this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = i2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 < 0 ? -1 : 1 });
      }
    } else {
      if (r2 === -1 && (t2 >= 0 ? (r2 = 0, this._setEndings(true, this.repetitions === 0, s2)) : this._setEndings(this.repetitions === 0, true, s2)), i2 >= e2 || i2 < 0) {
        const n3 = Math.floor(i2 / e2);
        i2 -= e2 * n3, r2 += Math.abs(n3);
        const a2 = this.repetitions - r2;
        if (a2 <= 0)
          this.clampWhenFinished ? this.paused = true : this.enabled = false, i2 = t2 > 0 ? e2 : 0, this.time = i2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 > 0 ? 1 : -1 });
        else {
          if (a2 === 1) {
            const e3 = t2 < 0;
            this._setEndings(e3, !e3, s2);
          } else
            this._setEndings(false, false, s2);
          this._loopCount = r2, this.time = i2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n3 });
        }
      } else
        this.time = i2;
      if (s2 && (1 & r2) == 1)
        return e2 - i2;
    }
    return i2;
  }
  _setEndings(t2, e2, n2) {
    const i2 = this._interpolantSettings;
    n2 ? (i2.endingStart = 2401, i2.endingEnd = 2401) : (i2.endingStart = t2 ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i2.endingEnd = e2 ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
  }
  _scheduleFading(t2, e2, n2) {
    const i2 = this._mixer, r2 = i2.time;
    let s2 = this._weightInterpolant;
    s2 === null && (s2 = i2._lendControlInterpolant(), this._weightInterpolant = s2);
    const a2 = s2.parameterPositions, o2 = s2.sampleValues;
    return a2[0] = r2, o2[0] = e2, a2[1] = r2 + t2, o2[1] = n2, this;
  }
}
class jl extends et {
  constructor(t2) {
    super(), this._root = t2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(t2, e2) {
    const n2 = t2._localRoot || this._root, i2 = t2._clip.tracks, r2 = i2.length, s2 = t2._propertyBindings, a2 = t2._interpolants, o2 = n2.uuid, l2 = this._bindingsByRootAndName;
    let c2 = l2[o2];
    c2 === void 0 && (c2 = {}, l2[o2] = c2);
    for (let t3 = 0; t3 !== r2; ++t3) {
      const r3 = i2[t3], l3 = r3.name;
      let h2 = c2[l3];
      if (h2 !== void 0)
        s2[t3] = h2;
      else {
        if (h2 = s2[t3], h2 !== void 0) {
          h2._cacheIndex === null && (++h2.referenceCount, this._addInactiveBinding(h2, o2, l3));
          continue;
        }
        const i3 = e2 && e2._propertyBindings[t3].binding.parsedPath;
        h2 = new Nl(Gl.create(n2, l3, i3), r3.ValueTypeName, r3.getValueSize()), ++h2.referenceCount, this._addInactiveBinding(h2, o2, l3), s2[t3] = h2;
      }
      a2[t3].resultBuffer = h2.buffer;
    }
  }
  _activateAction(t2) {
    if (!this._isActiveAction(t2)) {
      if (t2._cacheIndex === null) {
        const e3 = (t2._localRoot || this._root).uuid, n2 = t2._clip.uuid, i2 = this._actionsByClip[n2];
        this._bindAction(t2, i2 && i2.knownActions[0]), this._addInactiveAction(t2, n2, e3);
      }
      const e2 = t2._propertyBindings;
      for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
        const n3 = e2[t3];
        n3.useCount++ == 0 && (this._lendBinding(n3), n3.saveOriginalState());
      }
      this._lendAction(t2);
    }
  }
  _deactivateAction(t2) {
    if (this._isActiveAction(t2)) {
      const e2 = t2._propertyBindings;
      for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
        const n3 = e2[t3];
        --n3.useCount == 0 && (n3.restoreOriginalState(), this._takeBackBinding(n3));
      }
      this._takeBackAction(t2);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const t2 = this;
    this.stats = { actions: { get total() {
      return t2._actions.length;
    }, get inUse() {
      return t2._nActiveActions;
    } }, bindings: { get total() {
      return t2._bindings.length;
    }, get inUse() {
      return t2._nActiveBindings;
    } }, controlInterpolants: { get total() {
      return t2._controlInterpolants.length;
    }, get inUse() {
      return t2._nActiveControlInterpolants;
    } } };
  }
  _isActiveAction(t2) {
    const e2 = t2._cacheIndex;
    return e2 !== null && e2 < this._nActiveActions;
  }
  _addInactiveAction(t2, e2, n2) {
    const i2 = this._actions, r2 = this._actionsByClip;
    let s2 = r2[e2];
    if (s2 === void 0)
      s2 = { knownActions: [t2], actionByRoot: {} }, t2._byClipCacheIndex = 0, r2[e2] = s2;
    else {
      const e3 = s2.knownActions;
      t2._byClipCacheIndex = e3.length, e3.push(t2);
    }
    t2._cacheIndex = i2.length, i2.push(t2), s2.actionByRoot[n2] = t2;
  }
  _removeInactiveAction(t2) {
    const e2 = this._actions, n2 = e2[e2.length - 1], i2 = t2._cacheIndex;
    n2._cacheIndex = i2, e2[i2] = n2, e2.pop(), t2._cacheIndex = null;
    const r2 = t2._clip.uuid, s2 = this._actionsByClip, a2 = s2[r2], o2 = a2.knownActions, l2 = o2[o2.length - 1], c2 = t2._byClipCacheIndex;
    l2._byClipCacheIndex = c2, o2[c2] = l2, o2.pop(), t2._byClipCacheIndex = null;
    delete a2.actionByRoot[(t2._localRoot || this._root).uuid], o2.length === 0 && delete s2[r2], this._removeInactiveBindingsForAction(t2);
  }
  _removeInactiveBindingsForAction(t2) {
    const e2 = t2._propertyBindings;
    for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
      const n3 = e2[t3];
      --n3.referenceCount == 0 && this._removeInactiveBinding(n3);
    }
  }
  _lendAction(t2) {
    const e2 = this._actions, n2 = t2._cacheIndex, i2 = this._nActiveActions++, r2 = e2[i2];
    t2._cacheIndex = i2, e2[i2] = t2, r2._cacheIndex = n2, e2[n2] = r2;
  }
  _takeBackAction(t2) {
    const e2 = this._actions, n2 = t2._cacheIndex, i2 = --this._nActiveActions, r2 = e2[i2];
    t2._cacheIndex = i2, e2[i2] = t2, r2._cacheIndex = n2, e2[n2] = r2;
  }
  _addInactiveBinding(t2, e2, n2) {
    const i2 = this._bindingsByRootAndName, r2 = this._bindings;
    let s2 = i2[e2];
    s2 === void 0 && (s2 = {}, i2[e2] = s2), s2[n2] = t2, t2._cacheIndex = r2.length, r2.push(t2);
  }
  _removeInactiveBinding(t2) {
    const e2 = this._bindings, n2 = t2.binding, i2 = n2.rootNode.uuid, r2 = n2.path, s2 = this._bindingsByRootAndName, a2 = s2[i2], o2 = e2[e2.length - 1], l2 = t2._cacheIndex;
    o2._cacheIndex = l2, e2[l2] = o2, e2.pop(), delete a2[r2], Object.keys(a2).length === 0 && delete s2[i2];
  }
  _lendBinding(t2) {
    const e2 = this._bindings, n2 = t2._cacheIndex, i2 = this._nActiveBindings++, r2 = e2[i2];
    t2._cacheIndex = i2, e2[i2] = t2, r2._cacheIndex = n2, e2[n2] = r2;
  }
  _takeBackBinding(t2) {
    const e2 = this._bindings, n2 = t2._cacheIndex, i2 = --this._nActiveBindings, r2 = e2[i2];
    t2._cacheIndex = i2, e2[i2] = t2, r2._cacheIndex = n2, e2[n2] = r2;
  }
  _lendControlInterpolant() {
    const t2 = this._controlInterpolants, e2 = this._nActiveControlInterpolants++;
    let n2 = t2[e2];
    return n2 === void 0 && (n2 = new qo(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n2.__cacheIndex = e2, t2[e2] = n2), n2;
  }
  _takeBackControlInterpolant(t2) {
    const e2 = this._controlInterpolants, n2 = t2.__cacheIndex, i2 = --this._nActiveControlInterpolants, r2 = e2[i2];
    t2.__cacheIndex = i2, e2[i2] = t2, r2.__cacheIndex = n2, e2[n2] = r2;
  }
  clipAction(t2, e2, n2) {
    const i2 = e2 || this._root, r2 = i2.uuid;
    let s2 = typeof t2 == "string" ? nl.findByName(i2, t2) : t2;
    const a2 = s2 !== null ? s2.uuid : t2, o2 = this._actionsByClip[a2];
    let l2 = null;
    if (n2 === void 0 && (n2 = s2 !== null ? s2.blendMode : 2500), o2 !== void 0) {
      const t3 = o2.actionByRoot[r2];
      if (t3 !== void 0 && t3.blendMode === n2)
        return t3;
      l2 = o2.knownActions[0], s2 === null && (s2 = l2._clip);
    }
    if (s2 === null)
      return null;
    const c2 = new Wl(this, s2, e2, n2);
    return this._bindAction(c2, l2), this._addInactiveAction(c2, a2, r2), c2;
  }
  existingAction(t2, e2) {
    const n2 = e2 || this._root, i2 = n2.uuid, r2 = typeof t2 == "string" ? nl.findByName(n2, t2) : t2, s2 = r2 ? r2.uuid : t2, a2 = this._actionsByClip[s2];
    return a2 !== void 0 && a2.actionByRoot[i2] || null;
  }
  stopAllAction() {
    const t2 = this._actions;
    for (let e2 = this._nActiveActions - 1; e2 >= 0; --e2)
      t2[e2].stop();
    return this;
  }
  update(t2) {
    t2 *= this.timeScale;
    const e2 = this._actions, n2 = this._nActiveActions, i2 = this.time += t2, r2 = Math.sign(t2), s2 = this._accuIndex ^= 1;
    for (let a3 = 0; a3 !== n2; ++a3) {
      e2[a3]._update(i2, t2, r2, s2);
    }
    const a2 = this._bindings, o2 = this._nActiveBindings;
    for (let t3 = 0; t3 !== o2; ++t3)
      a2[t3].apply(s2);
    return this;
  }
  setTime(t2) {
    this.time = 0;
    for (let t3 = 0; t3 < this._actions.length; t3++)
      this._actions[t3].time = 0;
    return this.update(t2);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(t2) {
    const e2 = this._actions, n2 = t2.uuid, i2 = this._actionsByClip, r2 = i2[n2];
    if (r2 !== void 0) {
      const t3 = r2.knownActions;
      for (let n3 = 0, i3 = t3.length; n3 !== i3; ++n3) {
        const i4 = t3[n3];
        this._deactivateAction(i4);
        const r3 = i4._cacheIndex, s2 = e2[e2.length - 1];
        i4._cacheIndex = null, i4._byClipCacheIndex = null, s2._cacheIndex = r3, e2[r3] = s2, e2.pop(), this._removeInactiveBindingsForAction(i4);
      }
      delete i2[n2];
    }
  }
  uncacheRoot(t2) {
    const e2 = t2.uuid, n2 = this._actionsByClip;
    for (const t3 in n2) {
      const i3 = n2[t3].actionByRoot[e2];
      i3 !== void 0 && (this._deactivateAction(i3), this._removeInactiveAction(i3));
    }
    const i2 = this._bindingsByRootAndName[e2];
    if (i2 !== void 0)
      for (const t3 in i2) {
        const e3 = i2[t3];
        e3.restoreOriginalState(), this._removeInactiveBinding(e3);
      }
  }
  uncacheAction(t2, e2) {
    const n2 = this.existingAction(t2, e2);
    n2 !== null && (this._deactivateAction(n2), this._removeInactiveAction(n2));
  }
}
jl.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
(class extends Hs {
  constructor(t2, e2, n2 = 1) {
    super(t2, e2), this.meshPerAttribute = n2;
  }
  copy(t2) {
    return super.copy(t2), this.meshPerAttribute = t2.meshPerAttribute, this;
  }
  clone(t2) {
    const e2 = super.clone(t2);
    return e2.meshPerAttribute = this.meshPerAttribute, e2;
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    return e2.isInstancedInterleavedBuffer = true, e2.meshPerAttribute = this.meshPerAttribute, e2;
  }
}).prototype.isInstancedInterleavedBuffer = true;
function ql(t2, e2) {
  return t2.distance - e2.distance;
}
function Xl(t2, e2, n2, i2) {
  if (t2.layers.test(e2.layers) && t2.raycast(e2, n2), i2 === true) {
    const i3 = t2.children;
    for (let t3 = 0, r2 = i3.length; t3 < r2; t3++)
      Xl(i3[t3], e2, n2, true);
  }
}
class Yl {
  constructor(t2 = 1, e2 = 0, n2 = 0) {
    return this.radius = t2, this.phi = e2, this.theta = n2, this;
  }
  set(t2, e2, n2) {
    return this.radius = t2, this.phi = e2, this.theta = n2, this;
  }
  copy(t2) {
    return this.radius = t2.radius, this.phi = t2.phi, this.theta = t2.theta, this;
  }
  makeSafe() {
    const t2 = 1e-6;
    return this.phi = Math.max(t2, Math.min(Math.PI - t2, this.phi)), this;
  }
  setFromVector3(t2) {
    return this.setFromCartesianCoords(t2.x, t2.y, t2.z);
  }
  setFromCartesianCoords(t2, e2, n2) {
    return this.radius = Math.sqrt(t2 * t2 + e2 * e2 + n2 * n2), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t2, n2), this.phi = Math.acos(ot(e2 / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Zl = new At(), Jl = new re(), $l = new re();
function Kl(t2) {
  const e2 = [];
  t2 && t2.isBone && e2.push(t2);
  for (let n2 = 0; n2 < t2.children.length; n2++)
    e2.push.apply(e2, Kl(t2.children[n2]));
  return e2;
}
const Ql = new Float32Array(1), tc = new Int32Array(Ql.buffer);
class ec {
  static toHalfFloat(t2) {
    t2 > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), t2 = 65504), Ql[0] = t2;
    const e2 = tc[0];
    let n2 = e2 >> 16 & 32768, i2 = e2 >> 12 & 2047;
    const r2 = e2 >> 23 & 255;
    return r2 < 103 ? n2 : r2 > 142 ? (n2 |= 31744, n2 |= (r2 == 255 ? 0 : 1) && 8388607 & e2, n2) : r2 < 113 ? (i2 |= 2048, n2 |= (i2 >> 114 - r2) + (i2 >> 113 - r2 & 1), n2) : (n2 |= r2 - 112 << 10 | i2 >> 1, n2 += 1 & i2, n2);
  }
}
Ba.create = function(t2, e2) {
  return console.log("THREE.Curve.create() has been deprecated"), t2.prototype = Object.create(Ba.prototype), t2.prototype.constructor = t2, t2.prototype.getPoint = e2, t2;
}, ao.prototype.fromPoints = function(t2) {
  return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t2);
}, class extends Ca {
  constructor(t2 = 10, e2 = 10, n2 = 4473924, i2 = 8947848) {
    n2 = new Ze(n2), i2 = new Ze(i2);
    const r2 = e2 / 2, s2 = t2 / e2, a2 = t2 / 2, o2 = [], l2 = [];
    for (let t3 = 0, c3 = 0, h2 = -a2; t3 <= e2; t3++, h2 += s2) {
      o2.push(-a2, 0, h2, a2, 0, h2), o2.push(h2, 0, -a2, h2, 0, a2);
      const e3 = t3 === r2 ? n2 : i2;
      e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3;
    }
    const c2 = new un();
    c2.setAttribute("position", new nn(o2, 3)), c2.setAttribute("color", new nn(l2, 3));
    super(c2, new wa({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
  }
}.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
}, class extends Ca {
  constructor(t2) {
    const e2 = Kl(t2), n2 = new un(), i2 = [], r2 = [], s2 = new Ze(0, 0, 1), a2 = new Ze(0, 1, 0);
    for (let t3 = 0; t3 < e2.length; t3++) {
      const n3 = e2[t3];
      n3.parent && n3.parent.isBone && (i2.push(0, 0, 0), i2.push(0, 0, 0), r2.push(s2.r, s2.g, s2.b), r2.push(a2.r, a2.g, a2.b));
    }
    n2.setAttribute("position", new nn(i2, 3)), n2.setAttribute("color", new nn(r2, 3));
    super(n2, new wa({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t2, this.bones = e2, this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(t2) {
    const e2 = this.bones, n2 = this.geometry, i2 = n2.getAttribute("position");
    $l.copy(this.root.matrixWorld).invert();
    for (let t3 = 0, n3 = 0; t3 < e2.length; t3++) {
      const r2 = e2[t3];
      r2.parent && r2.parent.isBone && (Jl.multiplyMatrices($l, r2.matrixWorld), Zl.setFromMatrixPosition(Jl), i2.setXYZ(n3, Zl.x, Zl.y, Zl.z), Jl.multiplyMatrices($l, r2.parent.matrixWorld), Zl.setFromMatrixPosition(Jl), i2.setXYZ(n3 + 1, Zl.x, Zl.y, Zl.z), n3 += 2);
    }
    n2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t2);
  }
}.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
}, al.prototype.extractUrlBase = function(t2) {
  return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ll.extractUrlBase(t2);
}, al.Handlers = { add: function() {
  console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
}, get: function() {
  console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
} }, Ct.prototype.center = function(t2) {
  return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t2);
}, Ct.prototype.empty = function() {
  return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}, Ct.prototype.isIntersectionBox = function(t2) {
  return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
}, Ct.prototype.isIntersectionSphere = function(t2) {
  return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
}, Ct.prototype.size = function(t2) {
  return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t2);
}, Zt.prototype.empty = function() {
  return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}, Xn.prototype.setFromMatrix = function(t2) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t2);
}, ft.prototype.flattenToArrayOffset = function(t2, e2) {
  return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
}, ft.prototype.multiplyVector3 = function(t2) {
  return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
}, ft.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
}, ft.prototype.applyToBufferAttribute = function(t2) {
  return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
}, ft.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
}, ft.prototype.getInverse = function(t2) {
  return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
}, re.prototype.extractPosition = function(t2) {
  return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t2);
}, re.prototype.flattenToArrayOffset = function(t2, e2) {
  return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
}, re.prototype.getPosition = function() {
  return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new At().setFromMatrixColumn(this, 3);
}, re.prototype.setRotationFromQuaternion = function(t2) {
  return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t2);
}, re.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
}, re.prototype.multiplyVector3 = function(t2) {
  return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
}, re.prototype.multiplyVector4 = function(t2) {
  return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
}, re.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
}, re.prototype.rotateAxis = function(t2) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t2.transformDirection(this);
}, re.prototype.crossVector = function(t2) {
  return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
}, re.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
}, re.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
}, re.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
}, re.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
}, re.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
}, re.prototype.applyToBufferAttribute = function(t2) {
  return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
}, re.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
}, re.prototype.makeFrustum = function(t2, e2, n2, i2, r2, s2) {
  return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t2, e2, i2, n2, r2, s2);
}, re.prototype.getInverse = function(t2) {
  return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
}, Wn.prototype.isIntersectionLine = function(t2) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t2);
}, Et.prototype.multiplyVector3 = function(t2) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t2.applyQuaternion(this);
}, Et.prototype.inverse = function() {
  return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
}, ie.prototype.isIntersectionBox = function(t2) {
  return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
}, ie.prototype.isIntersectionPlane = function(t2) {
  return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t2);
}, ie.prototype.isIntersectionSphere = function(t2) {
  return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
}, Be.prototype.area = function() {
  return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
}, Be.prototype.barycoordFromPoint = function(t2, e2) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t2, e2);
}, Be.prototype.midpoint = function(t2) {
  return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t2);
}, Be.prototypenormal = function(t2) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t2);
}, Be.prototype.plane = function(t2) {
  return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t2);
}, Be.barycoordFromPoint = function(t2, e2, n2, i2, r2) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Be.getBarycoord(t2, e2, n2, i2, r2);
}, Be.normal = function(t2, e2, n2, i2) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Be.getNormal(t2, e2, n2, i2);
}, oo.prototype.extractAllPoints = function(t2) {
  return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t2);
}, oo.prototype.extrude = function(t2) {
  return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Uo(this, t2);
}, oo.prototype.makeGeometry = function(t2) {
  return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new zo(this, t2);
}, mt.prototype.fromAttribute = function(t2, e2, n2) {
  return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
}, mt.prototype.distanceToManhattan = function(t2) {
  return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
}, mt.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, At.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
}, At.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
}, At.prototype.getPositionFromMatrix = function(t2) {
  return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t2);
}, At.prototype.getScaleFromMatrix = function(t2) {
  return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t2);
}, At.prototype.getColumnFromMatrix = function(t2, e2) {
  return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e2, t2);
}, At.prototype.applyProjection = function(t2) {
  return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t2);
}, At.prototype.fromAttribute = function(t2, e2, n2) {
  return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
}, At.prototype.distanceToManhattan = function(t2) {
  return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
}, At.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, Mt.prototype.fromAttribute = function(t2, e2, n2) {
  return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
}, Mt.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, Le.prototype.getChildByName = function(t2) {
  return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t2);
}, Le.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
}, Le.prototype.translate = function(t2, e2) {
  return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e2, t2);
}, Le.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
}, Le.prototype.applyMatrix = function(t2) {
  return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
}, Object.defineProperties(Le.prototype, { eulerOrder: { get: function() {
  return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
}, set: function(t2) {
  console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t2;
} }, useQuaternion: { get: function() {
  console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
}, set: function() {
  console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
} } }), Ln.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
}, Object.defineProperties(Ln.prototype, { drawMode: { get: function() {
  return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
}, set: function() {
  console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
} } }), ha.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
}, Un.prototype.setLens = function(t2, e2) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e2 !== void 0 && (this.filmGauge = e2), this.setFocalLength(t2);
}, Object.defineProperties(pl.prototype, { onlyShadow: { set: function() {
  console.warn("THREE.Light: .onlyShadow has been removed.");
} }, shadowCameraFov: { set: function(t2) {
  console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t2;
} }, shadowCameraLeft: { set: function(t2) {
  console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t2;
} }, shadowCameraRight: { set: function(t2) {
  console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t2;
} }, shadowCameraTop: { set: function(t2) {
  console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t2;
} }, shadowCameraBottom: { set: function(t2) {
  console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t2;
} }, shadowCameraNear: { set: function(t2) {
  console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t2;
} }, shadowCameraFar: { set: function(t2) {
  console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t2;
} }, shadowCameraVisible: { set: function() {
  console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
} }, shadowBias: { set: function(t2) {
  console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t2;
} }, shadowDarkness: { set: function() {
  console.warn("THREE.Light: .shadowDarkness has been removed.");
} }, shadowMapWidth: { set: function(t2) {
  console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t2;
} }, shadowMapHeight: { set: function(t2) {
  console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t2;
} } }), Object.defineProperties(Qe.prototype, { length: { get: function() {
  return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
} }, dynamic: { get: function() {
  return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === 35048;
}, set: function() {
  console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048);
} } }), Qe.prototype.setDynamic = function(t2) {
  return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t2 === true ? 35048 : 35044), this;
}, Qe.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, Qe.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
}, un.prototype.addIndex = function(t2) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t2);
}, un.prototype.addAttribute = function(t2, e2) {
  return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e2 && e2.isBufferAttribute || e2 && e2.isInterleavedBufferAttribute ? t2 === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e2), this) : this.setAttribute(t2, e2) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t2, new Qe(arguments[1], arguments[2])));
}, un.prototype.addDrawCall = function(t2, e2, n2) {
  n2 !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t2, e2);
}, un.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
}, un.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
}, un.prototype.removeAttribute = function(t2) {
  return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t2);
}, un.prototype.applyMatrix = function(t2) {
  return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
}, Object.defineProperties(un.prototype, { drawcalls: { get: function() {
  return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
} }, offsets: { get: function() {
  return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
} } }), Hs.prototype.setDynamic = function(t2) {
  return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t2 === true ? 35048 : 35044), this;
}, Hs.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
}, Uo.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
}, Uo.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
}, Uo.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
}, Bs.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
}, Object.defineProperties(Ve.prototype, { wrapAround: { get: function() {
  console.warn("THREE.Material: .wrapAround has been removed.");
}, set: function() {
  console.warn("THREE.Material: .wrapAround has been removed.");
} }, overdraw: { get: function() {
  console.warn("THREE.Material: .overdraw has been removed.");
}, set: function() {
  console.warn("THREE.Material: .overdraw has been removed.");
} }, wrapRGB: { get: function() {
  return console.warn("THREE.Material: .wrapRGB has been removed."), new Ze();
} }, shading: { get: function() {
  console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
}, set: function(t2) {
  console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t2 === 1;
} }, stencilMask: { get: function() {
  return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
}, set: function(t2) {
  console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t2;
} }, vertexTangents: { get: function() {
  console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
}, set: function() {
  console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
} } }), Object.defineProperties(Fn.prototype, { derivatives: { get: function() {
  return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
}, set: function(t2) {
  console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t2;
} } }), zs.prototype.clearTarget = function(t2, e2, n2, i2) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t2), this.clear(e2, n2, i2);
}, zs.prototype.animate = function(t2) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t2);
}, zs.prototype.getCurrentRenderTarget = function() {
  return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
}, zs.prototype.getMaxAnisotropy = function() {
  return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
}, zs.prototype.getPrecision = function() {
  return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
}, zs.prototype.resetGLState = function() {
  return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
}, zs.prototype.supportsFloatTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
}, zs.prototype.supportsHalfFloatTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
}, zs.prototype.supportsStandardDerivatives = function() {
  return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
}, zs.prototype.supportsCompressedTextureS3TC = function() {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
}, zs.prototype.supportsCompressedTexturePVRTC = function() {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
}, zs.prototype.supportsBlendMinMax = function() {
  return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
}, zs.prototype.supportsVertexTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
}, zs.prototype.supportsInstancedArrays = function() {
  return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
}, zs.prototype.enableScissorTest = function(t2) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t2);
}, zs.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
}, zs.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
}, zs.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
}, zs.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
}, zs.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
}, zs.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
}, zs.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
}, zs.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
}, zs.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
}, zs.prototype.getActiveMipMapLevel = function() {
  return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
}, Object.defineProperties(zs.prototype, { shadowMapEnabled: { get: function() {
  return this.shadowMap.enabled;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t2;
} }, shadowMapType: { get: function() {
  return this.shadowMap.type;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t2;
} }, shadowMapCullFace: { get: function() {
  console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
}, set: function() {
  console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
} }, context: { get: function() {
  return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
} }, vr: { get: function() {
  return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
} }, gammaInput: { get: function() {
  return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
}, set: function() {
  console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
} }, gammaOutput: { get: function() {
  return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = t2 === true ? 3001 : 3e3;
} }, toneMappingWhitePoint: { get: function() {
  return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
}, set: function() {
  console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
} }, gammaFactor: { get: function() {
  return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
}, set: function() {
  console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
} } }), Object.defineProperties(Rs.prototype, { cullFace: { get: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
}, set: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
} }, renderReverseSided: { get: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
}, set: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
} }, renderSingleSided: { get: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
}, set: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
} } }), Object.defineProperties(St.prototype, { wrapS: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t2;
} }, wrapT: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t2;
} }, magFilter: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t2;
} }, minFilter: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t2;
} }, anisotropy: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t2;
} }, offset: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t2;
} }, repeat: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t2;
} }, format: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t2;
} }, type: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t2;
} }, generateMipmaps: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
}, set: function(t2) {
  console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t2;
} } }), class extends Le {
  constructor(t2) {
    super(), this.type = "Audio", this.listener = t2, this.context = t2.context, this.gain = this.context.createGain(), this.gain.connect(t2.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(t2) {
    return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t2, this.connect(), this;
  }
  setMediaElementSource(t2) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t2), this.connect(), this;
  }
  setMediaStreamSource(t2) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t2), this.connect(), this;
  }
  setBuffer(t2) {
    return this.buffer = t2, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(t2 = 0) {
    if (this.isPlaying === true)
      return void console.warn("THREE.Audio: Audio is already playing.");
    if (this.hasPlaybackControl === false)
      return void console.warn("THREE.Audio: this Audio has no playback control.");
    this._startedAt = this.context.currentTime + t2;
    const e2 = this.context.createBufferSource();
    return e2.buffer = this.buffer, e2.loop = this.loop, e2.loopStart = this.loopStart, e2.loopEnd = this.loopEnd, e2.onended = this.onEnded.bind(this), e2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl !== false)
      return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  stop() {
    if (this.hasPlaybackControl !== false)
      return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++)
        this.filters[t2 - 1].connect(this.filters[t2]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = true, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++)
        this.filters[t2 - 1].disconnect(this.filters[t2]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = false, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(t2) {
    return t2 || (t2 = []), this._connected === true ? (this.disconnect(), this.filters = t2.slice(), this.connect()) : this.filters = t2.slice(), this;
  }
  setDetune(t2) {
    if (this.detune = t2, this.source.detune !== void 0)
      return this.isPlaying === true && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(t2) {
    return this.setFilters(t2 ? [t2] : []);
  }
  setPlaybackRate(t2) {
    if (this.hasPlaybackControl !== false)
      return this.playbackRate = t2, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
  }
  setLoop(t2) {
    if (this.hasPlaybackControl !== false)
      return this.loop = t2, this.isPlaying === true && (this.source.loop = this.loop), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  setLoopStart(t2) {
    return this.loopStart = t2, this;
  }
  setLoopEnd(t2) {
    return this.loopEnd = t2, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(t2) {
    return this.gain.gain.setTargetAtTime(t2, this.context.currentTime, 0.01), this;
  }
}.prototype.load = function(t2) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const e2 = this;
  return new Dl().load(t2, function(t3) {
    e2.setBuffer(t3);
  }), this;
}, kn.prototype.updateCubeMap = function(t2, e2) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t2, e2);
}, kn.prototype.clear = function(t2, e2, n2, i2) {
  return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t2, e2, n2, i2);
}, xt.crossOrigin = void 0, xt.loadTexture = function(t2, e2, n2, i2) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const r2 = new dl();
  r2.setCrossOrigin(this.crossOrigin);
  const s2 = r2.load(t2, n2, void 0, i2);
  return e2 && (s2.mapping = e2), s2;
}, xt.loadTextureCube = function(t2, e2, n2, i2) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const r2 = new hl();
  r2.setCrossOrigin(this.crossOrigin);
  const s2 = r2.load(t2, n2, void 0, i2);
  return e2 && (s2.mapping = e2), s2;
}, xt.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
}, xt.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
}, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "136" } })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "136");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nc = navigator.xr != null && self.XRSession != null && navigator.xr.isSessionSupported != null, ic = nc && self.XRSession.prototype.requestHitTestSource, rc = self.ResizeObserver != null, sc = self.IntersectionObserver != null, ac = ic;
(() => {
  const t2 = navigator.userAgent || navigator.vendor || self.opera;
  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t2.substr(0, 4))) && true;
})(), /\bCrOS\b/.test(navigator.userAgent);
const oc = /android/i.test(navigator.userAgent), lc = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1, cc = (() => {
  const t2 = document.createElement("a");
  return Boolean(t2.relList && t2.relList.supports && t2.relList.supports("ar"));
})();
/Safari\//.test(navigator.userAgent);
const hc = /firefox/i.test(navigator.userAgent), uc = /OculusBrowser/.test(navigator.userAgent);
lc && /CriOS\//.test(navigator.userAgent);
const dc = oc && !hc && !uc;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pc = U`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

/* NOTE: This ruleset is our integration surface area with the
 * :focus-visible polyfill.
 *
 * @see https://github.com/WICG/focus-visible/pull/196 */
:host([data-js-focus-visible]:focus:not(.focus-visible)),
:host([data-js-focus-visible]) :focus:not(.focus-visible) {
  outline: none;
}

.container {
  position: relative;
}

.userInput {
  width: 100%;
  height: 100%;
  display: block;
  position: relative;
  overflow: hidden;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

canvas.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  opacity: 0;
  transition: opacity 0.3s 0.3s;
  background-color: inherit;
}

.slot.poster.show {
  opacity: 1;
  transition: none;
}

.slot.poster.quick {
  transition: none;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: var(--poster-color, #fff);
  background-image: var(--poster-image, none);
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .mask {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--progress-mask, #fff);
  transition: opacity 0.3s;
  opacity: 0.2;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  align-items: center;
  justify-content: center;

  opacity: 0;
  will-change: opacity;
  overflow: hidden;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.slot.interaction-prompt > .animated-container {
  will-change: transform, opacity;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 16px;
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="A depiction of a 3D model"
      aria-live="polite">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>
  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          aria-label="View this 3D model up close">
        ${U`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`}
      </a>
    </slot>
  </div>

  <div class="slot interaction-prompt">
    <div class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${U`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`}
      </slot>
    </div>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="mask" part="default-progress-mask"></div>
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>
    
    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${U`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`}
        </a>
      </slot>
    </div>
  </div>
</div>`, mc = /* @__PURE__ */ new WeakMap();
function fc() {
  let t2, e2;
  function n2(t3, e3, n3, i2, r2, s2) {
    const a2 = s2.num_components(), o2 = n3.num_points() * a2, l2 = o2 * r2.BYTES_PER_ELEMENT, c2 = function(t4, e4) {
      switch (e4) {
        case Float32Array:
          return t4.DT_FLOAT32;
        case Int8Array:
          return t4.DT_INT8;
        case Int16Array:
          return t4.DT_INT16;
        case Int32Array:
          return t4.DT_INT32;
        case Uint8Array:
          return t4.DT_UINT8;
        case Uint16Array:
          return t4.DT_UINT16;
        case Uint32Array:
          return t4.DT_UINT32;
      }
    }(t3, r2), h2 = t3._malloc(l2);
    e3.GetAttributeDataArrayForAllPoints(n3, s2, c2, l2, h2);
    const u2 = new r2(t3.HEAPF32.buffer, h2, o2).slice();
    return t3._free(h2), { name: i2, array: u2, itemSize: a2 };
  }
  onmessage = function(i2) {
    const r2 = i2.data;
    switch (r2.type) {
      case "init":
        t2 = r2.decoderConfig, e2 = new Promise(function(e3) {
          t2.onModuleLoaded = function(t3) {
            e3({ draco: t3 });
          }, DracoDecoderModule(t2);
        });
        break;
      case "decode":
        const i3 = r2.buffer, s2 = r2.taskConfig;
        e2.then((t3) => {
          const e3 = t3.draco, a2 = new e3.Decoder(), o2 = new e3.DecoderBuffer();
          o2.Init(new Int8Array(i3), i3.byteLength);
          try {
            const t4 = function(t5, e4, i5, r3) {
              const s3 = r3.attributeIDs, a3 = r3.attributeTypes;
              let o3, l2;
              const c2 = e4.GetEncodedGeometryType(i5);
              if (c2 === t5.TRIANGULAR_MESH)
                o3 = new t5.Mesh(), l2 = e4.DecodeBufferToMesh(i5, o3);
              else {
                if (c2 !== t5.POINT_CLOUD)
                  throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                o3 = new t5.PointCloud(), l2 = e4.DecodeBufferToPointCloud(i5, o3);
              }
              if (!l2.ok() || o3.ptr === 0)
                throw new Error("THREE.DRACOLoader: Decoding failed: " + l2.error_msg());
              const h2 = { index: null, attributes: [] };
              for (const i6 in s3) {
                const l3 = self[a3[i6]];
                let c3, u2;
                if (r3.useUniqueIDs)
                  u2 = s3[i6], c3 = e4.GetAttributeByUniqueId(o3, u2);
                else {
                  if (u2 = e4.GetAttributeId(o3, t5[s3[i6]]), u2 === -1)
                    continue;
                  c3 = e4.GetAttribute(o3, u2);
                }
                h2.attributes.push(n2(t5, e4, o3, i6, l3, c3));
              }
              c2 === t5.TRIANGULAR_MESH && (h2.index = function(t6, e5, n3) {
                const i6 = 3 * n3.num_faces(), r4 = 4 * i6, s4 = t6._malloc(r4);
                e5.GetTrianglesUInt32Array(n3, r4, s4);
                const a4 = new Uint32Array(t6.HEAPF32.buffer, s4, i6).slice();
                return t6._free(s4), { array: a4, itemSize: 1 };
              }(t5, e4, o3));
              return t5.destroy(o3), h2;
            }(e3, a2, o2, s2), i4 = t4.attributes.map((t5) => t5.array.buffer);
            t4.index && i4.push(t4.index.array.buffer), self.postMessage({ type: "decode", id: r2.id, geometry: t4 }, i4);
          } catch (t4) {
            console.error(t4), self.postMessage({ type: "error", id: r2.id, error: t4.message });
          } finally {
            e3.destroy(o2), e3.destroy(a2);
          }
        });
    }
  };
}
class gc extends al {
  constructor(t2) {
    super(t2), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t3) {
      return new wc(t3);
    }), this.register(function(t3) {
      return new Ac(t3);
    }), this.register(function(t3) {
      return new Rc(t3);
    }), this.register(function(t3) {
      return new _c(t3);
    }), this.register(function(t3) {
      return new Mc(t3);
    }), this.register(function(t3) {
      return new Sc(t3);
    }), this.register(function(t3) {
      return new Tc(t3);
    }), this.register(function(t3) {
      return new Ec(t3);
    }), this.register(function(t3) {
      return new xc(t3);
    }), this.register(function(t3) {
      return new Lc(t3);
    });
  }
  load(t2, e2, n2, i2) {
    const r2 = this;
    let s2;
    s2 = this.resourcePath !== "" ? this.resourcePath : this.path !== "" ? this.path : Ll.extractUrlBase(t2), this.manager.itemStart(t2);
    const a2 = function(e3) {
      i2 ? i2(e3) : console.error(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
    }, o2 = new ll(this.manager);
    o2.setPath(this.path), o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(t2, function(n3) {
      try {
        r2.parse(n3, s2, function(n4) {
          e2(n4), r2.manager.itemEnd(t2);
        }, a2);
      } catch (t3) {
        a2(t3);
      }
    }, n2, a2);
  }
  setDRACOLoader(t2) {
    return this.dracoLoader = t2, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(t2) {
    return this.ktx2Loader = t2, this;
  }
  setMeshoptDecoder(t2) {
    return this.meshoptDecoder = t2, this;
  }
  register(t2) {
    return this.pluginCallbacks.indexOf(t2) === -1 && this.pluginCallbacks.push(t2), this;
  }
  unregister(t2) {
    return this.pluginCallbacks.indexOf(t2) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t2), 1), this;
  }
  parse(t2, e2, n2, i2) {
    let r2;
    const s2 = {}, a2 = {};
    if (typeof t2 == "string")
      r2 = t2;
    else {
      if (Ll.decodeText(new Uint8Array(t2, 0, 4)) === Cc) {
        try {
          s2[yc.KHR_BINARY_GLTF] = new Dc(t2);
        } catch (t3) {
          return void (i2 && i2(t3));
        }
        r2 = s2[yc.KHR_BINARY_GLTF].content;
      } else
        r2 = Ll.decodeText(new Uint8Array(t2));
    }
    const o2 = JSON.parse(r2);
    if (o2.asset === void 0 || o2.asset.version[0] < 2)
      return void (i2 && i2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
    const l2 = new dh(o2, { path: e2 || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
    l2.fileLoader.setRequestHeader(this.requestHeader);
    for (let t3 = 0; t3 < this.pluginCallbacks.length; t3++) {
      const e3 = this.pluginCallbacks[t3](l2);
      a2[e3.name] = e3, s2[e3.name] = true;
    }
    if (o2.extensionsUsed)
      for (let t3 = 0; t3 < o2.extensionsUsed.length; ++t3) {
        const e3 = o2.extensionsUsed[t3], n3 = o2.extensionsRequired || [];
        switch (e3) {
          case yc.KHR_MATERIALS_UNLIT:
            s2[e3] = new bc();
            break;
          case yc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            s2[e3] = new Uc();
            break;
          case yc.KHR_DRACO_MESH_COMPRESSION:
            s2[e3] = new Nc(o2, this.dracoLoader);
            break;
          case yc.KHR_TEXTURE_TRANSFORM:
            s2[e3] = new Fc();
            break;
          case yc.KHR_MESH_QUANTIZATION:
            s2[e3] = new kc();
            break;
          default:
            n3.indexOf(e3) >= 0 && a2[e3] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + e3 + '".');
        }
      }
    l2.setExtensions(s2), l2.setPlugins(a2), l2.parse(n2, i2);
  }
  parseAsync(t2, e2) {
    const n2 = this;
    return new Promise(function(i2, r2) {
      n2.parse(t2, e2, i2, r2);
    });
  }
}
function vc() {
  let t2 = {};
  return { get: function(e2) {
    return t2[e2];
  }, add: function(e2, n2) {
    t2[e2] = n2;
  }, remove: function(e2) {
    delete t2[e2];
  }, removeAll: function() {
    t2 = {};
  } };
}
const yc = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
class xc {
  constructor(t2) {
    this.parser = t2, this.name = yc.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const t2 = this.parser, e2 = this.parser.json.nodes || [];
    for (let n2 = 0, i2 = e2.length; n2 < i2; n2++) {
      const i3 = e2[n2];
      i3.extensions && i3.extensions[this.name] && i3.extensions[this.name].light !== void 0 && t2._addNodeRef(this.cache, i3.extensions[this.name].light);
    }
  }
  _loadLight(t2) {
    const e2 = this.parser, n2 = "light:" + t2;
    let i2 = e2.cache.get(n2);
    if (i2)
      return i2;
    const r2 = e2.json, s2 = ((r2.extensions && r2.extensions[this.name] || {}).lights || [])[t2];
    let a2;
    const o2 = new Ze(16777215);
    s2.color !== void 0 && o2.fromArray(s2.color);
    const l2 = s2.range !== void 0 ? s2.range : 0;
    switch (s2.type) {
      case "directional":
        a2 = new El(o2), a2.target.position.set(0, 0, -1), a2.add(a2.target);
        break;
      case "point":
        a2 = new Sl(o2), a2.distance = l2;
        break;
      case "spot":
        a2 = new xl(o2), a2.distance = l2, s2.spot = s2.spot || {}, s2.spot.innerConeAngle = s2.spot.innerConeAngle !== void 0 ? s2.spot.innerConeAngle : 0, s2.spot.outerConeAngle = s2.spot.outerConeAngle !== void 0 ? s2.spot.outerConeAngle : Math.PI / 4, a2.angle = s2.spot.outerConeAngle, a2.penumbra = 1 - s2.spot.innerConeAngle / s2.spot.outerConeAngle, a2.target.position.set(0, 0, -1), a2.add(a2.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + s2.type);
    }
    return a2.position.set(0, 0, 0), a2.decay = 2, s2.intensity !== void 0 && (a2.intensity = s2.intensity), a2.name = e2.createUniqueName(s2.name || "light_" + t2), i2 = Promise.resolve(a2), e2.cache.add(n2, i2), i2;
  }
  createNodeAttachment(t2) {
    const e2 = this, n2 = this.parser, i2 = n2.json.nodes[t2], r2 = (i2.extensions && i2.extensions[this.name] || {}).light;
    return r2 === void 0 ? null : this._loadLight(r2).then(function(t3) {
      return n2._getNodeRef(e2.cache, r2, t3);
    });
  }
}
class bc {
  constructor() {
    this.name = yc.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Je;
  }
  extendParams(t2, e2, n2) {
    const i2 = [];
    t2.color = new Ze(1, 1, 1), t2.opacity = 1;
    const r2 = e2.pbrMetallicRoughness;
    if (r2) {
      if (Array.isArray(r2.baseColorFactor)) {
        const e3 = r2.baseColorFactor;
        t2.color.fromArray(e3), t2.opacity = e3[3];
      }
      r2.baseColorTexture !== void 0 && i2.push(n2.assignTexture(t2, "map", r2.baseColorTexture));
    }
    return Promise.all(i2);
  }
}
class wc {
  constructor(t2) {
    this.parser = t2, this.name = yc.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(t2) {
    const e2 = this.parser.json.materials[t2];
    return e2.extensions && e2.extensions[this.name] ? Vo : null;
  }
  extendMaterialParams(t2, e2) {
    const n2 = this.parser, i2 = n2.json.materials[t2];
    if (!i2.extensions || !i2.extensions[this.name])
      return Promise.resolve();
    const r2 = [], s2 = i2.extensions[this.name];
    if (s2.clearcoatFactor !== void 0 && (e2.clearcoat = s2.clearcoatFactor), s2.clearcoatTexture !== void 0 && r2.push(n2.assignTexture(e2, "clearcoatMap", s2.clearcoatTexture)), s2.clearcoatRoughnessFactor !== void 0 && (e2.clearcoatRoughness = s2.clearcoatRoughnessFactor), s2.clearcoatRoughnessTexture !== void 0 && r2.push(n2.assignTexture(e2, "clearcoatRoughnessMap", s2.clearcoatRoughnessTexture)), s2.clearcoatNormalTexture !== void 0 && (r2.push(n2.assignTexture(e2, "clearcoatNormalMap", s2.clearcoatNormalTexture)), s2.clearcoatNormalTexture.scale !== void 0)) {
      const t3 = s2.clearcoatNormalTexture.scale;
      e2.clearcoatNormalScale = new mt(t3, t3);
    }
    return Promise.all(r2);
  }
}
class _c {
  constructor(t2) {
    this.parser = t2, this.name = yc.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(t2) {
    const e2 = this.parser.json.materials[t2];
    return e2.extensions && e2.extensions[this.name] ? Vo : null;
  }
  extendMaterialParams(t2, e2) {
    const n2 = this.parser, i2 = n2.json.materials[t2];
    if (!i2.extensions || !i2.extensions[this.name])
      return Promise.resolve();
    const r2 = [];
    e2.sheenColor = new Ze(0, 0, 0), e2.sheenRoughness = 0, e2.sheen = 1;
    const s2 = i2.extensions[this.name];
    return s2.sheenColorFactor !== void 0 && e2.sheenColor.fromArray(s2.sheenColorFactor), s2.sheenRoughnessFactor !== void 0 && (e2.sheenRoughness = s2.sheenRoughnessFactor), s2.sheenColorTexture !== void 0 && r2.push(n2.assignTexture(e2, "sheenColorMap", s2.sheenColorTexture)), s2.sheenRoughnessTexture !== void 0 && r2.push(n2.assignTexture(e2, "sheenRoughnessMap", s2.sheenRoughnessTexture)), Promise.all(r2);
  }
}
class Mc {
  constructor(t2) {
    this.parser = t2, this.name = yc.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(t2) {
    const e2 = this.parser.json.materials[t2];
    return e2.extensions && e2.extensions[this.name] ? Vo : null;
  }
  extendMaterialParams(t2, e2) {
    const n2 = this.parser, i2 = n2.json.materials[t2];
    if (!i2.extensions || !i2.extensions[this.name])
      return Promise.resolve();
    const r2 = [], s2 = i2.extensions[this.name];
    return s2.transmissionFactor !== void 0 && (e2.transmission = s2.transmissionFactor), s2.transmissionTexture !== void 0 && r2.push(n2.assignTexture(e2, "transmissionMap", s2.transmissionTexture)), Promise.all(r2);
  }
}
class Sc {
  constructor(t2) {
    this.parser = t2, this.name = yc.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(t2) {
    const e2 = this.parser.json.materials[t2];
    return e2.extensions && e2.extensions[this.name] ? Vo : null;
  }
  extendMaterialParams(t2, e2) {
    const n2 = this.parser, i2 = n2.json.materials[t2];
    if (!i2.extensions || !i2.extensions[this.name])
      return Promise.resolve();
    const r2 = [], s2 = i2.extensions[this.name];
    e2.thickness = s2.thicknessFactor !== void 0 ? s2.thicknessFactor : 0, s2.thicknessTexture !== void 0 && r2.push(n2.assignTexture(e2, "thicknessMap", s2.thicknessTexture)), e2.attenuationDistance = s2.attenuationDistance || 0;
    const a2 = s2.attenuationColor || [1, 1, 1];
    return e2.attenuationColor = new Ze(a2[0], a2[1], a2[2]), Promise.all(r2);
  }
}
class Tc {
  constructor(t2) {
    this.parser = t2, this.name = yc.KHR_MATERIALS_IOR;
  }
  getMaterialType(t2) {
    const e2 = this.parser.json.materials[t2];
    return e2.extensions && e2.extensions[this.name] ? Vo : null;
  }
  extendMaterialParams(t2, e2) {
    const n2 = this.parser.json.materials[t2];
    if (!n2.extensions || !n2.extensions[this.name])
      return Promise.resolve();
    const i2 = n2.extensions[this.name];
    return e2.ior = i2.ior !== void 0 ? i2.ior : 1.5, Promise.resolve();
  }
}
class Ec {
  constructor(t2) {
    this.parser = t2, this.name = yc.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(t2) {
    const e2 = this.parser.json.materials[t2];
    return e2.extensions && e2.extensions[this.name] ? Vo : null;
  }
  extendMaterialParams(t2, e2) {
    const n2 = this.parser, i2 = n2.json.materials[t2];
    if (!i2.extensions || !i2.extensions[this.name])
      return Promise.resolve();
    const r2 = [], s2 = i2.extensions[this.name];
    e2.specularIntensity = s2.specularFactor !== void 0 ? s2.specularFactor : 1, s2.specularTexture !== void 0 && r2.push(n2.assignTexture(e2, "specularIntensityMap", s2.specularTexture));
    const a2 = s2.specularColorFactor || [1, 1, 1];
    return e2.specularColor = new Ze(a2[0], a2[1], a2[2]), s2.specularColorTexture !== void 0 && r2.push(n2.assignTexture(e2, "specularColorMap", s2.specularColorTexture).then(function(t3) {
      t3.encoding = 3001;
    })), Promise.all(r2);
  }
}
class Ac {
  constructor(t2) {
    this.parser = t2, this.name = yc.KHR_TEXTURE_BASISU;
  }
  loadTexture(t2) {
    const e2 = this.parser, n2 = e2.json, i2 = n2.textures[t2];
    if (!i2.extensions || !i2.extensions[this.name])
      return null;
    const r2 = i2.extensions[this.name], s2 = n2.images[r2.source], a2 = e2.options.ktx2Loader;
    if (!a2) {
      if (n2.extensionsRequired && n2.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return e2.loadTextureImage(t2, s2, a2);
  }
}
class Rc {
  constructor(t2) {
    this.parser = t2, this.name = yc.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(t2) {
    const e2 = this.name, n2 = this.parser, i2 = n2.json, r2 = i2.textures[t2];
    if (!r2.extensions || !r2.extensions[e2])
      return null;
    const s2 = r2.extensions[e2], a2 = i2.images[s2.source];
    let o2 = n2.textureLoader;
    if (a2.uri) {
      const t3 = n2.options.manager.getHandler(a2.uri);
      t3 !== null && (o2 = t3);
    }
    return this.detectSupport().then(function(r3) {
      if (r3)
        return n2.loadTextureImage(t2, a2, o2);
      if (i2.extensionsRequired && i2.extensionsRequired.indexOf(e2) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n2.loadTexture(t2);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(t2) {
      const e2 = new Image();
      e2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e2.onload = e2.onerror = function() {
        t2(e2.height === 1);
      };
    })), this.isSupported;
  }
}
class Lc {
  constructor(t2) {
    this.name = yc.EXT_MESHOPT_COMPRESSION, this.parser = t2;
  }
  loadBufferView(t2) {
    const e2 = this.parser.json, n2 = e2.bufferViews[t2];
    if (n2.extensions && n2.extensions[this.name]) {
      const t3 = n2.extensions[this.name], i2 = this.parser.getDependency("buffer", t3.buffer), r2 = this.parser.options.meshoptDecoder;
      if (!r2 || !r2.supported) {
        if (e2.extensionsRequired && e2.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return Promise.all([i2, r2.ready]).then(function(e3) {
        const n3 = t3.byteOffset || 0, i3 = t3.byteLength || 0, s2 = t3.count, a2 = t3.byteStride, o2 = new ArrayBuffer(s2 * a2), l2 = new Uint8Array(e3[0], n3, i3);
        return r2.decodeGltfBuffer(new Uint8Array(o2), s2, a2, l2, t3.mode, t3.filter), o2;
      });
    }
    return null;
  }
}
const Cc = "glTF", Pc = 1313821514, Ic = 5130562;
class Dc {
  constructor(t2) {
    this.name = yc.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const e2 = new DataView(t2, 0, 12);
    if (this.header = { magic: Ll.decodeText(new Uint8Array(t2.slice(0, 4))), version: e2.getUint32(4, true), length: e2.getUint32(8, true) }, this.header.magic !== Cc)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n2 = this.header.length - 12, i2 = new DataView(t2, 12);
    let r2 = 0;
    for (; r2 < n2; ) {
      const e3 = i2.getUint32(r2, true);
      r2 += 4;
      const n3 = i2.getUint32(r2, true);
      if (r2 += 4, n3 === Pc) {
        const n4 = new Uint8Array(t2, 12 + r2, e3);
        this.content = Ll.decodeText(n4);
      } else if (n3 === Ic) {
        const n4 = 12 + r2;
        this.body = t2.slice(n4, n4 + e3);
      }
      r2 += e3;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Nc {
  constructor(t2, e2) {
    if (!e2)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = yc.KHR_DRACO_MESH_COMPRESSION, this.json = t2, this.dracoLoader = e2, this.dracoLoader.preload();
  }
  decodePrimitive(t2, e2) {
    const n2 = this.json, i2 = this.dracoLoader, r2 = t2.extensions[this.name].bufferView, s2 = t2.extensions[this.name].attributes, a2 = {}, o2 = {}, l2 = {};
    for (const t3 in s2) {
      const e3 = Qc[t3] || t3.toLowerCase();
      a2[e3] = s2[t3];
    }
    for (const e3 in t2.attributes) {
      const i3 = Qc[e3] || e3.toLowerCase();
      if (s2[e3] !== void 0) {
        const r3 = n2.accessors[t2.attributes[e3]], s3 = Zc[r3.componentType];
        l2[i3] = s3, o2[i3] = r3.normalized === true;
      }
    }
    return e2.getDependency("bufferView", r2).then(function(t3) {
      return new Promise(function(e3) {
        i2.decodeDracoFile(t3, function(t4) {
          for (const e4 in t4.attributes) {
            const n3 = t4.attributes[e4], i3 = o2[e4];
            i3 !== void 0 && (n3.normalized = i3);
          }
          e3(t4);
        }, a2, l2);
      });
    });
  }
}
class Fc {
  constructor() {
    this.name = yc.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(t2, e2) {
    return e2.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e2.offset === void 0 && e2.rotation === void 0 && e2.scale === void 0 || (t2 = t2.clone(), e2.offset !== void 0 && t2.offset.fromArray(e2.offset), e2.rotation !== void 0 && (t2.rotation = e2.rotation), e2.scale !== void 0 && t2.repeat.fromArray(e2.scale), t2.needsUpdate = true), t2;
  }
}
class Oc extends Ho {
  constructor(t2) {
    super(), this.isGLTFSpecularGlossinessMaterial = true;
    const e2 = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n"), n2 = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n"), i2 = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	texelSpecular = sRGBToLinear( texelSpecular );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), r2 = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), s2 = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), a2 = { specular: { value: new Ze().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
    this._extraUniforms = a2, this.onBeforeCompile = function(t3) {
      for (const e3 in a2)
        t3.uniforms[e3] = a2[e3];
      t3.fragmentShader = t3.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e2).replace("#include <metalnessmap_pars_fragment>", n2).replace("#include <roughnessmap_fragment>", i2).replace("#include <metalnessmap_fragment>", r2).replace("#include <lights_physical_fragment>", s2);
    }, Object.defineProperties(this, { specular: { get: function() {
      return a2.specular.value;
    }, set: function(t3) {
      a2.specular.value = t3;
    } }, specularMap: { get: function() {
      return a2.specularMap.value;
    }, set: function(t3) {
      a2.specularMap.value = t3, t3 ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
    } }, glossiness: { get: function() {
      return a2.glossiness.value;
    }, set: function(t3) {
      a2.glossiness.value = t3;
    } }, glossinessMap: { get: function() {
      return a2.glossinessMap.value;
    }, set: function(t3) {
      a2.glossinessMap.value = t3, t3 ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
    } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t2);
  }
  copy(t2) {
    return super.copy(t2), this.specularMap = t2.specularMap, this.specular.copy(t2.specular), this.glossinessMap = t2.glossinessMap, this.glossiness = t2.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
  }
}
class Uc {
  constructor() {
    this.name = yc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"];
  }
  getMaterialType() {
    return Oc;
  }
  extendParams(t2, e2, n2) {
    const i2 = e2.extensions[this.name];
    t2.color = new Ze(1, 1, 1), t2.opacity = 1;
    const r2 = [];
    if (Array.isArray(i2.diffuseFactor)) {
      const e3 = i2.diffuseFactor;
      t2.color.fromArray(e3), t2.opacity = e3[3];
    }
    if (i2.diffuseTexture !== void 0 && r2.push(n2.assignTexture(t2, "map", i2.diffuseTexture)), t2.emissive = new Ze(0, 0, 0), t2.glossiness = i2.glossinessFactor !== void 0 ? i2.glossinessFactor : 1, t2.specular = new Ze(1, 1, 1), Array.isArray(i2.specularFactor) && t2.specular.fromArray(i2.specularFactor), i2.specularGlossinessTexture !== void 0) {
      const e3 = i2.specularGlossinessTexture;
      r2.push(n2.assignTexture(t2, "glossinessMap", e3)), r2.push(n2.assignTexture(t2, "specularMap", e3));
    }
    return Promise.all(r2);
  }
  createMaterial(t2) {
    const e2 = new Oc(t2);
    return e2.fog = true, e2.color = t2.color, e2.map = t2.map === void 0 ? null : t2.map, e2.lightMap = null, e2.lightMapIntensity = 1, e2.aoMap = t2.aoMap === void 0 ? null : t2.aoMap, e2.aoMapIntensity = 1, e2.emissive = t2.emissive, e2.emissiveIntensity = 1, e2.emissiveMap = t2.emissiveMap === void 0 ? null : t2.emissiveMap, e2.bumpMap = t2.bumpMap === void 0 ? null : t2.bumpMap, e2.bumpScale = 1, e2.normalMap = t2.normalMap === void 0 ? null : t2.normalMap, e2.normalMapType = 0, t2.normalScale && (e2.normalScale = t2.normalScale), e2.displacementMap = null, e2.displacementScale = 1, e2.displacementBias = 0, e2.specularMap = t2.specularMap === void 0 ? null : t2.specularMap, e2.specular = t2.specular, e2.glossinessMap = t2.glossinessMap === void 0 ? null : t2.glossinessMap, e2.glossiness = t2.glossiness, e2.alphaMap = null, e2.envMap = t2.envMap === void 0 ? null : t2.envMap, e2.envMapIntensity = 1, e2.refractionRatio = 0.98, e2;
  }
}
class kc {
  constructor() {
    this.name = yc.KHR_MESH_QUANTIZATION;
  }
}
class zc extends Wo {
  constructor(t2, e2, n2, i2) {
    super(t2, e2, n2, i2);
  }
  copySampleValue_(t2) {
    const e2 = this.resultBuffer, n2 = this.sampleValues, i2 = this.valueSize, r2 = t2 * i2 * 3 + i2;
    for (let t3 = 0; t3 !== i2; t3++)
      e2[t3] = n2[r2 + t3];
    return e2;
  }
}
zc.prototype.beforeStart_ = zc.prototype.copySampleValue_, zc.prototype.afterEnd_ = zc.prototype.copySampleValue_, zc.prototype.interpolate_ = function(t2, e2, n2, i2) {
  const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o2 = 2 * a2, l2 = 3 * a2, c2 = i2 - e2, h2 = (n2 - e2) / c2, u2 = h2 * h2, d2 = u2 * h2, p2 = t2 * l2, m2 = p2 - l2, f2 = -2 * d2 + 3 * u2, g2 = d2 - u2, v2 = 1 - f2, y2 = g2 - u2 + h2;
  for (let t3 = 0; t3 !== a2; t3++) {
    const e3 = s2[m2 + t3 + a2], n3 = s2[m2 + t3 + o2] * c2, i3 = s2[p2 + t3 + a2], l3 = s2[p2 + t3] * c2;
    r2[t3] = v2 * e3 + y2 * n3 + f2 * i3 + g2 * l3;
  }
  return r2;
};
const Bc = new Et();
class Hc extends zc {
  interpolate_(t2, e2, n2, i2) {
    const r2 = super.interpolate_(t2, e2, n2, i2);
    return Bc.fromArray(r2).normalize().toArray(r2), r2;
  }
}
const Vc = 0, Gc = 1, Wc = 2, jc = 3, qc = 4, Xc = 5, Yc = 6, Zc = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Jc = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 }, $c = { 33071: 1001, 33648: 1002, 10497: 1e3 }, Kc = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, Qc = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, th = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, eh = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 }, nh = "OPAQUE", ih = "MASK", rh = "BLEND";
function sh(t2) {
  return t2.DefaultMaterial === void 0 && (t2.DefaultMaterial = new Ho({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: 0 })), t2.DefaultMaterial;
}
function ah(t2, e2, n2) {
  for (const i2 in n2.extensions)
    t2[i2] === void 0 && (e2.userData.gltfExtensions = e2.userData.gltfExtensions || {}, e2.userData.gltfExtensions[i2] = n2.extensions[i2]);
}
function oh(t2, e2) {
  e2.extras !== void 0 && (typeof e2.extras == "object" ? Object.assign(t2.userData, e2.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e2.extras));
}
function lh(t2, e2) {
  if (t2.updateMorphTargets(), e2.weights !== void 0)
    for (let n2 = 0, i2 = e2.weights.length; n2 < i2; n2++)
      t2.morphTargetInfluences[n2] = e2.weights[n2];
  if (e2.extras && Array.isArray(e2.extras.targetNames)) {
    const n2 = e2.extras.targetNames;
    if (t2.morphTargetInfluences.length === n2.length) {
      t2.morphTargetDictionary = {};
      for (let e3 = 0, i2 = n2.length; e3 < i2; e3++)
        t2.morphTargetDictionary[n2[e3]] = e3;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function ch(t2) {
  const e2 = t2.extensions && t2.extensions[yc.KHR_DRACO_MESH_COMPRESSION];
  let n2;
  return n2 = e2 ? "draco:" + e2.bufferView + ":" + e2.indices + ":" + hh(e2.attributes) : t2.indices + ":" + hh(t2.attributes) + ":" + t2.mode, n2;
}
function hh(t2) {
  let e2 = "";
  const n2 = Object.keys(t2).sort();
  for (let i2 = 0, r2 = n2.length; i2 < r2; i2++)
    e2 += n2[i2] + ":" + t2[n2[i2]] + ";";
  return e2;
}
function uh(t2) {
  switch (t2) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
class dh {
  constructor(t2 = {}, e2 = {}) {
    this.json = t2, this.extensions = {}, this.plugins = {}, this.options = e2, this.cache = new vc(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, typeof createImageBitmap != "undefined" && /Firefox|Safari/.test(navigator.userAgent) === false ? this.textureLoader = new Cl(this.options.manager) : this.textureLoader = new dl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ll(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
  }
  setExtensions(t2) {
    this.extensions = t2;
  }
  setPlugins(t2) {
    this.plugins = t2;
  }
  parse(t2, e2) {
    const n2 = this, i2 = this.json, r2 = this.extensions;
    this.cache.removeAll(), this._invokeAll(function(t3) {
      return t3._markDefs && t3._markDefs();
    }), Promise.all(this._invokeAll(function(t3) {
      return t3.beforeRoot && t3.beforeRoot();
    })).then(function() {
      return Promise.all([n2.getDependencies("scene"), n2.getDependencies("animation"), n2.getDependencies("camera")]);
    }).then(function(e3) {
      const s2 = { scene: e3[0][i2.scene || 0], scenes: e3[0], animations: e3[1], cameras: e3[2], asset: i2.asset, parser: n2, userData: {} };
      ah(r2, s2, i2), oh(s2, i2), Promise.all(n2._invokeAll(function(t3) {
        return t3.afterRoot && t3.afterRoot(s2);
      })).then(function() {
        t2(s2);
      });
    }).catch(e2);
  }
  _markDefs() {
    const t2 = this.json.nodes || [], e2 = this.json.skins || [], n2 = this.json.meshes || [];
    for (let n3 = 0, i2 = e2.length; n3 < i2; n3++) {
      const i3 = e2[n3].joints;
      for (let e3 = 0, n4 = i3.length; e3 < n4; e3++)
        t2[i3[e3]].isBone = true;
    }
    for (let e3 = 0, i2 = t2.length; e3 < i2; e3++) {
      const i3 = t2[e3];
      i3.mesh !== void 0 && (this._addNodeRef(this.meshCache, i3.mesh), i3.skin !== void 0 && (n2[i3.mesh].isSkinnedMesh = true)), i3.camera !== void 0 && this._addNodeRef(this.cameraCache, i3.camera);
    }
  }
  _addNodeRef(t2, e2) {
    e2 !== void 0 && (t2.refs[e2] === void 0 && (t2.refs[e2] = t2.uses[e2] = 0), t2.refs[e2]++);
  }
  _getNodeRef(t2, e2, n2) {
    if (t2.refs[e2] <= 1)
      return n2;
    const i2 = n2.clone(), r2 = (t3, e3) => {
      const n3 = this.associations.get(t3);
      n3 != null && this.associations.set(e3, n3);
      for (const [n4, i3] of t3.children.entries())
        r2(i3, e3.children[n4]);
    };
    return r2(n2, i2), i2.name += "_instance_" + t2.uses[e2]++, i2;
  }
  _invokeOne(t2) {
    const e2 = Object.values(this.plugins);
    e2.push(this);
    for (let n2 = 0; n2 < e2.length; n2++) {
      const i2 = t2(e2[n2]);
      if (i2)
        return i2;
    }
    return null;
  }
  _invokeAll(t2) {
    const e2 = Object.values(this.plugins);
    e2.unshift(this);
    const n2 = [];
    for (let i2 = 0; i2 < e2.length; i2++) {
      const r2 = t2(e2[i2]);
      r2 && n2.push(r2);
    }
    return n2;
  }
  getDependency(t2, e2) {
    const n2 = t2 + ":" + e2;
    let i2 = this.cache.get(n2);
    if (!i2) {
      switch (t2) {
        case "scene":
          i2 = this.loadScene(e2);
          break;
        case "node":
          i2 = this.loadNode(e2);
          break;
        case "mesh":
          i2 = this._invokeOne(function(t3) {
            return t3.loadMesh && t3.loadMesh(e2);
          });
          break;
        case "accessor":
          i2 = this.loadAccessor(e2);
          break;
        case "bufferView":
          i2 = this._invokeOne(function(t3) {
            return t3.loadBufferView && t3.loadBufferView(e2);
          });
          break;
        case "buffer":
          i2 = this.loadBuffer(e2);
          break;
        case "material":
          i2 = this._invokeOne(function(t3) {
            return t3.loadMaterial && t3.loadMaterial(e2);
          });
          break;
        case "texture":
          i2 = this._invokeOne(function(t3) {
            return t3.loadTexture && t3.loadTexture(e2);
          });
          break;
        case "skin":
          i2 = this.loadSkin(e2);
          break;
        case "animation":
          i2 = this.loadAnimation(e2);
          break;
        case "camera":
          i2 = this.loadCamera(e2);
          break;
        default:
          throw new Error("Unknown type: " + t2);
      }
      this.cache.add(n2, i2);
    }
    return i2;
  }
  getDependencies(t2) {
    let e2 = this.cache.get(t2);
    if (!e2) {
      const n2 = this, i2 = this.json[t2 + (t2 === "mesh" ? "es" : "s")] || [];
      e2 = Promise.all(i2.map(function(e3, i3) {
        return n2.getDependency(t2, i3);
      })), this.cache.add(t2, e2);
    }
    return e2;
  }
  loadBuffer(t2) {
    const e2 = this.json.buffers[t2], n2 = this.fileLoader;
    if (e2.type && e2.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + e2.type + " buffer type is not supported.");
    if (e2.uri === void 0 && t2 === 0)
      return Promise.resolve(this.extensions[yc.KHR_BINARY_GLTF].body);
    const i2 = this.options;
    return new Promise(function(t3, r2) {
      n2.load(Ll.resolveURL(e2.uri, i2.path), t3, void 0, function() {
        r2(new Error('THREE.GLTFLoader: Failed to load buffer "' + e2.uri + '".'));
      });
    });
  }
  loadBufferView(t2) {
    const e2 = this.json.bufferViews[t2];
    return this.getDependency("buffer", e2.buffer).then(function(t3) {
      const n2 = e2.byteLength || 0, i2 = e2.byteOffset || 0;
      return t3.slice(i2, i2 + n2);
    });
  }
  loadAccessor(t2) {
    const e2 = this, n2 = this.json, i2 = this.json.accessors[t2];
    if (i2.bufferView === void 0 && i2.sparse === void 0)
      return Promise.resolve(null);
    const r2 = [];
    return i2.bufferView !== void 0 ? r2.push(this.getDependency("bufferView", i2.bufferView)) : r2.push(null), i2.sparse !== void 0 && (r2.push(this.getDependency("bufferView", i2.sparse.indices.bufferView)), r2.push(this.getDependency("bufferView", i2.sparse.values.bufferView))), Promise.all(r2).then(function(t3) {
      const r3 = t3[0], s2 = Kc[i2.type], a2 = Zc[i2.componentType], o2 = a2.BYTES_PER_ELEMENT, l2 = o2 * s2, c2 = i2.byteOffset || 0, h2 = i2.bufferView !== void 0 ? n2.bufferViews[i2.bufferView].byteStride : void 0, u2 = i2.normalized === true;
      let d2, p2;
      if (h2 && h2 !== l2) {
        const t4 = Math.floor(c2 / h2), n3 = "InterleavedBuffer:" + i2.bufferView + ":" + i2.componentType + ":" + t4 + ":" + i2.count;
        let l3 = e2.cache.get(n3);
        l3 || (d2 = new a2(r3, t4 * h2, i2.count * h2 / o2), l3 = new Hs(d2, h2 / o2), e2.cache.add(n3, l3)), p2 = new Gs(l3, s2, c2 % h2 / o2, u2);
      } else
        d2 = r3 === null ? new a2(i2.count * s2) : new a2(r3, c2, i2.count * s2), p2 = new Qe(d2, s2, u2);
      if (i2.sparse !== void 0) {
        const e3 = Kc.SCALAR, n3 = Zc[i2.sparse.indices.componentType], o3 = i2.sparse.indices.byteOffset || 0, l3 = i2.sparse.values.byteOffset || 0, c3 = new n3(t3[1], o3, i2.sparse.count * e3), h3 = new a2(t3[2], l3, i2.sparse.count * s2);
        r3 !== null && (p2 = new Qe(p2.array.slice(), p2.itemSize, p2.normalized));
        for (let t4 = 0, e4 = c3.length; t4 < e4; t4++) {
          const e5 = c3[t4];
          if (p2.setX(e5, h3[t4 * s2]), s2 >= 2 && p2.setY(e5, h3[t4 * s2 + 1]), s2 >= 3 && p2.setZ(e5, h3[t4 * s2 + 2]), s2 >= 4 && p2.setW(e5, h3[t4 * s2 + 3]), s2 >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return p2;
    });
  }
  loadTexture(t2) {
    const e2 = this.json, n2 = this.options, i2 = e2.textures[t2], r2 = e2.images[i2.source];
    let s2 = this.textureLoader;
    if (r2.uri) {
      const t3 = n2.manager.getHandler(r2.uri);
      t3 !== null && (s2 = t3);
    }
    return this.loadTextureImage(t2, r2, s2);
  }
  loadTextureImage(t2, e2, n2) {
    const i2 = this, r2 = this.json, s2 = this.options, a2 = r2.textures[t2], o2 = (e2.uri || e2.bufferView) + ":" + a2.sampler;
    if (this.textureCache[o2])
      return this.textureCache[o2];
    const l2 = self.URL || self.webkitURL;
    let c2 = e2.uri || "", h2 = false;
    if (e2.bufferView !== void 0)
      c2 = i2.getDependency("bufferView", e2.bufferView).then(function(t3) {
        h2 = true;
        const n3 = new Blob([t3], { type: e2.mimeType });
        return c2 = l2.createObjectURL(n3), c2;
      });
    else if (e2.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + t2 + " is missing URI and bufferView");
    const u2 = Promise.resolve(c2).then(function(t3) {
      return new Promise(function(e3, i3) {
        let r3 = e3;
        n2.isImageBitmapLoader === true && (r3 = function(t4) {
          const n3 = new wt(t4);
          n3.needsUpdate = true, e3(n3);
        }), n2.load(Ll.resolveURL(t3, s2.path), r3, void 0, i3);
      });
    }).then(function(e3) {
      h2 === true && l2.revokeObjectURL(c2), e3.flipY = false, a2.name && (e3.name = a2.name);
      const n3 = (r2.samplers || {})[a2.sampler] || {};
      return e3.magFilter = Jc[n3.magFilter] || 1006, e3.minFilter = Jc[n3.minFilter] || 1008, e3.wrapS = $c[n3.wrapS] || 1e3, e3.wrapT = $c[n3.wrapT] || 1e3, i2.associations.set(e3, { textures: t2 }), e3;
    }).catch(function() {
      return console.error("THREE.GLTFLoader: Couldn't load texture", c2), null;
    });
    return this.textureCache[o2] = u2, u2;
  }
  assignTexture(t2, e2, n2) {
    const i2 = this;
    return this.getDependency("texture", n2.index).then(function(r2) {
      if (n2.texCoord === void 0 || n2.texCoord == 0 || e2 === "aoMap" && n2.texCoord == 1 || console.warn("THREE.GLTFLoader: Custom UV set " + n2.texCoord + " for texture " + e2 + " not yet supported."), i2.extensions[yc.KHR_TEXTURE_TRANSFORM]) {
        const t3 = n2.extensions !== void 0 ? n2.extensions[yc.KHR_TEXTURE_TRANSFORM] : void 0;
        if (t3) {
          const e3 = i2.associations.get(r2);
          r2 = i2.extensions[yc.KHR_TEXTURE_TRANSFORM].extendTexture(r2, t3), i2.associations.set(r2, e3);
        }
      }
      return t2[e2] = r2, r2;
    });
  }
  assignFinalMaterial(t2) {
    const e2 = t2.geometry;
    let n2 = t2.material;
    const i2 = e2.attributes.tangent === void 0, r2 = e2.attributes.color !== void 0, s2 = e2.attributes.normal === void 0;
    if (t2.isPoints) {
      const t3 = "PointsMaterial:" + n2.uuid;
      let e3 = this.cache.get(t3);
      e3 || (e3 = new Ia(), Ve.prototype.copy.call(e3, n2), e3.color.copy(n2.color), e3.map = n2.map, e3.sizeAttenuation = false, this.cache.add(t3, e3)), n2 = e3;
    } else if (t2.isLine) {
      const t3 = "LineBasicMaterial:" + n2.uuid;
      let e3 = this.cache.get(t3);
      e3 || (e3 = new wa(), Ve.prototype.copy.call(e3, n2), e3.color.copy(n2.color), this.cache.add(t3, e3)), n2 = e3;
    }
    if (i2 || r2 || s2) {
      let t3 = "ClonedMaterial:" + n2.uuid + ":";
      n2.isGLTFSpecularGlossinessMaterial && (t3 += "specular-glossiness:"), i2 && (t3 += "derivative-tangents:"), r2 && (t3 += "vertex-colors:"), s2 && (t3 += "flat-shading:");
      let e3 = this.cache.get(t3);
      e3 || (e3 = n2.clone(), r2 && (e3.vertexColors = true), s2 && (e3.flatShading = true), i2 && (e3.normalScale && (e3.normalScale.y *= -1), e3.clearcoatNormalScale && (e3.clearcoatNormalScale.y *= -1)), this.cache.add(t3, e3), this.associations.set(e3, this.associations.get(n2))), n2 = e3;
    }
    n2.aoMap && e2.attributes.uv2 === void 0 && e2.attributes.uv !== void 0 && e2.setAttribute("uv2", e2.attributes.uv), t2.material = n2;
  }
  getMaterialType() {
    return Ho;
  }
  loadMaterial(t2) {
    const e2 = this, n2 = this.json, i2 = this.extensions, r2 = n2.materials[t2];
    let s2;
    const a2 = {}, o2 = r2.extensions || {}, l2 = [];
    if (o2[yc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const t3 = i2[yc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      s2 = t3.getMaterialType(), l2.push(t3.extendParams(a2, r2, e2));
    } else if (o2[yc.KHR_MATERIALS_UNLIT]) {
      const t3 = i2[yc.KHR_MATERIALS_UNLIT];
      s2 = t3.getMaterialType(), l2.push(t3.extendParams(a2, r2, e2));
    } else {
      const n3 = r2.pbrMetallicRoughness || {};
      if (a2.color = new Ze(1, 1, 1), a2.opacity = 1, Array.isArray(n3.baseColorFactor)) {
        const t3 = n3.baseColorFactor;
        a2.color.fromArray(t3), a2.opacity = t3[3];
      }
      n3.baseColorTexture !== void 0 && l2.push(e2.assignTexture(a2, "map", n3.baseColorTexture)), a2.metalness = n3.metallicFactor !== void 0 ? n3.metallicFactor : 1, a2.roughness = n3.roughnessFactor !== void 0 ? n3.roughnessFactor : 1, n3.metallicRoughnessTexture !== void 0 && (l2.push(e2.assignTexture(a2, "metalnessMap", n3.metallicRoughnessTexture)), l2.push(e2.assignTexture(a2, "roughnessMap", n3.metallicRoughnessTexture))), s2 = this._invokeOne(function(e3) {
        return e3.getMaterialType && e3.getMaterialType(t2);
      }), l2.push(Promise.all(this._invokeAll(function(e3) {
        return e3.extendMaterialParams && e3.extendMaterialParams(t2, a2);
      })));
    }
    r2.doubleSided === true && (a2.side = 2);
    const c2 = r2.alphaMode || nh;
    if (c2 === rh ? (a2.transparent = true, a2.depthWrite = false) : (a2.format = 1022, a2.transparent = false, c2 === ih && (a2.alphaTest = r2.alphaCutoff !== void 0 ? r2.alphaCutoff : 0.5)), r2.normalTexture !== void 0 && s2 !== Je && (l2.push(e2.assignTexture(a2, "normalMap", r2.normalTexture)), a2.normalScale = new mt(1, 1), r2.normalTexture.scale !== void 0)) {
      const t3 = r2.normalTexture.scale;
      a2.normalScale.set(t3, t3);
    }
    return r2.occlusionTexture !== void 0 && s2 !== Je && (l2.push(e2.assignTexture(a2, "aoMap", r2.occlusionTexture)), r2.occlusionTexture.strength !== void 0 && (a2.aoMapIntensity = r2.occlusionTexture.strength)), r2.emissiveFactor !== void 0 && s2 !== Je && (a2.emissive = new Ze().fromArray(r2.emissiveFactor)), r2.emissiveTexture !== void 0 && s2 !== Je && l2.push(e2.assignTexture(a2, "emissiveMap", r2.emissiveTexture)), Promise.all(l2).then(function() {
      let n3;
      return n3 = s2 === Oc ? i2[yc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a2) : new s2(a2), r2.name && (n3.name = r2.name), n3.map && (n3.map.encoding = 3001), n3.emissiveMap && (n3.emissiveMap.encoding = 3001), oh(n3, r2), e2.associations.set(n3, { materials: t2 }), r2.extensions && ah(i2, n3, r2), n3;
    });
  }
  createUniqueName(t2) {
    const e2 = Gl.sanitizeNodeName(t2 || "");
    let n2 = e2;
    for (let t3 = 1; this.nodeNamesUsed[n2]; ++t3)
      n2 = e2 + "_" + t3;
    return this.nodeNamesUsed[n2] = true, n2;
  }
  loadGeometries(t2) {
    const e2 = this, n2 = this.extensions, i2 = this.primitiveCache;
    function r2(t3) {
      return n2[yc.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t3, e2).then(function(n3) {
        return mh(n3, t3, e2);
      });
    }
    const s2 = [];
    for (let n3 = 0, a2 = t2.length; n3 < a2; n3++) {
      const a3 = t2[n3], o2 = ch(a3), l2 = i2[o2];
      if (l2)
        s2.push(l2.promise);
      else {
        let t3;
        t3 = a3.extensions && a3.extensions[yc.KHR_DRACO_MESH_COMPRESSION] ? r2(a3) : mh(new un(), a3, e2), i2[o2] = { primitive: a3, promise: t3 }, s2.push(t3);
      }
    }
    return Promise.all(s2);
  }
  loadMesh(t2) {
    const e2 = this, n2 = this.json, i2 = this.extensions, r2 = n2.meshes[t2], s2 = r2.primitives, a2 = [];
    for (let t3 = 0, e3 = s2.length; t3 < e3; t3++) {
      const e4 = s2[t3].material === void 0 ? sh(this.cache) : this.getDependency("material", s2[t3].material);
      a2.push(e4);
    }
    return a2.push(e2.loadGeometries(s2)), Promise.all(a2).then(function(n3) {
      const a3 = n3.slice(0, n3.length - 1), o2 = n3[n3.length - 1], l2 = [];
      for (let n4 = 0, c3 = o2.length; n4 < c3; n4++) {
        const c4 = o2[n4], h2 = s2[n4];
        let u2;
        const d2 = a3[n4];
        if (h2.mode === qc || h2.mode === Xc || h2.mode === Yc || h2.mode === void 0)
          u2 = r2.isSkinnedMesh === true ? new ha(c4, d2) : new Ln(c4, d2), u2.isSkinnedMesh !== true || u2.geometry.attributes.skinWeight.normalized || u2.normalizeSkinWeights(), h2.mode === Xc ? u2.geometry = fh(u2.geometry, 1) : h2.mode === Yc && (u2.geometry = fh(u2.geometry, 2));
        else if (h2.mode === Gc)
          u2 = new Ca(c4, d2);
        else if (h2.mode === jc)
          u2 = new Aa(c4, d2);
        else if (h2.mode === Wc)
          u2 = new Pa(c4, d2);
        else {
          if (h2.mode !== Vc)
            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h2.mode);
          u2 = new Ua(c4, d2);
        }
        Object.keys(u2.geometry.morphAttributes).length > 0 && lh(u2, r2), u2.name = e2.createUniqueName(r2.name || "mesh_" + t2), oh(u2, r2), h2.extensions && ah(i2, u2, h2), e2.assignFinalMaterial(u2), l2.push(u2);
      }
      for (let n4 = 0, i3 = l2.length; n4 < i3; n4++)
        e2.associations.set(l2[n4], { meshes: t2, primitives: n4 });
      if (l2.length === 1)
        return l2[0];
      const c2 = new Ds();
      e2.associations.set(c2, { meshes: t2 });
      for (let t3 = 0, e3 = l2.length; t3 < e3; t3++)
        c2.add(l2[t3]);
      return c2;
    });
  }
  loadCamera(t2) {
    let e2;
    const n2 = this.json.cameras[t2], i2 = n2[n2.type];
    if (i2)
      return n2.type === "perspective" ? e2 = new Un(pt.radToDeg(i2.yfov), i2.aspectRatio || 1, i2.znear || 1, i2.zfar || 2e6) : n2.type === "orthographic" && (e2 = new ai(-i2.xmag, i2.xmag, i2.ymag, -i2.ymag, i2.znear, i2.zfar)), n2.name && (e2.name = this.createUniqueName(n2.name)), oh(e2, n2), Promise.resolve(e2);
    console.warn("THREE.GLTFLoader: Missing camera parameters.");
  }
  loadSkin(t2) {
    const e2 = this.json.skins[t2], n2 = { joints: e2.joints };
    return e2.inverseBindMatrices === void 0 ? Promise.resolve(n2) : this.getDependency("accessor", e2.inverseBindMatrices).then(function(t3) {
      return n2.inverseBindMatrices = t3, n2;
    });
  }
  loadAnimation(t2) {
    const e2 = this.json.animations[t2], n2 = [], i2 = [], r2 = [], s2 = [], a2 = [];
    for (let t3 = 0, o2 = e2.channels.length; t3 < o2; t3++) {
      const o3 = e2.channels[t3], l2 = e2.samplers[o3.sampler], c2 = o3.target, h2 = c2.node !== void 0 ? c2.node : c2.id, u2 = e2.parameters !== void 0 ? e2.parameters[l2.input] : l2.input, d2 = e2.parameters !== void 0 ? e2.parameters[l2.output] : l2.output;
      n2.push(this.getDependency("node", h2)), i2.push(this.getDependency("accessor", u2)), r2.push(this.getDependency("accessor", d2)), s2.push(l2), a2.push(c2);
    }
    return Promise.all([Promise.all(n2), Promise.all(i2), Promise.all(r2), Promise.all(s2), Promise.all(a2)]).then(function(n3) {
      const i3 = n3[0], r3 = n3[1], s3 = n3[2], a3 = n3[3], o2 = n3[4], l2 = [];
      for (let t3 = 0, e3 = i3.length; t3 < e3; t3++) {
        const e4 = i3[t3], n4 = r3[t3], c3 = s3[t3], h2 = a3[t3], u2 = o2[t3];
        if (e4 === void 0)
          continue;
        let d2;
        switch (e4.updateMatrix(), e4.matrixAutoUpdate = true, th[u2.path]) {
          case th.weights:
            d2 = $o;
            break;
          case th.rotation:
            d2 = Qo;
            break;
          default:
            d2 = el;
        }
        const p2 = e4.name ? e4.name : e4.uuid, m2 = h2.interpolation !== void 0 ? eh[h2.interpolation] : 2301, f2 = [];
        th[u2.path] === th.weights ? e4.traverse(function(t4) {
          t4.morphTargetInfluences && f2.push(t4.name ? t4.name : t4.uuid);
        }) : f2.push(p2);
        let g2 = c3.array;
        if (c3.normalized) {
          const t4 = uh(g2.constructor), e5 = new Float32Array(g2.length);
          for (let n5 = 0, i4 = g2.length; n5 < i4; n5++)
            e5[n5] = g2[n5] * t4;
          g2 = e5;
        }
        for (let t4 = 0, e5 = f2.length; t4 < e5; t4++) {
          const e6 = new d2(f2[t4] + "." + th[u2.path], n4.array, g2, m2);
          h2.interpolation === "CUBICSPLINE" && (e6.createInterpolant = function(t5) {
            return new (this instanceof Qo ? Hc : zc)(this.times, this.values, this.getValueSize() / 3, t5);
          }, e6.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), l2.push(e6);
        }
      }
      const c2 = e2.name ? e2.name : "animation_" + t2;
      return new nl(c2, void 0, l2);
    });
  }
  createNodeMesh(t2) {
    const e2 = this.json, n2 = this, i2 = e2.nodes[t2];
    return i2.mesh === void 0 ? null : n2.getDependency("mesh", i2.mesh).then(function(t3) {
      const e3 = n2._getNodeRef(n2.meshCache, i2.mesh, t3);
      return i2.weights !== void 0 && e3.traverse(function(t4) {
        if (t4.isMesh)
          for (let e4 = 0, n3 = i2.weights.length; e4 < n3; e4++)
            t4.morphTargetInfluences[e4] = i2.weights[e4];
      }), e3;
    });
  }
  loadNode(t2) {
    const e2 = this.json, n2 = this.extensions, i2 = this, r2 = e2.nodes[t2], s2 = r2.name ? i2.createUniqueName(r2.name) : "";
    return function() {
      const e3 = [], n3 = i2._invokeOne(function(e4) {
        return e4.createNodeMesh && e4.createNodeMesh(t2);
      });
      return n3 && e3.push(n3), r2.camera !== void 0 && e3.push(i2.getDependency("camera", r2.camera).then(function(t3) {
        return i2._getNodeRef(i2.cameraCache, r2.camera, t3);
      })), i2._invokeAll(function(e4) {
        return e4.createNodeAttachment && e4.createNodeAttachment(t2);
      }).forEach(function(t3) {
        e3.push(t3);
      }), Promise.all(e3);
    }().then(function(e3) {
      let a2;
      if (a2 = r2.isBone === true ? new ua() : e3.length > 1 ? new Ds() : e3.length === 1 ? e3[0] : new Le(), a2 !== e3[0])
        for (let t3 = 0, n3 = e3.length; t3 < n3; t3++)
          a2.add(e3[t3]);
      if (r2.name && (a2.userData.name = r2.name, a2.name = s2), oh(a2, r2), r2.extensions && ah(n2, a2, r2), r2.matrix !== void 0) {
        const t3 = new re();
        t3.fromArray(r2.matrix), a2.applyMatrix4(t3);
      } else
        r2.translation !== void 0 && a2.position.fromArray(r2.translation), r2.rotation !== void 0 && a2.quaternion.fromArray(r2.rotation), r2.scale !== void 0 && a2.scale.fromArray(r2.scale);
      return i2.associations.has(a2) || i2.associations.set(a2, {}), i2.associations.get(a2).nodes = t2, a2;
    });
  }
  loadScene(t2) {
    const e2 = this.json, n2 = this.extensions, i2 = this.json.scenes[t2], r2 = this, s2 = new Ds();
    i2.name && (s2.name = r2.createUniqueName(i2.name)), oh(s2, i2), i2.extensions && ah(n2, s2, i2);
    const a2 = i2.nodes || [], o2 = [];
    for (let t3 = 0, n3 = a2.length; t3 < n3; t3++)
      o2.push(ph(a2[t3], s2, e2, r2));
    return Promise.all(o2).then(function() {
      return r2.associations = ((t3) => {
        const e3 = /* @__PURE__ */ new Map();
        for (const [t4, n3] of r2.associations)
          (t4 instanceof Ve || t4 instanceof wt) && e3.set(t4, n3);
        return t3.traverse((t4) => {
          const n3 = r2.associations.get(t4);
          n3 != null && e3.set(t4, n3);
        }), e3;
      })(s2), s2;
    });
  }
}
function ph(t2, e2, n2, i2) {
  const r2 = n2.nodes[t2];
  return i2.getDependency("node", t2).then(function(t3) {
    if (r2.skin === void 0)
      return t3;
    let e3;
    return i2.getDependency("skin", r2.skin).then(function(t4) {
      e3 = t4;
      const n3 = [];
      for (let t5 = 0, r3 = e3.joints.length; t5 < r3; t5++)
        n3.push(i2.getDependency("node", e3.joints[t5]));
      return Promise.all(n3);
    }).then(function(n3) {
      return t3.traverse(function(t4) {
        if (!t4.isMesh)
          return;
        const i3 = [], r3 = [];
        for (let t5 = 0, s2 = n3.length; t5 < s2; t5++) {
          const s3 = n3[t5];
          if (s3) {
            i3.push(s3);
            const n4 = new re();
            e3.inverseBindMatrices !== void 0 && n4.fromArray(e3.inverseBindMatrices.array, 16 * t5), r3.push(n4);
          } else
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e3.joints[t5]);
        }
        t4.bind(new fa(i3, r3), t4.matrixWorld);
      }), t3;
    });
  }).then(function(t3) {
    e2.add(t3);
    const s2 = [];
    if (r2.children) {
      const e3 = r2.children;
      for (let r3 = 0, a2 = e3.length; r3 < a2; r3++) {
        const a3 = e3[r3];
        s2.push(ph(a3, t3, n2, i2));
      }
    }
    return Promise.all(s2);
  });
}
function mh(t2, e2, n2) {
  const i2 = e2.attributes, r2 = [];
  function s2(e3, i3) {
    return n2.getDependency("accessor", e3).then(function(e4) {
      t2.setAttribute(i3, e4);
    });
  }
  for (const e3 in i2) {
    const n3 = Qc[e3] || e3.toLowerCase();
    n3 in t2.attributes || r2.push(s2(i2[e3], n3));
  }
  if (e2.indices !== void 0 && !t2.index) {
    const i3 = n2.getDependency("accessor", e2.indices).then(function(e3) {
      t2.setIndex(e3);
    });
    r2.push(i3);
  }
  return oh(t2, e2), function(t3, e3, n3) {
    const i3 = e3.attributes, r3 = new Ct();
    if (i3.POSITION === void 0)
      return;
    {
      const t4 = n3.json.accessors[i3.POSITION], e4 = t4.min, s4 = t4.max;
      if (e4 === void 0 || s4 === void 0)
        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      if (r3.set(new At(e4[0], e4[1], e4[2]), new At(s4[0], s4[1], s4[2])), t4.normalized) {
        const e5 = uh(Zc[t4.componentType]);
        r3.min.multiplyScalar(e5), r3.max.multiplyScalar(e5);
      }
    }
    const s3 = e3.targets;
    if (s3 !== void 0) {
      const t4 = new At(), e4 = new At();
      for (let i4 = 0, r4 = s3.length; i4 < r4; i4++) {
        const r5 = s3[i4];
        if (r5.POSITION !== void 0) {
          const i5 = n3.json.accessors[r5.POSITION], s4 = i5.min, a3 = i5.max;
          if (s4 !== void 0 && a3 !== void 0) {
            if (e4.setX(Math.max(Math.abs(s4[0]), Math.abs(a3[0]))), e4.setY(Math.max(Math.abs(s4[1]), Math.abs(a3[1]))), e4.setZ(Math.max(Math.abs(s4[2]), Math.abs(a3[2]))), i5.normalized) {
              const t5 = uh(Zc[i5.componentType]);
              e4.multiplyScalar(t5);
            }
            t4.max(e4);
          } else
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      r3.expandByVector(t4);
    }
    t3.boundingBox = r3;
    const a2 = new Zt();
    r3.getCenter(a2.center), a2.radius = r3.min.distanceTo(r3.max) / 2, t3.boundingSphere = a2;
  }(t2, e2, n2), Promise.all(r2).then(function() {
    return e2.targets !== void 0 ? function(t3, e3, n3) {
      let i3 = false, r3 = false;
      for (let t4 = 0, n4 = e3.length; t4 < n4; t4++) {
        const n5 = e3[t4];
        if (n5.POSITION !== void 0 && (i3 = true), n5.NORMAL !== void 0 && (r3 = true), i3 && r3)
          break;
      }
      if (!i3 && !r3)
        return Promise.resolve(t3);
      const s3 = [], a2 = [];
      for (let o2 = 0, l2 = e3.length; o2 < l2; o2++) {
        const l3 = e3[o2];
        if (i3) {
          const e4 = l3.POSITION !== void 0 ? n3.getDependency("accessor", l3.POSITION) : t3.attributes.position;
          s3.push(e4);
        }
        if (r3) {
          const e4 = l3.NORMAL !== void 0 ? n3.getDependency("accessor", l3.NORMAL) : t3.attributes.normal;
          a2.push(e4);
        }
      }
      return Promise.all([Promise.all(s3), Promise.all(a2)]).then(function(e4) {
        const n4 = e4[0], s4 = e4[1];
        return i3 && (t3.morphAttributes.position = n4), r3 && (t3.morphAttributes.normal = s4), t3.morphTargetsRelative = true, t3;
      });
    }(t2, e2.targets, n2) : t2;
  });
}
function fh(t2, e2) {
  let n2 = t2.getIndex();
  if (n2 === null) {
    const e3 = [], i3 = t2.getAttribute("position");
    if (i3 === void 0)
      return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t2;
    for (let t3 = 0; t3 < i3.count; t3++)
      e3.push(t3);
    t2.setIndex(e3), n2 = t2.getIndex();
  }
  const i2 = n2.count - 2, r2 = [];
  if (e2 === 2)
    for (let t3 = 1; t3 <= i2; t3++)
      r2.push(n2.getX(0)), r2.push(n2.getX(t3)), r2.push(n2.getX(t3 + 1));
  else
    for (let t3 = 0; t3 < i2; t3++)
      t3 % 2 == 0 ? (r2.push(n2.getX(t3)), r2.push(n2.getX(t3 + 1)), r2.push(n2.getX(t3 + 2))) : (r2.push(n2.getX(t3 + 2)), r2.push(n2.getX(t3 + 1)), r2.push(n2.getX(t3)));
  r2.length / 3 !== i2 && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  const s2 = t2.clone();
  return s2.setIndex(r2), s2;
}
class gh {
  constructor(t2 = 4) {
    this.pool = t2, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(t2) {
    if (!this.workers[t2]) {
      const e2 = this.workerCreator();
      e2.addEventListener("message", this._onMessage.bind(this, t2)), this.workers[t2] = e2;
    }
  }
  _getIdleWorker() {
    for (let t2 = 0; t2 < this.pool; t2++)
      if (!(this.workerStatus & 1 << t2))
        return t2;
    return -1;
  }
  _onMessage(t2, e2) {
    const n2 = this.workersResolve[t2];
    if (n2 && n2(e2), this.queue.length) {
      const { resolve: e3, msg: n3, transfer: i2 } = this.queue.shift();
      this.workersResolve[t2] = e3, this.workers[t2].postMessage(n3, i2);
    } else
      this.workerStatus ^= 1 << t2;
  }
  setWorkerCreator(t2) {
    this.workerCreator = t2;
  }
  setWorkerLimit(t2) {
    this.pool = t2;
  }
  postMessage(t2, e2) {
    return new Promise((n2) => {
      const i2 = this._getIdleWorker();
      i2 !== -1 ? (this._initWorker(i2), this.workerStatus |= 1 << i2, this.workersResolve[i2] = n2, this.workers[i2].postMessage(t2, e2)) : this.queue.push({ resolve: n2, msg: t2, transfer: e2 });
    });
  }
  dispose() {
    this.workers.forEach((t2) => t2.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
const vh = /* @__PURE__ */ new WeakMap();
let yh = 0;
class xh extends al {
  constructor(t2) {
    super(t2), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new gh(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER != "undefined" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
  }
  setTranscoderPath(t2) {
    return this.transcoderPath = t2, this;
  }
  setWorkerLimit(t2) {
    return this.workerPool.setWorkerLimit(t2), this;
  }
  detectSupport(t2) {
    return this.workerConfig = { astcSupported: t2.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: t2.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: t2.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: t2.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: t2.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: t2.extensions.has("WEBGL_compressed_texture_pvrtc") || t2.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, t2.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = false), this;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this;
  }
  init() {
    if (!this.transcoderPending) {
      const t2 = new ll(this.manager);
      t2.setPath(this.transcoderPath), t2.setWithCredentials(this.withCredentials);
      const e2 = t2.loadAsync("basis_transcoder.js"), n2 = new ll(this.manager);
      n2.setPath(this.transcoderPath), n2.setResponseType("arraybuffer"), n2.setWithCredentials(this.withCredentials);
      const i2 = n2.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([e2, i2]).then(([t3, e3]) => {
        const n3 = xh.BasisWorker.toString(), i3 = ["/* constants */", "let _EngineFormat = " + JSON.stringify(xh.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(xh.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(xh.BasisFormat), "/* basis_transcoder.js */", t3, "/* worker */", n3.substring(n3.indexOf("{") + 1, n3.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([i3])), this.transcoderBinary = e3, this.workerPool.setWorkerCreator(() => {
          const t4 = new Worker(this.workerSourceURL), e4 = this.transcoderBinary.slice(0);
          return t4.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: e4 }, [e4]), t4;
        });
      }), yh > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), yh++;
    }
    return this.transcoderPending;
  }
  load(t2, e2, n2, i2) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const r2 = new ll(this.manager);
    r2.setResponseType("arraybuffer"), r2.setWithCredentials(this.withCredentials);
    const s2 = new za();
    return r2.load(t2, (t3) => {
      if (vh.has(t3)) {
        return vh.get(t3).promise.then(e2).catch(i2);
      }
      this._createTexture([t3]).then(function(t4) {
        s2.copy(t4), s2.needsUpdate = true, e2 && e2(s2);
      }).catch(i2);
    }, n2, i2), s2;
  }
  _createTextureFrom(t2) {
    const { mipmaps: e2, width: n2, height: i2, format: r2, type: s2, error: a2, dfdTransferFn: o2, dfdFlags: l2 } = t2;
    if (s2 === "error")
      return Promise.reject(a2);
    const c2 = new za(e2, n2, i2, r2, 1009);
    return c2.minFilter = e2.length === 1 ? 1006 : 1008, c2.magFilter = 1006, c2.generateMipmaps = false, c2.needsUpdate = true, c2.encoding = o2 === 2 ? 3001 : 3e3, c2.premultiplyAlpha = !!(1 & l2), c2;
  }
  _createTexture(t2, e2 = {}) {
    const n2 = e2, i2 = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffers: t2, taskConfig: n2 }, t2)).then((t3) => this._createTextureFrom(t3.data));
    return vh.set(t2[0], { promise: i2 }), i2;
  }
  dispose() {
    return URL.revokeObjectURL(this.workerSourceURL), this.workerPool.dispose(), yh--, this;
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var bh, wh;
xh.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, xh.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, xh.EngineFormat = { RGBAFormat: 1023, RGBA_ASTC_4x4_Format: 37808, RGBA_BPTC_Format: 36492, RGBA_ETC2_EAC_Format: 37496, RGBA_PVRTC_4BPPV1_Format: 35842, RGBA_S3TC_DXT5_Format: 33779, RGB_ETC1_Format: 36196, RGB_ETC2_Format: 37492, RGB_PVRTC_4BPPV1_Format: 35840, RGB_S3TC_DXT1_Format: 33776 }, xh.BasisWorker = function() {
  let t2, e2, n2;
  const i2 = _EngineFormat, r2 = _TranscoderFormat, s2 = _BasisFormat;
  self.addEventListener("message", function(a3) {
    const h2 = a3.data;
    switch (h2.type) {
      case "init":
        t2 = h2.config, u2 = h2.transcoderBinary, e2 = new Promise((t3) => {
          n2 = { wasmBinary: u2, onRuntimeInitialized: t3 }, BASIS(n2);
        }).then(() => {
          n2.initializeBasis(), n2.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
        });
        break;
      case "transcode":
        e2.then(() => {
          try {
            const { width: e3, height: a4, hasAlpha: u3, mipmaps: d2, format: p2, dfdTransferFn: m2, dfdFlags: f2 } = function(e4) {
              const a5 = new n2.KTX2File(new Uint8Array(e4));
              function h3() {
                a5.close(), a5.delete();
              }
              if (!a5.isValid())
                throw h3(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
              const u4 = a5.isUASTC() ? s2.UASTC_4x4 : s2.ETC1S, d3 = a5.getWidth(), p3 = a5.getHeight(), m3 = a5.getLevels(), f3 = a5.getHasAlpha(), g3 = a5.getDFDTransferFunc(), v2 = a5.getDFDFlags(), { transcoderFormat: y2, engineFormat: x2 } = function(e5, n3, a6, h4) {
                let u5, d4;
                const p4 = e5 === s2.ETC1S ? o2 : l2;
                for (let i3 = 0; i3 < p4.length; i3++) {
                  const r3 = p4[i3];
                  if (t2[r3.if] && (r3.basisFormat.includes(e5) && !(h4 && r3.transcoderFormat.length < 2) && (!r3.needsPowerOfTwo || c2(n3) && c2(a6))))
                    return u5 = r3.transcoderFormat[h4 ? 1 : 0], d4 = r3.engineFormat[h4 ? 1 : 0], { transcoderFormat: u5, engineFormat: d4 };
                }
                return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), u5 = r2.RGBA32, d4 = i2.RGBAFormat, { transcoderFormat: u5, engineFormat: d4 };
              }(u4, d3, p3, f3);
              if (!d3 || !p3 || !m3)
                throw h3(), new Error("THREE.KTX2Loader:	Invalid texture");
              if (!a5.startTranscoding())
                throw h3(), new Error("THREE.KTX2Loader: .startTranscoding failed");
              const b2 = [];
              for (let t3 = 0; t3 < m3; t3++) {
                const e5 = a5.getImageLevelInfo(t3, 0, 0), n3 = e5.origWidth, i3 = e5.origHeight, r3 = new Uint8Array(a5.getImageTranscodedSizeInBytes(t3, 0, 0, y2));
                if (!a5.transcodeImage(r3, t3, 0, 0, y2, 0, -1, -1))
                  throw h3(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                b2.push({ data: r3, width: n3, height: i3 });
              }
              return h3(), { width: d3, height: p3, hasAlpha: f3, mipmaps: b2, format: x2, dfdTransferFn: g3, dfdFlags: v2 };
            }(h2.buffers[0]), g2 = [];
            for (let t3 = 0; t3 < d2.length; ++t3)
              g2.push(d2[t3].data.buffer);
            self.postMessage({ type: "transcode", id: h2.id, width: e3, height: a4, hasAlpha: u3, mipmaps: d2, format: p2, dfdTransferFn: m2, dfdFlags: f2 }, g2);
          } catch (t3) {
            console.error(t3), self.postMessage({ type: "error", id: h2.id, error: t3.message });
          }
        });
    }
    var u2;
  });
  const a2 = [{ if: "astcSupported", basisFormat: [s2.UASTC_4x4], transcoderFormat: [r2.ASTC_4x4, r2.ASTC_4x4], engineFormat: [i2.RGBA_ASTC_4x4_Format, i2.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: false }, { if: "bptcSupported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [r2.BC7_M5, r2.BC7_M5], engineFormat: [i2.RGBA_BPTC_Format, i2.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: false }, { if: "dxtSupported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [r2.BC1, r2.BC3], engineFormat: [i2.RGB_S3TC_DXT1_Format, i2.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: false }, { if: "etc2Supported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [r2.ETC1, r2.ETC2], engineFormat: [i2.RGB_ETC2_Format, i2.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: false }, { if: "etc1Supported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [r2.ETC1], engineFormat: [i2.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: false }, { if: "pvrtcSupported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [r2.PVRTC1_4_RGB, r2.PVRTC1_4_RGBA], engineFormat: [i2.RGB_PVRTC_4BPPV1_Format, i2.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: true }], o2 = a2.sort(function(t3, e3) {
    return t3.priorityETC1S - e3.priorityETC1S;
  }), l2 = a2.sort(function(t3, e3) {
    return t3.priorityUASTC - e3.priorityUASTC;
  });
  function c2(t3) {
    return t3 <= 2 || (t3 & t3 - 1) == 0 && t3 !== 0;
  }
};
const _h = Symbol("retainerCount"), Mh = Symbol("recentlyUsed"), Sh = Symbol("evict"), Th = Symbol("evictionThreshold"), Eh = Symbol("cache");
class Ah {
  constructor(t2, e2 = 5) {
    this[bh] = /* @__PURE__ */ new Map(), this[wh] = [], this[Eh] = t2, this[Th] = e2;
  }
  set evictionThreshold(t2) {
    this[Th] = t2, this[Sh]();
  }
  get evictionThreshold() {
    return this[Th];
  }
  get cache() {
    return this[Eh];
  }
  retainerCount(t2) {
    return this[_h].get(t2) || 0;
  }
  reset() {
    this[_h].clear(), this[Mh] = [];
  }
  retain(t2) {
    this[_h].has(t2) || this[_h].set(t2, 0), this[_h].set(t2, this[_h].get(t2) + 1);
    const e2 = this[Mh].indexOf(t2);
    e2 !== -1 && this[Mh].splice(e2, 1), this[Mh].unshift(t2), this[Sh]();
  }
  release(t2) {
    this[_h].has(t2) && this[_h].set(t2, Math.max(this[_h].get(t2) - 1, 0)), this[Sh]();
  }
  [(bh = _h, wh = Mh, Sh)]() {
    if (!(this[Mh].length < this[Th]))
      for (let t2 = this[Mh].length - 1; t2 >= this[Th]; --t2) {
        const e2 = this[Mh][t2];
        this[_h].get(e2) === 0 && (this[Eh].delete(e2), this[Mh].splice(t2, 1));
      }
  }
}
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Rh = (t2) => {
  const e2 = /* @__PURE__ */ new Map();
  for (const n2 of t2.mappings)
    for (const t3 of n2.variants)
      e2.set(t3, { material: null, gltfMaterialIndex: n2.material });
  return e2;
};
class Lh {
  constructor(t2) {
    this.parser = t2, this.name = "KHR_materials_variants";
  }
  afterRoot(t2) {
    const e2 = this.parser, n2 = e2.json;
    if (n2.extensions === void 0 || n2.extensions[this.name] === void 0)
      return null;
    const i2 = ((t3) => {
      const e3 = [], n3 = /* @__PURE__ */ new Set();
      for (const i3 of t3) {
        let t4 = i3, r2 = 0;
        for (; n3.has(t4); )
          t4 = i3 + "." + ++r2;
        n3.add(t4), e3.push(t4);
      }
      return e3;
    })((n2.extensions[this.name].variants || []).map((t3) => t3.name));
    for (const i3 of t2.scenes)
      i3.traverse((t3) => {
        const i4 = e2.associations.get(t3);
        if (i4 == null || i4.meshes == null)
          return;
        const r2 = i4.meshes, s2 = n2.meshes[r2].primitives, a2 = "isMesh" in t3 ? [t3] : t3.children;
        for (let t4 = 0; t4 < s2.length; t4++) {
          const e3 = s2[t4].extensions;
          e3 && e3[this.name] && (a2[t4].userData.variantMaterials = Rh(e3[this.name]));
        }
      });
    return t2.userData.variants = i2, Promise.resolve();
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Ch, Ph;
const Ih = /* @__PURE__ */ new Map(), Dh = /* @__PURE__ */ new Map();
let Nh;
const Fh = new class extends al {
  constructor(t2) {
    super(t2), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" };
  }
  setDecoderPath(t2) {
    return this.decoderPath = t2, this;
  }
  setDecoderConfig(t2) {
    return this.decoderConfig = t2, this;
  }
  setWorkerLimit(t2) {
    return this.workerLimit = t2, this;
  }
  load(t2, e2, n2, i2) {
    const r2 = new ll(this.manager);
    r2.setPath(this.path), r2.setResponseType("arraybuffer"), r2.setRequestHeader(this.requestHeader), r2.setWithCredentials(this.withCredentials), r2.load(t2, (t3) => {
      const n3 = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: false };
      this.decodeGeometry(t3, n3).then(e2).catch(i2);
    }, n2, i2);
  }
  decodeDracoFile(t2, e2, n2, i2) {
    const r2 = { attributeIDs: n2 || this.defaultAttributeIDs, attributeTypes: i2 || this.defaultAttributeTypes, useUniqueIDs: !!n2 };
    this.decodeGeometry(t2, r2).then(e2);
  }
  decodeGeometry(t2, e2) {
    for (const t3 in e2.attributeTypes) {
      const n3 = e2.attributeTypes[t3];
      n3.BYTES_PER_ELEMENT !== void 0 && (e2.attributeTypes[t3] = n3.name);
    }
    const n2 = JSON.stringify(e2);
    if (mc.has(t2)) {
      const e3 = mc.get(t2);
      if (e3.key === n2)
        return e3.promise;
      if (t2.byteLength === 0)
        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
    }
    let i2;
    const r2 = this.workerNextTaskID++, s2 = t2.byteLength, a2 = this._getWorker(r2, s2).then((n3) => (i2 = n3, new Promise((n4, s3) => {
      i2._callbacks[r2] = { resolve: n4, reject: s3 }, i2.postMessage({ type: "decode", id: r2, taskConfig: e2, buffer: t2 }, [t2]);
    }))).then((t3) => this._createGeometry(t3.geometry));
    return a2.catch(() => true).then(() => {
      i2 && r2 && this._releaseTask(i2, r2);
    }), mc.set(t2, { key: n2, promise: a2 }), a2;
  }
  _createGeometry(t2) {
    const e2 = new un();
    t2.index && e2.setIndex(new Qe(t2.index.array, 1));
    for (let n2 = 0; n2 < t2.attributes.length; n2++) {
      const i2 = t2.attributes[n2], r2 = i2.name, s2 = i2.array, a2 = i2.itemSize;
      e2.setAttribute(r2, new Qe(s2, a2));
    }
    return e2;
  }
  _loadLibrary(t2, e2) {
    const n2 = new ll(this.manager);
    return n2.setPath(this.decoderPath), n2.setResponseType(e2), n2.setWithCredentials(this.withCredentials), new Promise((e3, i2) => {
      n2.load(t2, e3, void 0, i2);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const t2 = typeof WebAssembly != "object" || this.decoderConfig.type === "js", e2 = [];
    return t2 ? e2.push(this._loadLibrary("draco_decoder.js", "text")) : (e2.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e2.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e2).then((e3) => {
      const n2 = e3[0];
      t2 || (this.decoderConfig.wasmBinary = e3[1]);
      const i2 = fc.toString(), r2 = ["/* draco decoder */", n2, "", "/* worker */", i2.substring(i2.indexOf("{") + 1, i2.lastIndexOf("}"))].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([r2]));
    }), this.decoderPending;
  }
  _getWorker(t2, e2) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const t3 = new Worker(this.workerSourceURL);
        t3._callbacks = {}, t3._taskCosts = {}, t3._taskLoad = 0, t3.postMessage({ type: "init", decoderConfig: this.decoderConfig }), t3.onmessage = function(e3) {
          const n3 = e3.data;
          switch (n3.type) {
            case "decode":
              t3._callbacks[n3.id].resolve(n3);
              break;
            case "error":
              t3._callbacks[n3.id].reject(n3);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + n3.type + '"');
          }
        }, this.workerPool.push(t3);
      } else
        this.workerPool.sort(function(t3, e3) {
          return t3._taskLoad > e3._taskLoad ? -1 : 1;
        });
      const n2 = this.workerPool[this.workerPool.length - 1];
      return n2._taskCosts[t2] = e2, n2._taskLoad += e2, n2;
    });
  }
  _releaseTask(t2, e2) {
    t2._taskLoad -= t2._taskCosts[e2], delete t2._callbacks[e2], delete t2._taskCosts[e2];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((t2) => t2._taskLoad));
  }
  dispose() {
    for (let t2 = 0; t2 < this.workerPool.length; ++t2)
      this.workerPool[t2].terminate();
    return this.workerPool.length = 0, this;
  }
}();
let Oh;
const Uh = new xh();
let kh, zh;
const Bh = Symbol("loader"), Hh = Symbol("evictionPolicy"), Vh = Symbol("GLTFInstance");
class Gh extends et {
  constructor(t2) {
    super(), this[Ph] = new gc().register((t3) => new Lh(t3)), this[Vh] = t2, this[Bh].setDRACOLoader(Fh), this[Bh].setKTX2Loader(Uh);
  }
  static setDRACODecoderLocation(t2) {
    Nh = t2, Fh.setDecoderPath(t2);
  }
  static getDRACODecoderLocation() {
    return Nh;
  }
  static setKTX2TranscoderLocation(t2) {
    Oh = t2, Uh.setTranscoderPath(t2);
  }
  static getKTX2TranscoderLocation() {
    return Oh;
  }
  static setMeshoptDecoderLocation(t2) {
    var e2;
    kh !== t2 && (kh = t2, zh = (e2 = t2, new Promise((t3, n2) => {
      const i2 = document.createElement("script");
      document.body.appendChild(i2), i2.onload = t3, i2.onerror = n2, i2.async = true, i2.src = e2;
    })).then(() => MeshoptDecoder.ready).then(() => MeshoptDecoder));
  }
  static getMeshoptDecoderLocation() {
    return kh;
  }
  static initializeKTX2Loader(t2) {
    Uh.detectSupport(t2);
  }
  static get cache() {
    return Ih;
  }
  static clearCache() {
    Ih.forEach((t2, e2) => {
      this.delete(e2);
    }), this[Hh].reset();
  }
  static has(t2) {
    return Ih.has(t2);
  }
  static async delete(t2) {
    if (!this.has(t2))
      return;
    const e2 = Ih.get(t2);
    Dh.delete(t2), Ih.delete(t2);
    (await e2).dispose();
  }
  static hasFinishedLoading(t2) {
    return !!Dh.get(t2);
  }
  get [(Ch = Hh, Ph = Bh, Hh)]() {
    return this.constructor[Hh];
  }
  async preload(t2, e2, n2 = () => {
  }) {
    if (this.dispatchEvent({ type: "preload", element: e2, src: t2 }), !Ih.has(t2)) {
      zh != null && this[Bh].setMeshoptDecoder(await zh);
      const e3 = ((t3, e4, n3 = () => {
      }) => {
        const i3 = (t4) => {
          const e5 = t4.loaded / t4.total;
          n3(Math.max(0, Math.min(1, isFinite(e5) ? e5 : 1)));
        };
        return new Promise((n4, r3) => {
          e4.load(t3, n4, i3, r3);
        });
      })(t2, this[Bh], (t3) => {
        n2(0.8 * t3);
      }), i2 = this[Vh], r2 = e3.then((t3) => i2.prepare(t3)).then((t3) => (n2(0.9), new i2(t3)));
      Ih.set(t2, r2);
    }
    await Ih.get(t2), Dh.set(t2, true), n2 && n2(1);
  }
  async load(t2, e2, n2 = () => {
  }) {
    await this.preload(t2, e2, n2);
    const i2 = await Ih.get(t2), r2 = await i2.clone();
    return this[Hh].retain(t2), r2.dispose = (() => {
      const e3 = r2.dispose;
      let n3 = false;
      return () => {
        n3 || (n3 = true, e3.apply(r2), this[Hh].release(t2));
      };
    })(), r2;
  }
}
Gh[Ch] = new Ah(Gh);
class Wh extends Le {
  constructor(t2 = document.createElement("div")) {
    super(), this.element = t2, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.addEventListener("removed", function() {
      this.traverse(function(t3) {
        t3.element instanceof Element && t3.element.parentNode !== null && t3.element.parentNode.removeChild(t3.element);
      });
    });
  }
  copy(t2, e2) {
    return super.copy(t2, e2), this.element = t2.element.cloneNode(true), this;
  }
}
Wh.prototype.isCSS2DObject = true;
const jh = new At(), qh = new re(), Xh = new re(), Yh = new At(), Zh = new At();
class Jh {
  constructor(t2 = {}) {
    const e2 = this;
    let n2, i2, r2, s2;
    const a2 = { objects: /* @__PURE__ */ new WeakMap() }, o2 = t2.element !== void 0 ? t2.element : document.createElement("div");
    function l2(t3, n3, i3) {
      if (t3.isCSS2DObject) {
        t3.onBeforeRender(e2, n3, i3), jh.setFromMatrixPosition(t3.matrixWorld), jh.applyMatrix4(Xh);
        const l3 = t3.element;
        /apple/i.test(navigator.vendor) ? l3.style.transform = "translate(-50%,-50%) translate(" + Math.round(jh.x * r2 + r2) + "px," + Math.round(-jh.y * s2 + s2) + "px)" : l3.style.transform = "translate(-50%,-50%) translate(" + (jh.x * r2 + r2) + "px," + (-jh.y * s2 + s2) + "px)", l3.style.display = t3.visible && jh.z >= -1 && jh.z <= 1 ? "" : "none";
        const h2 = { distanceToCameraSquared: c2(i3, t3) };
        a2.objects.set(t3, h2), l3.parentNode !== o2 && o2.appendChild(l3), t3.onAfterRender(e2, n3, i3);
      }
      for (let e3 = 0, r3 = t3.children.length; e3 < r3; e3++)
        l2(t3.children[e3], n3, i3);
    }
    function c2(t3, e3) {
      return Yh.setFromMatrixPosition(t3.matrixWorld), Zh.setFromMatrixPosition(e3.matrixWorld), Yh.distanceToSquared(Zh);
    }
    o2.style.overflow = "hidden", this.domElement = o2, this.getSize = function() {
      return { width: n2, height: i2 };
    }, this.render = function(t3, e3) {
      t3.autoUpdate === true && t3.updateMatrixWorld(), e3.parent === null && e3.updateMatrixWorld(), qh.copy(e3.matrixWorldInverse), Xh.multiplyMatrices(e3.projectionMatrix, qh), l2(t3, t3, e3), function(t4) {
        const e4 = function(t5) {
          const e5 = [];
          return t5.traverse(function(t6) {
            t6.isCSS2DObject && e5.push(t6);
          }), e5;
        }(t4).sort(function(t5, e5) {
          return a2.objects.get(t5).distanceToCameraSquared - a2.objects.get(e5).distanceToCameraSquared;
        }), n3 = e4.length;
        for (let t5 = 0, i3 = e4.length; t5 < i3; t5++)
          e4[t5].element.style.zIndex = n3 - t5;
      }(t3);
    }, this.setSize = function(t3, e3) {
      n2 = t3, i2 = e3, r2 = n2 / 2, s2 = i2 / 2, o2.style.width = t3 + "px", o2.style.height = e3 + "px";
    };
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $h = (t2) => t2 && t2 !== "null" ? Qh(t2) : null, Kh = () => {
  if (ac)
    return;
  const t2 = [];
  throw nc || t2.push("WebXR Device API"), ic || t2.push("WebXR Hit Test API"), new Error(`The following APIs are required for AR, but are missing in this browser: ${t2.join(", ")}`);
}, Qh = (t2) => new URL(t2, window.location.toString()).toString(), tu = (t2, e2) => {
  let n2 = null;
  return (...i2) => {
    n2 != null && self.clearTimeout(n2), n2 = self.setTimeout(() => {
      n2 = null, t2(...i2);
    }, e2);
  };
}, eu = (t2, e2, n2) => Math.max(e2, Math.min(n2, t2)), nu = (() => {
  const t2 = (() => {
    const t3 = document.head != null ? Array.from(document.head.querySelectorAll("meta")) : [];
    for (const e2 of t3)
      if (e2.name === "viewport")
        return true;
    return false;
  })();
  return t2 || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'), () => t2 ? window.devicePixelRatio : 1;
})(), iu = (() => {
  const t2 = new RegExp("[?&]model-viewer-debug-mode(&|$)");
  return () => self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(t2);
})(), ru = (t2 = 0) => new Promise((e2) => setTimeout(e2, t2));
class su {
  constructor(t2 = 50) {
    this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(t2);
  }
  setDecayTime(t2) {
    this.naturalFrequency = 1 / Math.max(1e-3, t2);
  }
  update(t2, e2, n2, i2) {
    const r2 = 2e-4 * this.naturalFrequency;
    if (t2 == null || i2 === 0)
      return e2;
    if (t2 === e2 && this.velocity === 0)
      return e2;
    if (n2 < 0)
      return t2;
    const s2 = t2 - e2, a2 = this.velocity + this.naturalFrequency * s2, o2 = s2 + n2 * a2, l2 = Math.exp(-this.naturalFrequency * n2), c2 = (a2 - this.naturalFrequency * o2) * l2, h2 = -this.naturalFrequency * (c2 + a2 * l2);
    return Math.abs(c2) < r2 * Math.abs(i2) && h2 * s2 >= 0 ? (this.velocity = 0, e2) : (this.velocity = c2, e2 + o2 * l2);
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const au = (t2, e2) => ({ type: "number", number: t2, unit: e2 }), ou = (() => {
  const t2 = {};
  return (e2) => {
    const n2 = e2;
    if (n2 in t2)
      return t2[n2];
    const i2 = [];
    let r2 = 0;
    for (; e2; ) {
      if (++r2 > 1e3) {
        e2 = "";
        break;
      }
      const t3 = lu(e2), n3 = t3.nodes[0];
      if (n3 == null || n3.terms.length === 0)
        break;
      i2.push(n3), e2 = t3.remainingInput;
    }
    return t2[n2] = i2;
  };
})(), lu = (() => {
  const t2 = /^(\-\-|[a-z\u0240-\uffff])/i, e2 = /^([\*\+\/]|[\-]\s)/i, n2 = /^[\),]/;
  return (i2) => {
    const r2 = [];
    for (; i2.length && (i2 = i2.trim(), !n2.test(i2)); )
      if (i2[0] === "(") {
        const { nodes: t3, remainingInput: e3 } = du(i2);
        i2 = e3, r2.push({ type: "function", name: { type: "ident", value: "calc" }, arguments: t3 });
      } else if (t2.test(i2)) {
        const t3 = cu(i2), e3 = t3.nodes[0];
        if ((i2 = t3.remainingInput)[0] === "(") {
          const { nodes: t4, remainingInput: n3 } = du(i2);
          r2.push({ type: "function", name: e3, arguments: t4 }), i2 = n3;
        } else
          r2.push(e3);
      } else if (e2.test(i2))
        r2.push({ type: "operator", value: i2[0] }), i2 = i2.slice(1);
      else {
        const { nodes: t3, remainingInput: e3 } = i2[0] === "#" ? uu(i2) : hu(i2);
        if (t3.length === 0)
          break;
        r2.push(t3[0]), i2 = e3;
      }
    return { nodes: [{ type: "expression", terms: r2 }], remainingInput: i2 };
  };
})(), cu = (() => {
  const t2 = /[^a-z0-9_\-\u0240-\uffff]/i;
  return (e2) => {
    const n2 = e2.match(t2);
    return { nodes: [{ type: "ident", value: n2 == null ? e2 : e2.substr(0, n2.index) }], remainingInput: n2 == null ? "" : e2.substr(n2.index) };
  };
})(), hu = (() => {
  const t2 = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/, e2 = /^[a-z%]+/i, n2 = /^(m|mm|cm|rad|deg|[%])$/;
  return (i2) => {
    const r2 = i2.match(t2), s2 = r2 == null ? "0" : r2[0], a2 = (i2 = s2 == null ? i2 : i2.slice(s2.length)).match(e2);
    let o2 = a2 != null && a2[0] !== "" ? a2[0] : null;
    const l2 = a2 == null ? i2 : i2.slice(o2.length);
    return o2 == null || n2.test(o2) || (o2 = null), { nodes: [{ type: "number", number: parseFloat(s2) || 0, unit: o2 }], remainingInput: l2 };
  };
})(), uu = (() => {
  const t2 = /^[a-f0-9]*/i;
  return (e2) => {
    const n2 = (e2 = e2.slice(1).trim()).match(t2);
    return { nodes: n2 == null ? [] : [{ type: "hex", value: n2[0] }], remainingInput: n2 == null ? e2 : e2.slice(n2[0].length) };
  };
})(), du = (t2) => {
  const e2 = [];
  for (t2 = t2.slice(1).trim(); t2.length; ) {
    const n2 = lu(t2);
    if (e2.push(n2.nodes[0]), (t2 = n2.remainingInput.trim())[0] === ",")
      t2 = t2.slice(1).trim();
    else if (t2[0] === ")") {
      t2 = t2.slice(1);
      break;
    }
  }
  return { nodes: e2, remainingInput: t2 };
}, pu = Symbol("visitedTypes");
class mu {
  constructor(t2) {
    this[pu] = t2;
  }
  walk(t2, e2) {
    const n2 = t2.slice();
    for (; n2.length; ) {
      const t3 = n2.shift();
      switch (this[pu].indexOf(t3.type) > -1 && e2(t3), t3.type) {
        case "expression":
          n2.unshift(...t3.terms);
          break;
        case "function":
          n2.unshift(t3.name, ...t3.arguments);
      }
    }
  }
}
const fu = Object.freeze({ type: "number", number: 0, unit: null }), gu = (t2, e2 = 0) => {
  let { number: n2, unit: i2 } = t2;
  if (isFinite(n2)) {
    if (t2.unit === "rad" || t2.unit == null)
      return t2;
  } else
    n2 = e2, i2 = "rad";
  return { type: "number", number: (i2 === "deg" && n2 != null ? n2 : 0) * Math.PI / 180, unit: "rad" };
}, vu = (t2, e2 = 0) => {
  let n2, { number: i2, unit: r2 } = t2;
  if (isFinite(i2)) {
    if (t2.unit === "m")
      return t2;
  } else
    i2 = e2, r2 = "m";
  switch (r2) {
    default:
      n2 = 1;
      break;
    case "cm":
      n2 = 0.01;
      break;
    case "mm":
      n2 = 1e-3;
  }
  return { type: "number", number: n2 * i2, unit: "m" };
}, yu = (() => {
  const t2 = (t3) => t3, e2 = { rad: t2, deg: gu, m: t2, mm: vu, cm: vu };
  return (t3, n2 = fu) => {
    isFinite(t3.number) || (t3.number = n2.number, t3.unit = n2.unit);
    const { unit: i2 } = t3;
    if (i2 == null)
      return t3;
    const r2 = e2[i2];
    return r2 == null ? n2 : r2(t3);
  };
})();
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xu extends Wh {
  constructor(t2) {
    super(document.createElement("div")), this.normal = new At(0, 1, 0), this.initialized = false, this.referenceCount = 1, this.pivot = document.createElement("div"), this.slot = document.createElement("slot"), this.element.classList.add("annotation-wrapper"), this.slot.name = t2.name, this.element.appendChild(this.pivot), this.pivot.appendChild(this.slot), this.updatePosition(t2.position), this.updateNormal(t2.normal);
  }
  get facingCamera() {
    return !this.element.classList.contains("hide");
  }
  show() {
    this.facingCamera && this.initialized || this.updateVisibility(true);
  }
  hide() {
    !this.facingCamera && this.initialized || this.updateVisibility(false);
  }
  increment() {
    this.referenceCount++;
  }
  decrement() {
    return this.referenceCount > 0 && --this.referenceCount, this.referenceCount === 0;
  }
  updatePosition(t2) {
    if (t2 == null)
      return;
    const e2 = ou(t2)[0].terms;
    for (let t3 = 0; t3 < 3; ++t3)
      this.position.setComponent(t3, yu(e2[t3]).number);
    this.updateMatrixWorld();
  }
  updateNormal(t2) {
    if (t2 == null)
      return;
    const e2 = ou(t2)[0].terms;
    for (let t3 = 0; t3 < 3; ++t3)
      this.normal.setComponent(t3, yu(e2[t3]).number);
  }
  orient(t2) {
    this.pivot.style.transform = `rotate(${t2}rad)`;
  }
  updateVisibility(t2) {
    t2 ? this.element.classList.remove("hide") : this.element.classList.add("hide"), this.slot.assignedNodes().forEach((e2) => {
      if (e2.nodeType !== Node.ELEMENT_NODE)
        return;
      const n2 = e2, i2 = n2.dataset.visibilityAttribute;
      if (i2 != null) {
        const e3 = `data-${i2}`;
        t2 ? n2.setAttribute(e3, "") : n2.removeAttribute(e3);
      }
      n2.dispatchEvent(new CustomEvent("hotspot-visibility", { detail: { visible: t2 } }));
    }), this.initialized = true;
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bu = (t2, e2, n2) => {
  let i2 = n2;
  const r2 = new At();
  return t2.traverse((t3) => {
    let n3, s2;
    t3.updateWorldMatrix(false, false);
    const a2 = t3.geometry;
    if (a2 !== void 0) {
      if (a2.isGeometry) {
        const o2 = a2.vertices;
        for (n3 = 0, s2 = o2.length; n3 < s2; n3++)
          r2.copy(o2[n3]), r2.applyMatrix4(t3.matrixWorld), i2 = e2(i2, r2);
      } else if (a2.isBufferGeometry) {
        const { position: o2 } = a2.attributes;
        if (o2 !== void 0) {
          const a3 = ((t4) => {
            if (!t4.normalized)
              return 1;
            const e3 = t4.array;
            return e3 instanceof Int8Array ? 1 / 127 : e3 instanceof Uint8Array ? 1 / 255 : e3 instanceof Int16Array ? 1 / 32767 : e3 instanceof Uint16Array ? 1 / 65535 : 1;
          })(o2);
          for (n3 = 0, s2 = o2.count; n3 < s2; n3++)
            r2.fromBufferAttribute(o2, n3), r2.multiplyScalar(a3), r2.applyMatrix4(t3.matrixWorld), i2 = e2(i2, r2);
        }
      }
    }
  }), i2;
};
class wu extends El {
  constructor(t2, e2, n2) {
    super(), this.shadowMaterial = new Bo(), this.boundingBox = new Ct(), this.size = new At(), this.shadowScale = 1, this.isAnimated = false, this.side = "bottom", this.needsUpdate = false, this.intensity = 0, this.castShadow = true, this.frustumCulled = false, this.floor = new Ln(new Jn(), this.shadowMaterial), this.floor.rotateX(-Math.PI / 2), this.floor.receiveShadow = true, this.floor.castShadow = false, this.floor.frustumCulled = false, this.add(this.floor), t2.target.add(this), this.target = t2.target, this.setScene(t2, e2, n2);
  }
  setScene(t2, e2, n2) {
    if (this.side = n2, this.isAnimated = t2.animationNames.length > 0, this.boundingBox.copy(t2.boundingBox), this.size.copy(t2.size), this.side === "back") {
      const { min: t3, max: e3 } = this.boundingBox;
      [t3.y, t3.z] = [t3.z, t3.y], [e3.y, e3.z] = [e3.z, e3.y], [this.size.y, this.size.z] = [this.size.z, this.size.y], this.rotation.x = Math.PI / 2, this.rotation.y = Math.PI;
    } else
      this.rotation.x = 0, this.rotation.y = 0;
    const { boundingBox: i2, size: r2 } = this;
    if (this.isAnimated) {
      const t3 = 2 * Math.max(r2.x, r2.y, r2.z);
      r2.y = t3, i2.expandByVector(r2.subScalar(t3).multiplyScalar(-0.5)), i2.max.y = i2.min.y + t3, r2.set(t3, t3, t3);
    }
    i2.getCenter(this.floor.position);
    const s2 = i2.max.y + 2e-3 * r2.y;
    n2 === "bottom" ? (this.position.y = s2, this.position.z = 0) : (this.position.y = 0, this.position.z = s2), this.setSoftness(e2);
  }
  setSoftness(t2) {
    const e2 = Math.pow(2, 9 - 3 * t2);
    this.setMapSize(e2);
  }
  setMapSize(t2) {
    const { camera: e2, mapSize: n2, map: i2 } = this.shadow, { size: r2, boundingBox: s2 } = this;
    i2 != null && (i2.dispose(), this.shadow.map = null), this.isAnimated && (t2 *= 2);
    const a2 = Math.floor(r2.x > r2.z ? t2 : t2 * r2.x / r2.z), o2 = Math.floor(r2.x > r2.z ? t2 * r2.z / r2.x : t2);
    n2.set(a2, o2);
    const l2 = 2.5 * r2.x / a2, c2 = 2.5 * r2.z / o2;
    e2.left = -s2.max.x - l2, e2.right = -s2.min.x + l2, e2.bottom = s2.min.z - c2, e2.top = s2.max.z + c2, this.setScaleAndOffset(this.shadowScale, 0), this.floor.scale.set(r2.x + 2 * l2, r2.z + 2 * c2, 1), this.needsUpdate = true, this.shadow.needsUpdate = true;
  }
  setIntensity(t2) {
    this.shadowMaterial.opacity = t2, t2 > 0 ? (this.visible = true, this.floor.visible = true) : (this.visible = false, this.floor.visible = false);
  }
  getIntensity() {
    return this.shadowMaterial.opacity;
  }
  setRotation(t2) {
    if (this.side !== "bottom")
      return this.shadow.camera.up.set(0, 1, 0), void this.shadow.updateMatrices(this);
    this.shadow.camera.up.set(Math.sin(t2), 0, Math.cos(t2)), this.shadow.updateMatrices(this);
  }
  setScaleAndOffset(t2, e2) {
    const n2 = this.size.y, { camera: i2 } = this.shadow;
    this.shadowScale = t2, i2.near = 0, i2.far = n2 - e2 / t2, i2.updateProjectionMatrix(), i2.scale.setScalar(t2);
    const r2 = 2e-3 * n2;
    this.floor.position.y = 2 * r2 - i2.far;
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _u = new At(), Mu = new At(), Su = new At(), Tu = new class {
  constructor(t2, e2, n2 = 0, i2 = 1 / 0) {
    this.ray = new ie(t2, e2), this.near = n2, this.far = i2, this.camera = null, this.layers = new fe(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(t2, e2) {
    this.ray.set(t2, e2);
  }
  setFromCamera(t2, e2) {
    e2 && e2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e2.matrixWorld), this.ray.direction.set(t2.x, t2.y, 0.5).unproject(e2).sub(this.ray.origin).normalize(), this.camera = e2) : e2 && e2.isOrthographicCamera ? (this.ray.origin.set(t2.x, t2.y, (e2.near + e2.far) / (e2.near - e2.far)).unproject(e2), this.ray.direction.set(0, 0, -1).transformDirection(e2.matrixWorld), this.camera = e2) : console.error("THREE.Raycaster: Unsupported camera type: " + e2.type);
  }
  intersectObject(t2, e2 = true, n2 = []) {
    return Xl(t2, this, n2, e2), n2.sort(ql), n2;
  }
  intersectObjects(t2, e2 = true, n2 = []) {
    for (let i2 = 0, r2 = t2.length; i2 < r2; i2++)
      Xl(t2[i2], this, n2, e2);
    return n2.sort(ql), n2;
  }
}(), Eu = new At(), Au = new mt();
class Ru extends Bs {
  constructor({ canvas: t2, element: e2, width: n2, height: i2 }) {
    super(), this.context = null, this.annotationRenderer = new Jh(), this.schemaElement = document.createElement("script"), this.width = 1, this.height = 1, this.aspect = 1, this.renderCount = 0, this.externalRenderer = null, this.camera = new Un(45, 1, 0.1, 100), this.xrCamera = null, this.url = null, this.target = new Le(), this.modelContainer = new Le(), this.animationNames = [], this.boundingBox = new Ct(), this.size = new At(), this.idealAspect = 0, this.framedFoVDeg = 45, this.boundingRadius = 0, this.shadow = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.exposure = 1, this.canScale = true, this.tightBounds = false, this.isDirty = false, this.goalTarget = new At(), this.targetDamperX = new su(), this.targetDamperY = new su(), this.targetDamperZ = new su(), this._currentGLTF = null, this.cancelPendingSourceChange = null, this.animationsByName = /* @__PURE__ */ new Map(), this.currentAnimationAction = null, this.name = "ModelScene", this.element = e2, this.canvas = t2, this.camera = new Un(45, 1, 0.1, 100), this.camera.name = "MainCamera", this.add(this.target), this.setSize(n2, i2), this.target.name = "Target", this.modelContainer.name = "ModelContainer", this.target.add(this.modelContainer), this.mixer = new jl(this.modelContainer);
    const { domElement: r2 } = this.annotationRenderer, { style: s2 } = r2;
    s2.display = "none", s2.pointerEvents = "none", s2.position = "absolute", s2.top = "0", this.element.shadowRoot.querySelector(".default").appendChild(r2), this.schemaElement.setAttribute("type", "application/ld+json");
  }
  createContext() {
    this.context = this.canvas.getContext("2d");
  }
  getCamera() {
    return this.xrCamera != null ? this.xrCamera : this.camera;
  }
  queueRender() {
    this.isDirty = true;
  }
  shouldRender() {
    return this.isDirty;
  }
  hasRendered() {
    this.isDirty = false;
  }
  async setObject(t2) {
    this.reset(), this.modelContainer.add(t2), await this.setupScene();
  }
  async setSource(t2, e2 = () => {
  }) {
    if (!t2 || t2 === this.url)
      return void e2(1);
    if (this.reset(), this.url = t2, this.externalRenderer != null) {
      const t3 = await this.externalRenderer.load(e2);
      return this.boundingRadius = t3.framedRadius, this.idealAspect = t3.fieldOfViewAspect, void this.dispatchEvent({ type: "model-load", url: this.url });
    }
    let n2;
    this.cancelPendingSourceChange != null && (this.cancelPendingSourceChange(), this.cancelPendingSourceChange = null);
    try {
      n2 = await new Promise(async (n3, i3) => {
        this.cancelPendingSourceChange = () => i3();
        try {
          n3(await this.element[op].loader.load(t2, this.element, e2));
        } catch (t3) {
          i3(t3);
        }
      });
    } catch (t3) {
      if (t3 == null)
        return;
      throw t3;
    }
    this.reset(), this.url = t2, this._currentGLTF = n2, n2 != null && this.modelContainer.add(n2.scene);
    const { animations: i2 } = n2, r2 = /* @__PURE__ */ new Map(), s2 = [];
    for (const t3 of i2)
      r2.set(t3.name, t3), s2.push(t3.name);
    this.animations = i2, this.animationsByName = r2, this.animationNames = s2, await this.setupScene();
  }
  async setupScene() {
    this.updateBoundingBox(), await this.updateFraming(), this.updateShadow(), this.setShadowIntensity(this.shadowIntensity), this.dispatchEvent({ type: "model-load", url: this.url });
  }
  reset() {
    this.url = null, this.queueRender(), this.shadow != null && this.shadow.setIntensity(0);
    const t2 = this._currentGLTF;
    if (t2 != null) {
      for (const t3 of this.modelContainer.children)
        this.modelContainer.remove(t3);
      t2.dispose(), this._currentGLTF = null;
    }
    this.currentAnimationAction != null && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this);
  }
  get currentGLTF() {
    return this._currentGLTF;
  }
  setSize(t2, e2) {
    if (this.width !== t2 || this.height !== e2) {
      if (this.width = Math.max(t2, 1), this.height = Math.max(e2, 1), this.annotationRenderer.setSize(t2, e2), this.aspect = this.width / this.height, this.externalRenderer != null) {
        const n2 = nu();
        this.externalRenderer.resize(t2 * n2, e2 * n2);
      }
      this.queueRender();
    }
  }
  updateBoundingBox() {
    if (this.target.remove(this.modelContainer), this.tightBounds === true) {
      const t2 = (t3, e2) => t3.expandByPoint(e2);
      this.boundingBox = bu(this.modelContainer, t2, new Ct());
    } else
      this.boundingBox.setFromObject(this.modelContainer);
    this.boundingBox.getSize(this.size), this.target.add(this.modelContainer);
  }
  async updateFraming() {
    this.target.remove(this.modelContainer);
    let t2 = this.boundingBox.getCenter(new At());
    this.tightBounds === true && (await this.element.requestUpdate("cameraTarget"), t2 = this.getTarget());
    this.boundingRadius = Math.sqrt(bu(this.modelContainer, (e2, n2) => Math.max(e2, t2.distanceToSquared(n2)), 0));
    this.idealAspect = bu(this.modelContainer, (e2, n2) => {
      n2.sub(t2);
      const i2 = Math.sqrt(n2.x * n2.x + n2.z * n2.z);
      return Math.max(e2, i2 / (this.idealCameraDistance() - Math.abs(n2.y)));
    }, 0) / Math.tan(this.framedFoVDeg / 2 * Math.PI / 180), this.target.add(this.modelContainer);
  }
  idealCameraDistance() {
    const t2 = this.framedFoVDeg / 2 * Math.PI / 180;
    return this.boundingRadius / Math.sin(t2);
  }
  adjustedFoV(t2) {
    const e2 = Math.tan(t2 / 2 * Math.PI / 180) * Math.max(1, this.idealAspect / this.aspect);
    return 2 * Math.atan(e2) * 180 / Math.PI;
  }
  getNDC(t2, e2) {
    if (this.xrCamera != null)
      Au.set(t2 / window.screen.width, e2 / window.screen.height);
    else {
      const n2 = this.element.getBoundingClientRect();
      Au.set((t2 - n2.x) / this.width, (e2 - n2.y) / this.height);
    }
    return Au.multiplyScalar(2).subScalar(1), Au.y *= -1, Au;
  }
  getSize() {
    return { width: this.width, height: this.height };
  }
  setTarget(t2, e2, n2) {
    this.goalTarget.set(-t2, -e2, -n2);
  }
  setTargetDamperDecayTime(t2) {
    this.targetDamperX.setDecayTime(t2), this.targetDamperY.setDecayTime(t2), this.targetDamperZ.setDecayTime(t2);
  }
  getTarget() {
    return Eu.copy(this.goalTarget).multiplyScalar(-1);
  }
  jumpToGoal() {
    this.updateTarget(1e4);
  }
  updateTarget(t2) {
    const e2 = this.goalTarget, n2 = this.target.position;
    if (!e2.equals(n2)) {
      const i2 = this.boundingRadius / 10;
      let { x: r2, y: s2, z: a2 } = n2;
      r2 = this.targetDamperX.update(r2, e2.x, t2, i2), s2 = this.targetDamperY.update(s2, e2.y, t2, i2), a2 = this.targetDamperZ.update(a2, e2.z, t2, i2), this.target.position.set(r2, s2, a2), this.target.updateMatrixWorld(), this.setShadowRotation(this.yaw), this.queueRender();
    }
  }
  pointTowards(t2, e2) {
    const { x: n2, z: i2 } = this.position;
    this.yaw = Math.atan2(t2 - n2, e2 - i2);
  }
  set yaw(t2) {
    this.rotation.y = t2, this.updateMatrixWorld(true), this.setShadowRotation(t2), this.queueRender();
  }
  get yaw() {
    return this.rotation.y;
  }
  set animationTime(t2) {
    this.mixer.setTime(t2);
  }
  get animationTime() {
    if (this.currentAnimationAction != null) {
      const t2 = Math.max(this.currentAnimationAction._loopCount, 0);
      return this.currentAnimationAction.loop === 2202 && (1 & t2) == 1 ? this.duration - this.currentAnimationAction.time : this.currentAnimationAction.time;
    }
    return 0;
  }
  get duration() {
    return this.currentAnimationAction != null && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0;
  }
  get hasActiveAnimation() {
    return this.currentAnimationAction != null;
  }
  playAnimation(t2 = null, e2 = 0, n2 = 2201, i2 = 1 / 0) {
    if (this._currentGLTF == null)
      return;
    const { animations: r2 } = this;
    if (r2 == null || r2.length === 0)
      return void console.warn("Cannot play animation (model does not have any animations)");
    let s2 = null;
    t2 != null && (s2 = this.animationsByName.get(t2)), s2 == null && (s2 = r2[0]);
    try {
      const { currentAnimationAction: t3 } = this, r3 = this.mixer.clipAction(s2, this);
      this.currentAnimationAction = r3, this.element.paused ? this.mixer.stopAllAction() : t3 != null && r3 !== t3 && r3.crossFadeFrom(t3, e2, false), r3.setLoop(n2, i2), r3.enabled = true, r3.play();
    } catch (t3) {
      console.error(t3);
    }
  }
  stopAnimation() {
    this.currentAnimationAction = null, this.mixer.stopAllAction();
  }
  updateAnimation(t2) {
    this.mixer.update(t2);
  }
  subscribeMixerEvent(t2, e2) {
    this.mixer.addEventListener(t2, e2);
  }
  updateShadow() {
    const t2 = this.shadow;
    if (t2 != null) {
      const e2 = this.element.arPlacement === "wall" ? "back" : "bottom";
      t2.setScene(this, this.shadowSoftness, e2), t2.setRotation(this.yaw);
    }
  }
  setShadowIntensity(t2) {
    if (this.shadowIntensity = t2, this._currentGLTF != null && !(t2 <= 0 && this.shadow == null)) {
      if (this.shadow == null) {
        const t3 = this.element.arPlacement === "wall" ? "back" : "bottom";
        this.shadow = new wu(this, this.shadowSoftness, t3), this.shadow.setRotation(this.yaw);
      }
      this.shadow.setIntensity(t2);
    }
  }
  setShadowSoftness(t2) {
    this.shadowSoftness = t2;
    const e2 = this.shadow;
    e2 != null && e2.setSoftness(t2);
  }
  setShadowRotation(t2) {
    const e2 = this.shadow;
    e2 != null && e2.setRotation(t2);
  }
  isShadowDirty() {
    const t2 = this.shadow;
    if (t2 == null)
      return false;
    {
      const { needsUpdate: e2 } = t2;
      return t2.needsUpdate = false, e2;
    }
  }
  setShadowScaleAndOffset(t2, e2) {
    const n2 = this.shadow;
    n2 != null && n2.setScaleAndOffset(t2, e2);
  }
  get raycaster() {
    return Tu;
  }
  positionAndNormalFromPoint(t2, e2 = this) {
    this.raycaster.setFromCamera(t2, this.getCamera());
    const n2 = this.raycaster.intersectObject(e2, true);
    if (n2.length === 0)
      return null;
    const i2 = n2[0];
    return i2.face == null ? null : i2.uv == null ? { position: i2.point, normal: i2.face.normal, uv: null } : (i2.face.normal.applyNormalMatrix(new ft().getNormalMatrix(i2.object.matrixWorld)), { position: i2.point, normal: i2.face.normal, uv: i2.uv });
  }
  addHotspot(t2) {
    this.target.add(t2), this.annotationRenderer.domElement.appendChild(t2.element);
  }
  removeHotspot(t2) {
    this.target.remove(t2);
  }
  forHotspots(t2) {
    const { children: e2 } = this.target;
    for (let n2 = 0, i2 = e2.length; n2 < i2; n2++) {
      const i3 = e2[n2];
      i3 instanceof xu && t2(i3);
    }
  }
  updateHotspots(t2) {
    this.forHotspots((e2) => {
      _u.copy(t2), Mu.setFromMatrixPosition(e2.matrixWorld), _u.sub(Mu), Su.copy(e2.normal).transformDirection(this.target.matrixWorld), _u.dot(Su) < 0 ? e2.hide() : e2.show();
    });
  }
  orientHotspots(t2) {
    this.forHotspots((e2) => {
      e2.orient(t2);
    });
  }
  setHotspotsVisibility(t2) {
    this.forHotspots((e2) => {
      e2.visible = t2;
    });
  }
  updateSchema(t2) {
    var e2;
    const { schemaElement: n2, element: i2 } = this, { alt: r2, poster: s2, iosSrc: a2 } = i2;
    if (t2 != null) {
      const i3 = [{ "@type": "MediaObject", contentUrl: t2, encodingFormat: ((e2 = t2.split(".").pop()) === null || e2 === void 0 ? void 0 : e2.toLowerCase()) === "gltf" ? "model/gltf+json" : "model/gltf-binary" }];
      a2 && i3.push({ "@type": "MediaObject", contentUrl: a2, encodingFormat: "model/vnd.usdz+zip" });
      const o2 = { "@context": "http://schema.org/", "@type": "3DModel", image: s2 != null ? s2 : void 0, name: r2 != null ? r2 : void 0, encoding: i3 };
      n2.textContent = JSON.stringify(o2), document.head.appendChild(n2);
    } else
      n2.parentElement != null && n2.parentElement.removeChild(n2);
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Lu = function(t2, e2, n2, i2) {
  for (var r2, s2 = arguments.length, a2 = s2 < 3 ? e2 : i2 === null ? i2 = Object.getOwnPropertyDescriptor(e2, n2) : i2, o2 = t2.length - 1; o2 >= 0; o2--)
    (r2 = t2[o2]) && (a2 = (s2 < 3 ? r2(a2) : s2 > 3 ? r2(e2, n2, a2) : r2(e2, n2)) || a2);
  return s2 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
};
const Cu = Symbol("currentEnvironmentMap"), Pu = Symbol("applyEnvironmentMap"), Iu = Symbol("updateEnvironment"), Du = Symbol("cancelEnvironmentUpdate"), Nu = Symbol("onPreload");
class Fu {
  constructor(t2, e2, n2, i2, r2) {
    this.xrLight = t2, this.renderer = e2, this.lightProbe = n2, this.xrWebGLBinding = null, this.estimationStartCallback = r2, this.frameCallback = this.onXRFrame.bind(this);
    const s2 = e2.xr.getSession();
    if (i2 && "XRWebGLBinding" in window) {
      const n3 = new Bn(16);
      t2.environment = n3.texture;
      const i3 = e2.getContext();
      switch (s2.preferredReflectionFormat) {
        case "srgba8":
          i3.getExtension("EXT_sRGB");
          break;
        case "rgba16f":
          i3.getExtension("OES_texture_half_float");
      }
      this.xrWebGLBinding = new XRWebGLBinding(s2, i3), this.lightProbe.addEventListener("reflectionchange", () => {
        this.updateReflection();
      });
    }
    s2.requestAnimationFrame(this.frameCallback);
  }
  updateReflection() {
    const t2 = this.renderer.properties.get(this.xrLight.environment);
    if (t2) {
      const e2 = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
      e2 && (t2.__webglTexture = e2);
    }
  }
  onXRFrame(t2, e2) {
    if (!this.xrLight)
      return;
    e2.session.requestAnimationFrame(this.frameCallback);
    const n2 = e2.getLightEstimate(this.lightProbe);
    if (n2) {
      this.xrLight.lightProbe.sh.fromArray(n2.sphericalHarmonicsCoefficients), this.xrLight.lightProbe.intensity = 1;
      const t3 = Math.max(1, Math.max(n2.primaryLightIntensity.x, Math.max(n2.primaryLightIntensity.y, n2.primaryLightIntensity.z)));
      this.xrLight.directionalLight.color.setRGB(n2.primaryLightIntensity.x / t3, n2.primaryLightIntensity.y / t3, n2.primaryLightIntensity.z / t3), this.xrLight.directionalLight.intensity = t3, this.xrLight.directionalLight.position.copy(n2.primaryLightDirection), this.estimationStartCallback && (this.estimationStartCallback(), this.estimationStartCallback = null);
    }
  }
  dispose() {
    this.xrLight = null, this.renderer = null, this.lightProbe = null, this.xrWebGLBinding = null;
  }
}
class Ou extends Ds {
  constructor(t2, e2 = true) {
    super(), this.lightProbe = new Rl(), this.lightProbe.intensity = 0, this.add(this.lightProbe), this.directionalLight = new El(), this.directionalLight.intensity = 0, this.add(this.directionalLight), this.environment = null;
    let n2 = null, i2 = false;
    t2.xr.addEventListener("sessionstart", () => {
      const r2 = t2.xr.getSession();
      "requestLightProbe" in r2 && r2.requestLightProbe({ reflectionFormat: r2.preferredReflectionFormat }).then((r3) => {
        n2 = new Fu(this, t2, r3, e2, () => {
          i2 = true, this.dispatchEvent({ type: "estimationstart" });
        });
      });
    }), t2.xr.addEventListener("sessionend", () => {
      n2 && (n2.dispose(), n2 = null), i2 && this.dispatchEvent({ type: "estimationend" });
    }), this.dispose = () => {
      n2 && (n2.dispose(), n2 = null), this.remove(this.lightProbe), this.lightProbe = null, this.remove(this.directionalLight), this.directionalLight = null, this.environment = null;
    };
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Uu = Math.PI / 24, ku = new mt(), zu = (t2, e2, n2) => {
  let i2 = e2 > 0 ? n2 > 0 ? 0 : -Math.PI / 2 : n2 > 0 ? Math.PI / 2 : Math.PI;
  for (let r2 = 0; r2 <= 12; ++r2)
    t2.push(e2 + 0.17 * Math.cos(i2), n2 + 0.17 * Math.sin(i2), 0, e2 + 0.2 * Math.cos(i2), n2 + 0.2 * Math.sin(i2), 0), i2 += Uu;
};
class Bu extends Ln {
  constructor(t2, e2) {
    const n2 = new un(), i2 = [], r2 = [], { size: s2, boundingBox: a2 } = t2, o2 = s2.x / 2, l2 = (e2 === "back" ? s2.y : s2.z) / 2;
    zu(r2, o2, l2), zu(r2, -o2, l2), zu(r2, -o2, -l2), zu(r2, o2, -l2);
    const c2 = r2.length / 3;
    for (let t3 = 0; t3 < c2 - 2; t3 += 2)
      i2.push(t3, t3 + 1, t3 + 3, t3, t3 + 3, t3 + 2);
    const h2 = c2 - 2;
    i2.push(h2, h2 + 1, 1, h2, 1, 0), n2.setAttribute("position", new nn(r2, 3)), n2.setIndex(i2), super(n2), this.side = e2;
    const u2 = this.material;
    switch (u2.side = 0, u2.transparent = true, u2.opacity = 0, this.goalOpacity = 0, this.opacityDamper = new su(), this.hitPlane = new Ln(new Jn(2 * (o2 + 0.2), 2 * (l2 + 0.2))), this.hitPlane.visible = false, this.add(this.hitPlane), a2.getCenter(this.position), e2) {
      case "bottom":
        this.rotateX(-Math.PI / 2), this.shadowHeight = a2.min.y, this.position.y = this.shadowHeight;
        break;
      case "back":
        this.shadowHeight = a2.min.z, this.position.z = this.shadowHeight;
    }
    t2.target.add(this);
  }
  getHit(t2, e2, n2) {
    ku.set(e2, -n2), this.hitPlane.visible = true;
    const i2 = t2.positionAndNormalFromPoint(ku, this.hitPlane);
    return this.hitPlane.visible = false, i2 == null ? null : i2.position;
  }
  getExpandedHit(t2, e2, n2) {
    this.hitPlane.scale.set(1e3, 1e3, 1e3);
    const i2 = this.getHit(t2, e2, n2);
    return this.hitPlane.scale.set(1, 1, 1), i2;
  }
  set offsetHeight(t2) {
    this.side === "back" ? this.position.z = this.shadowHeight + t2 : this.position.y = this.shadowHeight + t2;
  }
  get offsetHeight() {
    return this.side === "back" ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
  }
  set show(t2) {
    this.goalOpacity = t2 ? 0.75 : 0;
  }
  updateOpacity(t2) {
    const e2 = this.material;
    e2.opacity = this.opacityDamper.update(e2.opacity, this.goalOpacity, t2, 1), this.visible = e2.opacity > 0;
  }
  dispose() {
    var t2;
    const { geometry: e2, material: n2 } = this.hitPlane;
    e2.dispose(), n2.dispose(), this.geometry.dispose(), this.material.dispose(), (t2 = this.parent) === null || t2 === void 0 || t2.remove(this);
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Hu = "not-presenting", Vu = "session-started", Gu = "object-placed", Wu = "failed", ju = "tracking", qu = "not-tracking", Xu = new At(), Yu = new re(), Zu = new At(), Ju = new Un(45, 1, 0.1, 100);
class $u extends et {
  constructor(t2) {
    super(), this.renderer = t2, this.currentSession = null, this.placeOnWall = false, this.placementBox = null, this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.oldBackground = null, this.oldEnvironment = null, this.frame = null, this.initialHitSource = null, this.transientHitTestSource = null, this.inputSource = null, this._presentedScene = null, this.resolveCleanup = null, this.exitWebXRButtonContainer = null, this.overlay = null, this.xrLight = null, this.tracking = true, this.frames = 0, this.initialized = false, this.oldTarget = new At(), this.placementComplete = false, this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.lastDragPosition = new At(), this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new At(), this.goalYaw = 0, this.goalScale = 1, this.xDamper = new su(), this.yDamper = new su(), this.zDamper = new su(), this.yawDamper = new su(), this.scaleDamper = new su(), this.onExitWebXRButtonContainerClick = () => this.stopPresenting(), this.onUpdateScene = () => {
      this.placementBox != null && this.isPresenting && (this.placementBox.dispose(), this.placementBox = new Bu(this.presentedScene, this.placeOnWall ? "back" : "bottom"));
    }, this.onSelectStart = (t3) => {
      const e2 = this.transientHitTestSource;
      if (e2 == null)
        return;
      const n2 = this.frame.getHitTestResultsForTransientInput(e2), i2 = this.presentedScene, r2 = this.placementBox;
      if (n2.length === 1) {
        this.inputSource = t3.inputSource;
        const { axes: e3 } = this.inputSource.gamepad, n3 = r2.getHit(this.presentedScene, e3[0], e3[1]);
        r2.show = true, n3 != null ? (this.isTranslating = true, this.lastDragPosition.copy(n3)) : this.placeOnWall === false && (this.isRotating = true, this.lastAngle = 1.5 * e3[0]);
      } else if (n2.length === 2) {
        r2.show = true, this.isTwoFingering = true;
        const { separation: t4 } = this.fingerPolar(n2);
        this.firstRatio = t4 / i2.scale.x;
      }
    }, this.onSelectEnd = () => {
      this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = false;
    }, this.threeRenderer = t2.threeRenderer, this.threeRenderer.xr.enabled = true;
  }
  async resolveARSession() {
    Kh();
    const t2 = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ["hit-test"], optionalFeatures: ["dom-overlay", "light-estimation"], domOverlay: { root: this.overlay } });
    return this.threeRenderer.xr.setReferenceSpaceType("local"), await this.threeRenderer.xr.setSession(t2), this.threeRenderer.xr.cameraAutoUpdate = false, t2;
  }
  get presentedScene() {
    return this._presentedScene;
  }
  async supportsPresentation() {
    try {
      return Kh(), await navigator.xr.isSessionSupported("immersive-ar");
    } catch (t2) {
      return console.warn("Request to present in WebXR denied:"), console.warn(t2), console.warn("Falling back to next ar-mode"), false;
    }
  }
  async present(t2, e2 = false) {
    this.isPresenting && console.warn("Cannot present while a model is already presenting");
    let n2 = new Promise((t3, e3) => {
      requestAnimationFrame(() => t3());
    });
    t2.setHotspotsVisibility(false), t2.queueRender(), await n2, this._presentedScene = t2, this.overlay = t2.element.shadowRoot.querySelector("div.default"), e2 === true && (this.xrLight = new Ou(this.threeRenderer), this.xrLight.addEventListener("estimationstart", () => {
      if (!this.isPresenting || this.xrLight == null)
        return;
      const t3 = this.presentedScene;
      t3.add(this.xrLight), this.oldEnvironment = t3.environment, t3.environment = this.xrLight.environment;
    }));
    const i2 = await this.resolveARSession();
    i2.addEventListener("end", () => {
      this.postSessionCleanup();
    }, { once: true });
    const r2 = t2.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
    r2.classList.add("enabled"), r2.addEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = r2;
    const s2 = await i2.requestReferenceSpace("viewer");
    this.tracking = true, this.frames = 0, this.initialized = false, this.turntableRotation = t2.yaw, this.goalYaw = t2.yaw, this.goalScale = 1, this.oldBackground = t2.background, t2.background = null, this.oldShadowIntensity = t2.shadowIntensity, t2.setShadowIntensity(0.01), this.oldTarget.copy(t2.getTarget()), t2.addEventListener("model-load", this.onUpdateScene);
    const a2 = 20 * Math.PI / 180, o2 = this.placeOnWall === true ? void 0 : new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(a2), z: -Math.cos(a2) });
    i2.requestHitTestSource({ space: s2, offsetRay: o2 }).then((t3) => {
      this.initialHitSource = t3;
    }), this.currentSession = i2, this.placementBox = new Bu(t2, this.placeOnWall ? "back" : "bottom"), this.placementComplete = false, this.lastTick = performance.now(), this.dispatchEvent({ type: "status", status: Vu });
  }
  async stopPresenting() {
    if (!this.isPresenting)
      return;
    const t2 = new Promise((t3) => {
      this.resolveCleanup = t3;
    });
    try {
      await this.currentSession.end(), await t2;
    } catch (t3) {
      console.warn("Error while trying to end WebXR AR session"), console.warn(t3), this.postSessionCleanup();
    }
  }
  get isPresenting() {
    return this.presentedScene != null;
  }
  get target() {
    return this.oldTarget;
  }
  updateTarget() {
    const t2 = this.presentedScene;
    if (t2 != null) {
      const e2 = t2.getTarget();
      this.oldTarget.copy(e2), this.placeOnWall ? e2.z = t2.boundingBox.min.z : e2.y = t2.boundingBox.min.y, t2.setTarget(e2.x, e2.y, e2.z);
    }
  }
  postSessionCleanup() {
    const t2 = this.currentSession;
    t2 != null && (t2.removeEventListener("selectstart", this.onSelectStart), t2.removeEventListener("selectend", this.onSelectEnd), this.currentSession = null);
    const e2 = this.presentedScene;
    if (e2 != null) {
      const { element: t3 } = e2;
      this.xrLight != null && (e2.remove(this.xrLight), this.oldEnvironment != null && (e2.environment = this.oldEnvironment, this.oldEnvironment = null), this.xrLight.dispose(), this.xrLight = null), e2.position.set(0, 0, 0), e2.scale.set(1, 1, 1), e2.setShadowScaleAndOffset(1, 0);
      const n3 = this.turntableRotation;
      n3 != null && (e2.yaw = n3);
      const i3 = this.oldShadowIntensity;
      i3 != null && e2.setShadowIntensity(i3);
      const r3 = this.oldBackground;
      r3 != null && (e2.background = r3);
      const s2 = this.oldTarget;
      e2.setTarget(s2.x, s2.y, s2.z), e2.xrCamera = null, e2.removeEventListener("model-load", this.onUpdateScene), e2.orientHotspots(0), t3.requestUpdate("cameraTarget"), t3.requestUpdate("maxCameraOrbit"), t3[ap](t3.getBoundingClientRect());
    }
    this.renderer.height = 0;
    const n2 = this.exitWebXRButtonContainer;
    n2 != null && (n2.classList.remove("enabled"), n2.removeEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = null);
    const i2 = this.transientHitTestSource;
    i2 != null && (i2.cancel(), this.transientHitTestSource = null);
    const r2 = this.initialHitSource;
    r2 != null && (r2.cancel(), this.initialHitSource = null), this.placementBox != null && (this.placementBox.dispose(), this.placementBox = null), this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.oldBackground = null, this._presentedScene = null, this.frame = null, this.inputSource = null, this.overlay = null, this.resolveCleanup != null && this.resolveCleanup(), this.dispatchEvent({ type: "status", status: Hu });
  }
  updateView(t2) {
    const e2 = this.presentedScene, n2 = this.threeRenderer.xr;
    n2.updateCamera(Ju), e2.xrCamera = n2.getCamera();
    const { elements: i2 } = e2.getCamera().matrixWorld;
    if (e2.orientHotspots(Math.atan2(i2[1], i2[5])), this.initialized || (this.placeInitially(), this.initialized = true), t2.requestViewportScale && t2.recommendedViewportScale) {
      const e3 = t2.recommendedViewportScale;
      t2.requestViewportScale(Math.max(e3, 0.25));
    }
    const r2 = this.currentSession.renderState.baseLayer.getViewport(t2);
    this.threeRenderer.setViewport(r2.x, r2.y, r2.width, r2.height);
  }
  placeInitially() {
    const t2 = this.presentedScene, { position: e2, element: n2 } = t2, i2 = t2.getCamera(), { width: r2, height: s2 } = this.overlay.getBoundingClientRect();
    t2.setSize(r2, s2), i2.projectionMatrixInverse.copy(i2.projectionMatrix).invert();
    const { theta: a2, radius: o2 } = n2.getCameraOrbit(), l2 = i2.getWorldDirection(Xu);
    t2.yaw = Math.atan2(-l2.x, -l2.z) - a2, this.goalYaw = t2.yaw, e2.copy(i2.position).add(l2.multiplyScalar(o2)), this.updateTarget();
    const c2 = t2.getTarget();
    e2.add(c2).sub(this.oldTarget), this.goalPosition.copy(e2), t2.setHotspotsVisibility(true);
    const { session: h2 } = this.frame;
    h2.addEventListener("selectstart", this.onSelectStart), h2.addEventListener("selectend", this.onSelectEnd), h2.requestHitTestSourceForTransientInput({ profile: "generic-touchscreen" }).then((t3) => {
      this.transientHitTestSource = t3;
    });
  }
  getTouchLocation() {
    const { axes: t2 } = this.inputSource.gamepad;
    let e2 = this.placementBox.getExpandedHit(this.presentedScene, t2[0], t2[1]);
    return e2 != null && (Xu.copy(e2).sub(this.presentedScene.getCamera().position), Xu.length() > 10) ? null : e2;
  }
  getHitPoint(t2) {
    const e2 = this.threeRenderer.xr.getReferenceSpace(), n2 = t2.getPose(e2);
    if (n2 == null)
      return null;
    const i2 = Yu.fromArray(n2.transform.matrix);
    return this.placeOnWall === true && (this.goalYaw = Math.atan2(i2.elements[4], i2.elements[6])), i2.elements[5] > 0.75 !== this.placeOnWall ? Zu.setFromMatrixPosition(i2) : null;
  }
  moveToFloor(t2) {
    const e2 = this.initialHitSource;
    if (e2 == null)
      return;
    const n2 = t2.getHitTestResults(e2);
    if (n2.length == 0)
      return;
    const i2 = n2[0], r2 = this.getHitPoint(i2);
    r2 != null && (this.placementBox.show = true, this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(r2) : this.goalPosition.y = r2.y), e2.cancel(), this.initialHitSource = null, this.dispatchEvent({ type: "status", status: Gu }));
  }
  fingerPolar(t2) {
    const e2 = t2[0].inputSource.gamepad.axes, n2 = t2[1].inputSource.gamepad.axes, i2 = n2[0] - e2[0], r2 = n2[1] - e2[1], s2 = Math.atan2(r2, i2);
    let a2 = this.lastAngle - s2;
    return a2 > Math.PI ? a2 -= 2 * Math.PI : a2 < -Math.PI && (a2 += 2 * Math.PI), this.lastAngle = s2, { separation: Math.sqrt(i2 * i2 + r2 * r2), deltaYaw: a2 };
  }
  processInput(t2) {
    const e2 = this.transientHitTestSource;
    if (e2 == null)
      return;
    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating)
      return;
    const n2 = t2.getHitTestResultsForTransientInput(e2), i2 = this.presentedScene, r2 = i2.scale.x;
    if (this.isTwoFingering)
      if (n2.length < 2)
        this.isTwoFingering = false;
      else {
        const { separation: t3, deltaYaw: e3 } = this.fingerPolar(n2);
        if (this.placeOnWall === false && (this.goalYaw += e3), i2.canScale) {
          const e4 = t3 / this.firstRatio;
          this.goalScale = e4 < 1.3 && e4 > 0.7692307692307692 ? 1 : e4;
        }
      }
    else if (n2.length !== 2)
      if (this.isRotating) {
        const t3 = 1.5 * this.inputSource.gamepad.axes[0];
        this.goalYaw += t3 - this.lastAngle, this.lastAngle = t3;
      } else
        this.isTranslating && n2.forEach((t3) => {
          if (t3.inputSource !== this.inputSource)
            return;
          let e3 = null;
          if (t3.results.length > 0 && (e3 = this.getHitPoint(t3.results[0])), e3 == null && (e3 = this.getTouchLocation()), e3 != null) {
            if (this.goalPosition.sub(this.lastDragPosition), this.placeOnWall === false) {
              const t4 = e3.y - this.lastDragPosition.y;
              if (t4 < 0) {
                this.placementBox.offsetHeight = t4 / r2, this.presentedScene.setShadowScaleAndOffset(r2, t4);
                const n3 = Xu.copy(i2.getCamera().position), s2 = -t4 / (n3.y - e3.y);
                n3.multiplyScalar(s2), e3.multiplyScalar(1 - s2).add(n3);
              }
            }
            this.goalPosition.add(e3), this.lastDragPosition.copy(e3);
          }
        });
    else {
      this.isTranslating = false, this.isRotating = false, this.isTwoFingering = true;
      const { separation: t3 } = this.fingerPolar(n2);
      this.firstRatio = t3 / r2;
    }
  }
  moveScene(t2) {
    const e2 = this.presentedScene, { position: n2, yaw: i2, boundingRadius: r2 } = e2, s2 = this.goalPosition, a2 = e2.scale.x, o2 = this.placementBox;
    if (!s2.equals(n2) || this.goalScale !== a2) {
      let { x: i3, y: l2, z: c2 } = n2;
      i3 = this.xDamper.update(i3, s2.x, t2, r2), l2 = this.yDamper.update(l2, s2.y, t2, r2), c2 = this.zDamper.update(c2, s2.z, t2, r2), n2.set(i3, l2, c2);
      const h2 = this.scaleDamper.update(a2, this.goalScale, t2, 1);
      if (e2.scale.set(h2, h2, h2), !this.isTranslating) {
        const t3 = s2.y - l2;
        this.placementComplete && this.placeOnWall === false ? (o2.offsetHeight = t3 / h2, e2.setShadowScaleAndOffset(h2, t3)) : t3 === 0 && (this.placementComplete = true, o2.show = false, e2.setShadowIntensity(0.3));
      }
    }
    o2.updateOpacity(t2), e2.updateTarget(t2), e2.yaw = this.yawDamper.update(i2, this.goalYaw, t2, Math.PI);
  }
  onWebXRFrame(t2, e2) {
    this.frame = e2, ++this.frames;
    const n2 = this.threeRenderer.xr.getReferenceSpace(), i2 = e2.getViewerPose(n2);
    i2 == null && this.tracking === true && this.frames > 30 && (this.tracking = false, this.dispatchEvent({ type: "tracking", status: qu }));
    const r2 = this.presentedScene;
    if (i2 == null || r2 == null || !r2.element[dp]())
      return void this.threeRenderer.clear();
    this.tracking === false && (this.tracking = true, this.dispatchEvent({ type: "tracking", status: ju }));
    let s2 = true;
    for (const n3 of i2.views) {
      if (this.updateView(n3), s2) {
        this.moveToFloor(e2), this.processInput(e2);
        const n4 = t2 - this.lastTick;
        this.moveScene(n4), this.renderer.preRender(r2, t2, n4), this.lastTick = t2;
      }
      const i3 = this.threeRenderer.getContext();
      i3.depthMask(false), i3.clear(i3.DEPTH_BUFFER_BIT), i3.depthMask(true), this.threeRenderer.render(r2, r2.getCamera()), s2 = false;
    }
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ku {
  constructor(t2) {
    t2.threeRenderer.debug = { checkShaderErrors: true }, Promise.resolve().then(() => {
      self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", { detail: { renderer: t2, THREE: { ShaderMaterial: Fn, Texture: wt, Mesh: Ln, Scene: Bs, PlaneBufferGeometry: Jn, OrthographicCamera: ai, WebGLRenderTarget: St } } }));
    });
  }
  addScene(t2) {
    self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", { detail: { scene: t2 } }));
  }
  removeScene(t2) {
    self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", { detail: { scene: t2 } }));
  }
}
function Qu(t2) {
  const e2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map(), i2 = t2.clone();
  return td(t2, i2, function(t3, i3) {
    e2.set(i3, t3), n2.set(t3, i3);
  }), i2.traverse(function(t3) {
    if (!t3.isSkinnedMesh)
      return;
    const i3 = t3, r2 = e2.get(t3), s2 = r2.skeleton.bones;
    i3.skeleton = r2.skeleton.clone(), i3.bindMatrix.copy(r2.bindMatrix), i3.skeleton.bones = s2.map(function(t4) {
      return n2.get(t4);
    }), i3.bind(i3.skeleton, i3.bindMatrix);
  }), i2;
}
function td(t2, e2, n2) {
  n2(t2, e2);
  for (let i2 = 0; i2 < t2.children.length; i2++)
    td(t2.children[i2], e2.children[i2], n2);
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ed = Symbol("prepared"), nd = Symbol("prepare"), id = Symbol("preparedGLTF"), rd = Symbol("clone");
class sd {
  constructor(t2) {
    this[id] = t2;
  }
  static prepare(t2) {
    if (t2.scene == null)
      throw new Error("Model does not have a scene");
    if (t2[ed])
      return t2;
    const e2 = this[nd](t2);
    return e2[ed] = true, e2;
  }
  static [nd](t2) {
    const { scene: e2 } = t2, n2 = [e2];
    return Object.assign(Object.assign({}, t2), { scene: e2, scenes: n2 });
  }
  get parser() {
    return this[id].parser;
  }
  get animations() {
    return this[id].animations;
  }
  get scene() {
    return this[id].scene;
  }
  get scenes() {
    return this[id].scenes;
  }
  get cameras() {
    return this[id].cameras;
  }
  get asset() {
    return this[id].asset;
  }
  get userData() {
    return this[id].userData;
  }
  clone() {
    return new this.constructor(this[rd]());
  }
  dispose() {
    this.scenes.forEach((t2) => {
      t2.traverse((t3) => {
        if (!t3.isMesh)
          return;
        const e2 = t3;
        (Array.isArray(e2.material) ? e2.material : [e2.material]).forEach((t4) => {
          for (const e3 in t4) {
            const n2 = t4[e3];
            n2 instanceof wt && n2.dispose();
          }
          t4.dispose();
        }), e2.geometry.dispose();
      });
    });
  }
  [rd]() {
    const t2 = this[id], e2 = Qu(this.scene);
    ad(e2, this.scene);
    const n2 = [e2], i2 = t2.userData ? Object.assign({}, t2.userData) : {};
    return Object.assign(Object.assign({}, t2), { scene: e2, scenes: n2, userData: i2 });
  }
}
const ad = (t2, e2) => {
  od(t2, e2, (t3, e3) => {
    e3.userData.variantMaterials !== void 0 && (t3.userData.variantMaterials = new Map(e3.userData.variantMaterials)), e3.userData.variantData !== void 0 && (t3.userData.variantData = e3.userData.variantData), e3.userData.originalMaterial !== void 0 && (t3.userData.originalMaterial = e3.userData.originalMaterial);
  });
}, od = (t2, e2, n2) => {
  n2(t2, e2);
  for (let i2 = 0; i2 < t2.children.length; i2++)
    od(t2.children[i2], e2.children[i2], n2);
}, ld = Symbol("threeGLTF"), cd = Symbol("gltf"), hd = Symbol("gltfElementMap"), ud = Symbol("threeObjectMap"), dd = Symbol("parallelTraverseThreeScene"), pd = Symbol("correlateOriginalThreeGLTF"), md = Symbol("correlateCloneThreeGLTF");
class fd {
  constructor(t2, e2, n2, i2) {
    this[ld] = t2, this[cd] = e2, this[hd] = i2, this[ud] = n2;
  }
  static from(t2, e2) {
    return e2 != null ? this[md](t2, e2) : this[pd](t2);
  }
  static [pd](t2) {
    const e2 = t2.parser.json, n2 = t2.parser.associations, i2 = /* @__PURE__ */ new Map(), r2 = { name: "Default" }, s2 = { type: "materials", index: -1 };
    for (const t3 of n2.keys())
      t3 instanceof Ve && n2.get(t3) == null && (s2.index < 0 && (e2.materials == null && (e2.materials = []), s2.index = e2.materials.length, e2.materials.push(r2)), t3.name = r2.name, n2.set(t3, { materials: s2.index }));
    for (const [t3, r3] of n2) {
      if (r3) {
        const e3 = t3;
        e3.userData = e3.userData || {}, e3.userData.associations = r3;
      }
      for (const n3 in r3)
        if (n3 != null && n3 !== "primitives") {
          const s3 = n3, a2 = (e2[s3] || [])[r3[s3]];
          if (a2 == null)
            continue;
          let o2 = i2.get(a2);
          o2 == null && (o2 = /* @__PURE__ */ new Set(), i2.set(a2, o2)), o2.add(t3);
        }
    }
    return new fd(t2, e2, n2, i2);
  }
  static [md](t2, e2) {
    const n2 = e2.threeGLTF, i2 = e2.gltf, r2 = JSON.parse(JSON.stringify(i2)), s2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Map();
    for (let i3 = 0; i3 < n2.scenes.length; i3++)
      this[dd](n2.scenes[i3], t2.scenes[i3], (t3, n3) => {
        const i4 = e2.threeObjectMap.get(t3);
        if (i4 != null) {
          for (const t4 in i4)
            if (t4 != null && t4 !== "primitives") {
              const e3 = t4, o2 = i4[e3], l2 = r2[e3][o2], c2 = s2.get(n3) || {};
              c2[e3] = o2, s2.set(n3, c2);
              const h2 = a2.get(l2) || /* @__PURE__ */ new Set();
              h2.add(n3), a2.set(l2, h2);
            }
        }
      });
    return new fd(t2, r2, s2, a2);
  }
  static [dd](t2, e2, n2) {
    const i2 = (t3, e3) => {
      if (n2(t3, e3), t3.isObject3D) {
        if (t3.isMesh)
          if (Array.isArray(t3.material))
            for (let n3 = 0; n3 < t3.material.length; ++n3)
              i2(t3.material[n3], e3.material[n3]);
          else
            i2(t3.material, e3.material);
        for (let n3 = 0; n3 < t3.children.length; ++n3)
          i2(t3.children[n3], e3.children[n3]);
      }
    };
    i2(t2, e2);
  }
  get threeGLTF() {
    return this[ld];
  }
  get gltf() {
    return this[cd];
  }
  get gltfElementMap() {
    return this[hd];
  }
  get threeObjectMap() {
    return this[ud];
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const gd = Symbol("correlatedSceneGraph");
class vd extends sd {
  static [nd](t2) {
    const e2 = super[nd](t2);
    e2[gd] == null && (e2[gd] = fd.from(e2));
    const { scene: n2 } = e2, i2 = new Zt(void 0, 1 / 0);
    return n2.traverse((t3) => {
      t3.renderOrder = 1e3, t3.frustumCulled = false, t3.name || (t3.name = t3.uuid);
      const e3 = t3;
      if (e3.isMesh) {
        e3.castShadow = true, e3.isSkinnedMesh && (e3.geometry.boundingSphere = i2, e3.geometry.boundingBox = null);
        e3.material.shadowSide = 0;
      }
    }), e2;
  }
  get correlatedSceneGraph() {
    return this[id][gd];
  }
  [rd]() {
    const t2 = super[rd](), e2 = /* @__PURE__ */ new Map();
    return t2.scene.traverse((t3) => {
      if (t3.isMesh) {
        const n2 = t3, i2 = n2.material;
        if (i2 != null) {
          if (e2.has(i2.uuid))
            return void (n2.material = e2.get(i2.uuid));
          n2.material = i2.clone(), e2.set(i2.uuid, n2.material);
        }
      }
    }), t2[gd] = fd.from(t2, this.correlatedSceneGraph), t2;
  }
}
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yd extends Bs {
  constructor() {
    super(), this.position.y = -3.5;
    const t2 = new Pn();
    t2.deleteAttribute("uv");
    const e2 = new Ho({ metalness: 0, side: 1 }), n2 = new Ho({ metalness: 0 }), i2 = new Sl(16777215, 500, 28, 2);
    i2.position.set(0.418, 16.199, 0.3), this.add(i2);
    const r2 = new Ln(t2, e2);
    r2.position.set(-0.757, 13.219, 0.717), r2.scale.set(31.713, 28.305, 28.591), this.add(r2);
    const s2 = new Ln(t2, n2);
    s2.position.set(-10.906, 2.009, 1.846), s2.rotation.set(0, -0.195, 0), s2.scale.set(2.328, 7.905, 4.651), this.add(s2);
    const a2 = new Ln(t2, n2);
    a2.position.set(-5.607, -0.754, -0.758), a2.rotation.set(0, 0.994, 0), a2.scale.set(1.97, 1.534, 3.955), this.add(a2);
    const o2 = new Ln(t2, n2);
    o2.position.set(6.167, 0.857, 7.803), o2.rotation.set(0, 0.561, 0), o2.scale.set(3.927, 6.285, 3.687), this.add(o2);
    const l2 = new Ln(t2, n2);
    l2.position.set(-2.017, 0.018, 6.124), l2.rotation.set(0, 0.333, 0), l2.scale.set(2.002, 4.566, 2.064), this.add(l2);
    const c2 = new Ln(t2, n2);
    c2.position.set(2.291, -0.756, -2.621), c2.rotation.set(0, -0.286, 0), c2.scale.set(1.546, 1.552, 1.496), this.add(c2);
    const h2 = new Ln(t2, n2);
    h2.position.set(-2.193, -0.369, -5.547), h2.rotation.set(0, 0.516, 0), h2.scale.set(3.875, 3.487, 2.986), this.add(h2);
    const u2 = new Ln(t2, this.createAreaLightMaterial(50));
    u2.position.set(-16.116, 14.37, 8.208), u2.scale.set(0.1, 2.428, 2.739), this.add(u2);
    const d2 = new Ln(t2, this.createAreaLightMaterial(50));
    d2.position.set(-16.109, 18.021, -8.207), d2.scale.set(0.1, 2.425, 2.751), this.add(d2);
    const p2 = new Ln(t2, this.createAreaLightMaterial(17));
    p2.position.set(14.904, 12.198, -1.832), p2.scale.set(0.15, 4.265, 6.331), this.add(p2);
    const m2 = new Ln(t2, this.createAreaLightMaterial(43));
    m2.position.set(-0.462, 8.89, 14.52), m2.scale.set(4.38, 5.441, 0.088), this.add(m2);
    const f2 = new Ln(t2, this.createAreaLightMaterial(20));
    f2.position.set(3.235, 11.486, -12.541), f2.scale.set(2.5, 2, 0.1), this.add(f2);
    const g2 = new Ln(t2, this.createAreaLightMaterial(100));
    g2.position.set(0, 20, 0), g2.scale.set(1, 0.1, 1), this.add(g2);
  }
  createAreaLightMaterial(t2) {
    const e2 = new Je();
    return e2.color.setScalar(t2), e2;
  }
}
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xd extends Bs {
  constructor() {
    super(), this.position.y = -3.5;
    const t2 = new Pn();
    t2.deleteAttribute("uv");
    const e2 = new Ho({ metalness: 0, side: 1 }), n2 = new Ho({ metalness: 0 }), i2 = new Sl(16777215, 400, 28, 2);
    i2.position.set(0.5, 14, 0.5), this.add(i2);
    const r2 = new Ln(t2, e2);
    r2.position.set(0, 13.2, 0), r2.scale.set(31.5, 28.5, 31.5), this.add(r2);
    const s2 = new Ln(t2, n2);
    s2.position.set(-10.906, -1, 1.846), s2.rotation.set(0, -0.195, 0), s2.scale.set(2.328, 7.905, 4.651), this.add(s2);
    const a2 = new Ln(t2, n2);
    a2.position.set(-5.607, -0.754, -0.758), a2.rotation.set(0, 0.994, 0), a2.scale.set(1.97, 1.534, 3.955), this.add(a2);
    const o2 = new Ln(t2, n2);
    o2.position.set(6.167, -0.16, 7.803), o2.rotation.set(0, 0.561, 0), o2.scale.set(3.927, 6.285, 3.687), this.add(o2);
    const l2 = new Ln(t2, n2);
    l2.position.set(-2.017, 0.018, 6.124), l2.rotation.set(0, 0.333, 0), l2.scale.set(2.002, 4.566, 2.064), this.add(l2);
    const c2 = new Ln(t2, n2);
    c2.position.set(2.291, -0.756, -2.621), c2.rotation.set(0, -0.286, 0), c2.scale.set(1.546, 1.552, 1.496), this.add(c2);
    const h2 = new Ln(t2, n2);
    h2.position.set(-2.193, -0.369, -5.547), h2.rotation.set(0, 0.516, 0), h2.scale.set(3.875, 3.487, 2.986), this.add(h2);
    const u2 = new Ln(t2, this.createAreaLightMaterial(80));
    u2.position.set(-14, 10, 8), u2.scale.set(0.1, 2.5, 2.5), this.add(u2);
    const d2 = new Ln(t2, this.createAreaLightMaterial(80));
    d2.position.set(-14, 14, -4), d2.scale.set(0.1, 2.5, 2.5), this.add(d2);
    const p2 = new Ln(t2, this.createAreaLightMaterial(23));
    p2.position.set(14, 12, 0), p2.scale.set(0.1, 5, 5), this.add(p2);
    const m2 = new Ln(t2, this.createAreaLightMaterial(16));
    m2.position.set(0, 9, 14), m2.scale.set(5, 5, 0.1), this.add(m2);
    const f2 = new Ln(t2, this.createAreaLightMaterial(80));
    f2.position.set(7, 8, -14), f2.scale.set(2.5, 2.5, 0.1), this.add(f2);
    const g2 = new Ln(t2, this.createAreaLightMaterial(80));
    g2.position.set(-7, 16, -14), g2.scale.set(2.5, 2.5, 0.1), this.add(g2);
    const v2 = new Ln(t2, this.createAreaLightMaterial(1));
    v2.position.set(0, 20, 0), v2.scale.set(0.1, 0.1, 0.1), this.add(v2);
  }
  createAreaLightMaterial(t2) {
    const e2 = new Je();
    return e2.color.setScalar(t2), e2;
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bd = /\.hdr(\.js)?$/, wd = new dl(), _d = new class extends ul {
  constructor(t2) {
    super(t2), this.type = 1016;
  }
  parse(t2) {
    const e2 = function(t3, e3) {
      switch (t3) {
        case 1:
          console.error("THREE.RGBELoader Read Error: " + (e3 || ""));
          break;
        case 2:
          console.error("THREE.RGBELoader Write Error: " + (e3 || ""));
          break;
        case 3:
          console.error("THREE.RGBELoader Bad File Format: " + (e3 || ""));
          break;
        default:
          console.error("THREE.RGBELoader: Error: " + (e3 || ""));
      }
      return -1;
    }, n2 = function(t3, e3, n3) {
      e3 = e3 || 1024;
      let i3 = t3.pos, r3 = -1, s3 = 0, a3 = "", o2 = String.fromCharCode.apply(null, new Uint16Array(t3.subarray(i3, i3 + 128)));
      for (; 0 > (r3 = o2.indexOf("\n")) && s3 < e3 && i3 < t3.byteLength; )
        a3 += o2, s3 += o2.length, i3 += 128, o2 += String.fromCharCode.apply(null, new Uint16Array(t3.subarray(i3, i3 + 128)));
      return -1 < r3 && (n3 !== false && (t3.pos += s3 + r3 + 1), a3 + o2.slice(0, r3));
    }, i2 = function(t3, e3, n3, i3) {
      const r3 = t3[e3 + 3], s3 = Math.pow(2, r3 - 128) / 255;
      n3[i3 + 0] = t3[e3 + 0] * s3, n3[i3 + 1] = t3[e3 + 1] * s3, n3[i3 + 2] = t3[e3 + 2] * s3;
    }, r2 = function(t3, e3, n3, i3) {
      const r3 = t3[e3 + 3], s3 = Math.pow(2, r3 - 128) / 255;
      n3[i3 + 0] = ec.toHalfFloat(Math.min(t3[e3 + 0] * s3, 65504)), n3[i3 + 1] = ec.toHalfFloat(Math.min(t3[e3 + 1] * s3, 65504)), n3[i3 + 2] = ec.toHalfFloat(Math.min(t3[e3 + 2] * s3, 65504));
    }, s2 = new Uint8Array(t2);
    s2.pos = 0;
    const a2 = function(t3) {
      const i3 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, r3 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, s3 = /^\s*FORMAT=(\S+)\s*$/, a3 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, o2 = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
      let l2, c2;
      if (t3.pos >= t3.byteLength || !(l2 = n2(t3)))
        return e2(1, "no header found");
      if (!(c2 = l2.match(/^#\?(\S+)/)))
        return e2(3, "bad initial token");
      for (o2.valid |= 1, o2.programtype = c2[1], o2.string += l2 + "\n"; l2 = n2(t3), l2 !== false; )
        if (o2.string += l2 + "\n", l2.charAt(0) !== "#") {
          if ((c2 = l2.match(i3)) && (o2.gamma = parseFloat(c2[1], 10)), (c2 = l2.match(r3)) && (o2.exposure = parseFloat(c2[1], 10)), (c2 = l2.match(s3)) && (o2.valid |= 2, o2.format = c2[1]), (c2 = l2.match(a3)) && (o2.valid |= 4, o2.height = parseInt(c2[1], 10), o2.width = parseInt(c2[2], 10)), 2 & o2.valid && 4 & o2.valid)
            break;
        } else
          o2.comments += l2 + "\n";
      return 2 & o2.valid ? 4 & o2.valid ? o2 : e2(3, "missing image size specifier") : e2(3, "missing format specifier");
    }(s2);
    if (a2 !== -1) {
      const t3 = a2.width, n3 = a2.height, o2 = function(t4, n4, i3) {
        const r3 = n4;
        if (r3 < 8 || r3 > 32767 || t4[0] !== 2 || t4[1] !== 2 || 128 & t4[2])
          return new Uint8Array(t4);
        if (r3 !== (t4[2] << 8 | t4[3]))
          return e2(3, "wrong scanline width");
        const s3 = new Uint8Array(4 * n4 * i3);
        if (!s3.length)
          return e2(4, "unable to allocate buffer space");
        let a3 = 0, o3 = 0;
        const l2 = 4 * r3, c2 = new Uint8Array(4), h2 = new Uint8Array(l2);
        let u2 = i3;
        for (; u2 > 0 && o3 < t4.byteLength; ) {
          if (o3 + 4 > t4.byteLength)
            return e2(1);
          if (c2[0] = t4[o3++], c2[1] = t4[o3++], c2[2] = t4[o3++], c2[3] = t4[o3++], c2[0] != 2 || c2[1] != 2 || (c2[2] << 8 | c2[3]) != r3)
            return e2(3, "bad rgbe scanline format");
          let n5, i4 = 0;
          for (; i4 < l2 && o3 < t4.byteLength; ) {
            n5 = t4[o3++];
            const r4 = n5 > 128;
            if (r4 && (n5 -= 128), n5 === 0 || i4 + n5 > l2)
              return e2(3, "bad scanline data");
            if (r4) {
              const e3 = t4[o3++];
              for (let t5 = 0; t5 < n5; t5++)
                h2[i4++] = e3;
            } else
              h2.set(t4.subarray(o3, o3 + n5), i4), i4 += n5, o3 += n5;
          }
          const d2 = r3;
          for (let t5 = 0; t5 < d2; t5++) {
            let e3 = 0;
            s3[a3] = h2[t5 + e3], e3 += r3, s3[a3 + 1] = h2[t5 + e3], e3 += r3, s3[a3 + 2] = h2[t5 + e3], e3 += r3, s3[a3 + 3] = h2[t5 + e3], a3 += 4;
          }
          u2--;
        }
        return s3;
      }(s2.subarray(s2.pos), t3, n3);
      if (o2 !== -1) {
        let e3, s3, l2, c2;
        switch (this.type) {
          case 1015:
            c2 = o2.length / 4;
            const t4 = new Float32Array(3 * c2);
            for (let e4 = 0; e4 < c2; e4++)
              i2(o2, 4 * e4, t4, 3 * e4);
            e3 = t4, s3 = 1022, l2 = 1015;
            break;
          case 1016:
            c2 = o2.length / 4;
            const n4 = new Uint16Array(3 * c2);
            for (let t5 = 0; t5 < c2; t5++)
              r2(o2, 4 * t5, n4, 3 * t5);
            e3 = n4, s3 = 1022, l2 = 1016;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
        }
        return { width: t3, height: n3, data: e3, header: a2.string, gamma: a2.gamma, exposure: a2.exposure, format: s3, type: l2 };
      }
    }
    return null;
  }
  setDataType(t2) {
    return this.type = t2, this;
  }
  load(t2, e2, n2, i2) {
    return super.load(t2, function(t3, n3) {
      switch (t3.type) {
        case 1015:
        case 1016:
          t3.encoding = 3e3, t3.minFilter = 1006, t3.magFilter = 1006, t3.generateMipmaps = false, t3.flipY = true;
      }
      e2 && e2(t3, n3);
    }, n2, i2);
  }
}();
_d.setDataType(1016);
class Md extends et {
  constructor(t2) {
    super(), this.threeRenderer = t2, this.generatedEnvironmentMap = null, this.generatedEnvironmentMapAlt = null, this.skyboxCache = /* @__PURE__ */ new Map(), this.blurMaterial = null, this.blurScene = null;
  }
  async load(t2, e2 = () => {
  }) {
    try {
      const n2 = bd.test(t2), i2 = n2 ? _d : wd, r2 = await new Promise((n3, r3) => i2.load(t2, n3, (t3) => {
        e2(t3.loaded / t3.total * 0.9);
      }, r3));
      return e2(1), r2.name = t2, r2.mapping = 303, n2 || (r2.encoding = 3001), r2;
    } finally {
      e2 && e2(1);
    }
  }
  async generateEnvironmentMapAndSkybox(t2 = null, e2 = null, n2 = {}) {
    const { progressTracker: i2 } = n2, r2 = e2 === "neutral";
    r2 === true && (e2 = null), e2 = $h(e2);
    let s2, a2 = Promise.resolve(null);
    t2 && (a2 = this.loadEquirectFromUrl(t2, i2)), s2 = e2 ? this.loadEquirectFromUrl(e2, i2) : t2 ? this.loadEquirectFromUrl(t2, i2) : r2 === true ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();
    let [o2, l2] = await Promise.all([s2, a2]);
    if (o2 == null)
      throw new Error("Failed to load environment map.");
    return { environmentMap: o2, skybox: l2 };
  }
  async loadEquirectFromUrl(t2, e2) {
    if (!this.skyboxCache.has(t2)) {
      const n2 = e2 ? e2.beginActivity() : () => {
      }, i2 = this.load(t2, n2);
      this.skyboxCache.set(t2, i2);
    }
    return this.skyboxCache.get(t2);
  }
  async GenerateEnvironmentMap(t2, e2) {
    await ru();
    const n2 = this.threeRenderer, i2 = new Bn(256, { generateMipmaps: false, type: 1016, format: 1023, encoding: 3e3, depthBuffer: true }), r2 = new kn(0.1, 100, i2), s2 = r2.renderTarget.texture;
    s2.name = e2, s2.isRenderTargetTexture = false, s2.images = [1, 1, 1, 1, 1, 1], t2.scale.setComponent(0, -1);
    const a2 = n2.outputEncoding, o2 = n2.toneMapping;
    return n2.toneMapping = 0, n2.outputEncoding = 3e3, r2.update(n2, t2), await this.blurCubemap(i2, 0.04), n2.toneMapping = o2, n2.outputEncoding = a2, s2;
  }
  async loadGeneratedEnvironmentMap() {
    return this.generatedEnvironmentMap == null && (this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new yd(), "default")), this.generatedEnvironmentMap;
  }
  async loadGeneratedEnvironmentMapAlt() {
    return this.generatedEnvironmentMapAlt == null && (this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new xd(), "neutral")), this.generatedEnvironmentMapAlt;
  }
  async blurCubemap(t2, e2) {
    if (this.blurMaterial == null) {
      this.blurMaterial = this.getBlurShader(20);
      const t3 = new Pn(), e3 = new Ln(t3, this.blurMaterial);
      this.blurScene = new Bs(), this.blurScene.add(e3);
    }
    const n2 = t2.clone();
    this.halfblur(t2, n2, e2, "latitudinal"), this.halfblur(n2, t2, e2, "longitudinal");
  }
  async halfblur(t2, e2, n2, i2) {
    const r2 = t2.width, s2 = isFinite(n2) ? Math.PI / (2 * r2) : 2 * Math.PI / 39, a2 = n2 / s2, o2 = isFinite(n2) ? 1 + Math.floor(3 * a2) : 20;
    o2 > 20 && console.warn(`sigmaRadians, ${n2}, is too large and will clip, as it requested ${o2} samples when the maximum is set to 20`);
    const l2 = [];
    let c2 = 0;
    for (let t3 = 0; t3 < 20; ++t3) {
      const e3 = t3 / a2, n3 = Math.exp(-e3 * e3 / 2);
      l2.push(n3), t3 == 0 ? c2 += n3 : t3 < o2 && (c2 += 2 * n3);
    }
    for (let t3 = 0; t3 < l2.length; t3++)
      l2[t3] = l2[t3] / c2;
    const h2 = this.blurMaterial.uniforms;
    h2.envMap.value = t2.texture, h2.samples.value = o2, h2.weights.value = l2, h2.latitudinal.value = i2 === "latitudinal", h2.dTheta.value = s2;
    new kn(0.1, 100, e2).update(this.threeRenderer, this.blurScene);
  }
  getBlurShader(t2) {
    const e2 = new Float32Array(t2), n2 = new At(0, 1, 0);
    return new Fn({ name: "SphericalGaussianBlur", defines: { n: t2 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e2 }, latitudinal: { value: false }, dTheta: { value: 0 }, poleAxis: { value: n2 } }, vertexShader: "\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    ", fragmentShader: "\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      ", blending: 0, depthTest: false, depthWrite: false, side: 1 });
  }
  async dispose() {
    for (const [, t2] of this.skyboxCache) {
      (await t2).dispose();
    }
    this.generatedEnvironmentMap != null && ((await this.generatedEnvironmentMap).dispose(), this.generatedEnvironmentMap = null), this.generatedEnvironmentMapAlt != null && ((await this.generatedEnvironmentMapAlt).dispose(), this.generatedEnvironmentMapAlt = null), this.blurMaterial != null && this.blurMaterial.dispose();
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Sd = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];
class Td extends et {
  constructor(t2) {
    super(), this.loader = new Gh(vd), this.width = 0, this.height = 0, this.dpr = 1, this.debugger = null, this.scenes = /* @__PURE__ */ new Set(), this.multipleScenesVisible = false, this.scaleStep = 0, this.lastStep = 3, this.avgFrameDuration = 22, this.onWebGLContextLost = (t3) => {
      this.dispatchEvent({ type: "contextlost", sourceEvent: t3 });
    }, this.onWebGLContextRestored = () => {
      var t3;
      (t3 = this.textureUtils) === null || t3 === void 0 || t3.dispose(), this.textureUtils = new Md(this.threeRenderer);
      for (const t4 of this.scenes)
        t4.element[Iu]();
      this.threeRenderer.shadowMap.needsUpdate = true;
    }, this.dpr = nu(), this.canvas3D = document.createElement("canvas"), this.canvas3D.id = "webgl-canvas";
    try {
      this.threeRenderer = new zs({ canvas: this.canvas3D, alpha: true, antialias: true, powerPreference: t2.powerPreference, preserveDrawingBuffer: true }), this.threeRenderer.autoClear = true, this.threeRenderer.outputEncoding = 3001, this.threeRenderer.physicallyCorrectLights = true, this.threeRenderer.setPixelRatio(1), this.threeRenderer.shadowMap.enabled = true, this.threeRenderer.shadowMap.type = 2, this.threeRenderer.shadowMap.autoUpdate = false, this.debugger = t2.debug ? new Ku(this) : null, this.threeRenderer.debug = { checkShaderErrors: !!this.debugger }, this.threeRenderer.toneMapping = 4;
    } catch (t3) {
      console.warn(t3);
    }
    this.arRenderer = new $u(this), this.textureUtils = this.canRender ? new Md(this.threeRenderer) : null, Gh.initializeKTX2Loader(this.threeRenderer), this.canvas3D.addEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.addEventListener("webglcontextrestored", this.onWebGLContextRestored), this.updateRendererSize(), this.lastTick = performance.now(), this.avgFrameDuration = 0;
  }
  static get singleton() {
    return this._singleton;
  }
  static resetSingleton() {
    const t2 = this._singleton.dispose();
    for (const e2 of t2)
      e2.disconnectedCallback();
    this._singleton = new Td({ powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance", debug: iu() });
    for (const e2 of t2)
      e2.connectedCallback();
  }
  get canRender() {
    return this.threeRenderer != null;
  }
  get scaleFactor() {
    return Sd[this.scaleStep];
  }
  set minScale(t2) {
    let e2 = 1;
    for (; e2 < Sd.length && !(Sd[e2] < t2); )
      ++e2;
    this.lastStep = e2 - 1;
  }
  updateRendererSize() {
    const t2 = nu();
    if (t2 !== this.dpr)
      for (const t3 of this.scenes) {
        const { element: e3 } = t3;
        e3[jd](e3.getBoundingClientRect());
      }
    let e2 = 0, n2 = 0;
    for (const t3 of this.scenes)
      e2 = Math.max(e2, t3.width), n2 = Math.max(n2, t3.height);
    if (e2 === this.width && n2 === this.height && t2 === this.dpr)
      return;
    this.width = e2, this.height = n2, this.dpr = t2, this.canRender && this.threeRenderer.setSize(e2 * t2, n2 * t2, false);
    const i2 = this.scaleFactor, r2 = e2 / i2, s2 = n2 / i2;
    this.canvas3D.style.width = `${r2}px`, this.canvas3D.style.height = `${s2}px`;
    for (const i3 of this.scenes) {
      const { canvas: a2 } = i3;
      a2.width = Math.round(e2 * t2), a2.height = Math.round(n2 * t2), a2.style.width = `${r2}px`, a2.style.height = `${s2}px`, i3.queueRender();
    }
  }
  updateRendererScale() {
    const t2 = this.scaleStep;
    if (this.avgFrameDuration > 26 ? ++this.scaleStep : this.avgFrameDuration < 18 && this.scaleStep > 0 && --this.scaleStep, this.scaleStep = Math.min(this.scaleStep, this.lastStep), t2 == this.scaleStep)
      return;
    const e2 = this.scaleFactor;
    this.avgFrameDuration = 22;
    const n2 = this.width / e2, i2 = this.height / e2;
    this.canvas3D.style.width = `${n2}px`, this.canvas3D.style.height = `${i2}px`;
    for (const t3 of this.scenes) {
      const { style: e3 } = t3.canvas;
      e3.width = `${n2}px`, e3.height = `${i2}px`, t3.queueRender();
    }
  }
  registerScene(t2) {
    this.scenes.add(t2);
    const { canvas: e2 } = t2, n2 = this.scaleFactor;
    e2.width = Math.round(this.width * this.dpr), e2.height = Math.round(this.height * this.dpr), e2.style.width = this.width / n2 + "px", e2.style.height = this.height / n2 + "px", this.multipleScenesVisible && e2.classList.add("show"), t2.queueRender(), this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop((t3, e3) => this.render(t3, e3)), this.debugger != null && this.debugger.addScene(t2);
  }
  unregisterScene(t2) {
    this.scenes.delete(t2), this.canRender && this.scenes.size === 0 && this.threeRenderer.setAnimationLoop(null), this.debugger != null && this.debugger.removeScene(t2);
  }
  displayCanvas(t2) {
    return this.multipleScenesVisible ? t2.element[ep] : this.canvas3D;
  }
  selectCanvas() {
    let t2 = 0, e2 = null;
    for (const n3 of this.scenes) {
      const { element: i3 } = n3;
      i3.modelIsVisible && n3.externalRenderer == null && (++t2, e2 = n3.canvas);
    }
    if (e2 == null)
      return;
    const n2 = t2 > 1, { canvas3D: i2 } = this;
    if (n2 !== this.multipleScenesVisible || !n2 && i2.parentElement !== e2.parentElement) {
      this.multipleScenesVisible = n2, n2 && i2.classList.remove("show");
      for (const t3 of this.scenes) {
        if (t3.externalRenderer != null)
          continue;
        const r2 = t3.element[ep];
        n2 ? (r2.classList.add("show"), t3.queueRender()) : t3.canvas === e2 && (t3.canvas.parentElement.appendChild(i2), i2.classList.add("show"), r2.classList.remove("show"), t3.queueRender());
      }
    }
  }
  orderedScenes() {
    const t2 = [];
    for (const e2 of [false, true])
      for (const n2 of this.scenes)
        n2.element.modelIsVisible === e2 && t2.push(n2);
    return t2;
  }
  get isPresenting() {
    return this.arRenderer.isPresenting;
  }
  preRender(t2, e2, n2) {
    const { element: i2, exposure: r2 } = t2;
    i2[rp](e2, n2);
    const s2 = typeof r2 == "number" && !self.isNaN(r2);
    this.threeRenderer.toneMappingExposure = s2 ? r2 : 1, t2.isShadowDirty() && (this.threeRenderer.shadowMap.needsUpdate = true);
  }
  render(t2, e2) {
    if (e2 != null)
      return void this.arRenderer.onWebXRFrame(t2, e2);
    const n2 = t2 - this.lastTick;
    if (this.lastTick = t2, !this.canRender || this.isPresenting)
      return;
    this.avgFrameDuration += eu(0.2 * (n2 - this.avgFrameDuration), -2, 2), this.selectCanvas(), this.updateRendererSize(), this.updateRendererScale();
    const { dpr: i2, scaleFactor: r2 } = this;
    for (const e3 of this.orderedScenes()) {
      const { element: s2 } = e3;
      if (!s2.modelIsVisible && e3.renderCount > 0)
        continue;
      if (this.preRender(e3, t2, n2), !e3.shouldRender())
        continue;
      if (e3.externalRenderer != null) {
        const t3 = e3.getCamera();
        t3.updateMatrix();
        const { matrix: n3, projectionMatrix: i3 } = t3, r3 = n3.elements.slice(), s3 = e3.getTarget();
        r3[12] += s3.x, r3[13] += s3.y, r3[14] += s3.z, e3.externalRenderer.render({ viewMatrix: r3, projectionMatrix: i3.elements });
        continue;
      }
      if (!s2.modelIsVisible && !this.multipleScenesVisible)
        for (const t3 of this.scenes)
          t3.element.modelIsVisible && t3.queueRender();
      const a2 = Math.min(Math.ceil(e3.width * r2 * i2), this.canvas3D.width), o2 = Math.min(Math.ceil(e3.height * r2 * i2), this.canvas3D.height);
      if (this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.floor(this.height * i2) - o2, a2, o2), this.threeRenderer.render(e3, e3.camera), this.multipleScenesVisible) {
        e3.context == null && e3.createContext();
        const t3 = e3.context;
        t3.clearRect(0, 0, a2, o2), t3.drawImage(this.canvas3D, 0, 0, a2, o2, 0, 0, a2, o2);
      }
      e3.hasRendered(), s2.loaded && ++e3.renderCount;
    }
  }
  dispose() {
    this.textureUtils != null && this.textureUtils.dispose(), this.threeRenderer != null && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null;
    const t2 = [];
    for (const e2 of this.scenes)
      t2.push(e2.element);
    return this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.removeEventListener("webglcontextrestored", this.onWebGLContextRestored), t2;
  }
}
Td._singleton = new Td({ powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance", debug: iu() });
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ed extends EventTarget {
  constructor() {
    super(...arguments), this.ongoingActivities = /* @__PURE__ */ new Set(), this.totalProgress = 0;
  }
  get ongoingActivityCount() {
    return this.ongoingActivities.size;
  }
  beginActivity() {
    const t2 = { progress: 0, completed: false };
    return this.ongoingActivities.add(t2), this.ongoingActivityCount === 1 && this.announceTotalProgress(t2, 0), (e2) => {
      let n2;
      return n2 = Math.max(eu(e2, 0, 1), t2.progress), n2 !== t2.progress && this.announceTotalProgress(t2, n2), t2.progress;
    };
  }
  announceTotalProgress(t2, e2) {
    let n2 = 0, i2 = 0;
    e2 == 1 && (t2.completed = true);
    for (const t3 of this.ongoingActivities) {
      const { progress: e3 } = t3;
      n2 += 1 - e3, t3.completed === true && i2++;
    }
    const r2 = t2.progress;
    t2.progress = e2, this.totalProgress += (e2 - r2) * (1 - this.totalProgress) / n2;
    const s2 = i2 === this.ongoingActivityCount ? 1 : this.totalProgress;
    this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: s2 } })), i2 === this.ongoingActivityCount && (this.totalProgress = 0, this.ongoingActivities.clear());
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Ad, Rd, Ld, Cd, Pd, Id, Dd, Nd, Fd, Od, Ud = function(t2, e2, n2, i2) {
  for (var r2, s2 = arguments.length, a2 = s2 < 3 ? e2 : i2 === null ? i2 = Object.getOwnPropertyDescriptor(e2, n2) : i2, o2 = t2.length - 1; o2 >= 0; o2--)
    (r2 = t2[o2]) && (a2 = (s2 < 3 ? r2(a2) : s2 > 3 ? r2(e2, n2, a2) : r2(e2, n2)) || a2);
  return s2 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
};
const kd = document.createElement("canvas"), zd = Symbol("fallbackResizeHandler"), Bd = Symbol("defaultAriaLabel"), Hd = Symbol("resizeObserver"), Vd = Symbol("clearModelTimeout"), Gd = Symbol("onContextLost"), Wd = Symbol("loaded"), jd = Symbol("updateSize"), qd = Symbol("intersectionObserver"), Xd = Symbol("isElementInViewport"), Yd = Symbol("announceModelVisibility"), Zd = Symbol("ariaLabel"), Jd = Symbol("loadedTime"), $d = Symbol("updateSource"), Kd = Symbol("markLoaded"), Qd = Symbol("container"), tp = Symbol("input"), ep = Symbol("canvas"), np = Symbol("scene"), ip = Symbol("needsRender"), rp = Symbol("tick"), sp = Symbol("onModelLoad"), ap = Symbol("onResize"), op = Symbol("renderer"), lp = Symbol("progressTracker"), cp = Symbol("getLoaded"), hp = Symbol("getModelIsVisible"), up = Symbol("shouldAttemptPreload"), dp = Symbol("sceneIsReady"), pp = Symbol("hasTransitioned"), mp = (t2) => ({ x: t2.x, y: t2.y, z: t2.z, toString() {
  return `${this.x}m ${this.y}m ${this.z}m`;
} }), fp = (t2) => ({ u: t2.x, v: t2.y, toString() {
  return `${this.u} ${this.v}`;
} });
class gp extends X {
  constructor() {
    super(), this.alt = null, this.src = null, this[Ad] = false, this[Rd] = false, this[Ld] = 0, this[Cd] = null, this[Pd] = tu(() => {
      const t3 = this.getBoundingClientRect();
      this[jd](t3);
    }, 50), this[Id] = tu((t3) => {
      const e3 = this.modelIsVisible;
      e3 !== t3 && this.dispatchEvent(new CustomEvent("model-visibility", { detail: { visible: e3 } }));
    }, 0), this[Dd] = null, this[Nd] = null, this[Fd] = new Ed(), this[Od] = (t3) => {
      this.dispatchEvent(new CustomEvent("error", { detail: { type: "webglcontextlost", sourceError: t3.sourceEvent } }));
    }, this.attachShadow({ mode: "open" });
    const t2 = this.shadowRoot;
    let e2, n2;
    if (((t3) => {
      F(pc, t3);
    })(t2), this[Qd] = t2.querySelector(".container"), this[tp] = t2.querySelector(".userInput"), this[ep] = t2.querySelector("canvas"), this[Bd] = this[tp].getAttribute("aria-label"), this.isConnected) {
      const t3 = this.getBoundingClientRect();
      e2 = t3.width, n2 = t3.height;
    } else
      e2 = 300, n2 = 150;
    this[np] = new Ru({ canvas: this[ep], element: this, width: e2, height: n2 }), this[np].addEventListener("model-load", async (t3) => {
      this[Kd](), this[sp](), await ru(), this.dispatchEvent(new CustomEvent("load", { detail: { url: t3.url } }));
    }), Promise.resolve().then(() => {
      this[jd](this.getBoundingClientRect());
    }), rc && (this[Hd] = new ResizeObserver((t3) => {
      if (!this[op].isPresenting)
        for (let e3 of t3)
          e3.target === this && this[jd](e3.contentRect);
    })), sc ? this[qd] = new IntersectionObserver((t3) => {
      for (let e3 of t3)
        if (e3.target === this) {
          const t4 = this.modelIsVisible;
          this[Xd] = e3.isIntersecting, this[Yd](t4), this[Xd] && !this[dp]() && this[$d]();
        }
    }, { root: null, rootMargin: "0px", threshold: 0 }) : this[Xd] = true;
  }
  static get is() {
    return "model-viewer";
  }
  static set modelCacheSize(t2) {
    Gh[Hh].evictionThreshold = t2;
  }
  static get modelCacheSize() {
    return Gh[Hh].evictionThreshold;
  }
  static set minimumRenderScale(t2) {
    t2 > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), t2 <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."), Td.singleton.minScale = t2;
  }
  static get minimumRenderScale() {
    return Td.singleton.minScale;
  }
  get loaded() {
    return this[cp]();
  }
  get [(Ad = Xd, Rd = Wd, Ld = Jd, Cd = Vd, Pd = zd, Id = Yd, Dd = Hd, Nd = qd, Fd = lp, op)]() {
    return Td.singleton;
  }
  get modelIsVisible() {
    return this[hp]();
  }
  connectedCallback() {
    super.connectedCallback && super.connectedCallback(), rc ? this[Hd].observe(this) : self.addEventListener("resize", this[zd]), sc && this[qd].observe(this);
    const t2 = this[op];
    t2.addEventListener("contextlost", this[Gd]), t2.registerScene(this[np]), this[Vd] != null && (self.clearTimeout(this[Vd]), this[Vd] = null, this.requestUpdate("src", null));
  }
  disconnectedCallback() {
    super.disconnectedCallback && super.disconnectedCallback(), rc ? this[Hd].unobserve(this) : self.removeEventListener("resize", this[zd]), sc && this[qd].unobserve(this);
    const t2 = this[op];
    t2.removeEventListener("contextlost", this[Gd]), t2.unregisterScene(this[np]), this[Vd] = self.setTimeout(() => {
      this[np].reset();
    }, 1e3);
  }
  updated(t2) {
    if (super.updated(t2), t2.has("src") && (this.src == null ? (this[Wd] = false, this[Jd] = 0, this[np].reset()) : this.src !== this[np].url && (this[Wd] = false, this[Jd] = 0, this[$d]())), t2.has("alt")) {
      const t3 = this.alt == null ? this[Bd] : this.alt;
      this[tp].setAttribute("aria-label", t3);
    }
  }
  toDataURL(t2, e2) {
    return this[op].displayCanvas(this[np]).toDataURL(t2, e2);
  }
  async toBlob(t2) {
    const e2 = t2 ? t2.mimeType : void 0, n2 = t2 ? t2.qualityArgument : void 0, i2 = t2 ? t2.idealAspect : void 0, { width: r2, height: s2, idealAspect: a2, aspect: o2 } = this[np], { dpr: l2, scaleFactor: c2 } = this[op];
    let h2 = r2 * c2 * l2, u2 = s2 * c2 * l2, d2 = 0, p2 = 0;
    if (i2 === true)
      if (a2 > o2) {
        const t3 = u2;
        u2 = Math.round(h2 / a2), p2 = (t3 - u2) / 2;
      } else {
        const t3 = h2;
        h2 = Math.round(u2 * a2), d2 = (t3 - h2) / 2;
      }
    kd.width = h2, kd.height = u2;
    try {
      return new Promise(async (t3, i3) => (kd.getContext("2d").drawImage(this[op].displayCanvas(this[np]), d2, p2, h2, u2, 0, 0, h2, u2), !kd.msToBlob || e2 && e2 !== "image/png" ? kd.toBlob ? void kd.toBlob((e3) => {
        if (!e3)
          return i3(new Error("Unable to retrieve canvas blob"));
        t3(e3);
      }, e2, n2) : t3(await (async (t4) => new Promise((e3, n3) => {
        const i4 = t4.match(/data:(.*);/);
        if (!i4)
          return n3(new Error(`${t4} is not a valid data Url`));
        const r3 = i4[1], s3 = t4.replace(/data:image\/\w+;base64,/, ""), a3 = atob(s3), o3 = [];
        for (let t5 = 0; t5 < a3.length; t5 += 512) {
          const e4 = a3.slice(t5, t5 + 512), n4 = new Array(e4.length);
          for (let t6 = 0; t6 < e4.length; t6++)
            n4[t6] = e4.charCodeAt(t6);
          const i5 = new Uint8Array(n4);
          o3.push(i5);
        }
        e3(new Blob(o3, { type: r3 }));
      }))(kd.toDataURL(e2, n2))) : t3(kd.msToBlob())));
    } finally {
      this[jd]({ width: r2, height: s2 });
    }
  }
  registerRenderer(t2) {
    this[np].externalRenderer = t2;
  }
  unregisterRenderer() {
    this[np].externalRenderer = null;
  }
  get [Zd]() {
    return this.alt == null || this.alt === "null" ? this[Bd] : this.alt;
  }
  [cp]() {
    return this[Wd];
  }
  [hp]() {
    return this.loaded && this[Xd];
  }
  [pp]() {
    return this.modelIsVisible;
  }
  [up]() {
    return !!this.src && this[Xd];
  }
  [dp]() {
    return this[Wd];
  }
  [jd]({ width: t2, height: e2 }) {
    this[Qd].style.width = `${t2}px`, this[Qd].style.height = `${e2}px`, this[ap]({ width: parseFloat(t2), height: parseFloat(e2) });
  }
  [rp](t2, e2) {
  }
  [Kd]() {
    this[Wd] || (this[Wd] = true, this[Jd] = performance.now());
  }
  [ip]() {
    this[np].queueRender();
  }
  [sp]() {
  }
  [ap](t2) {
    this[np].setSize(t2.width, t2.height);
  }
  async [(Od = Gd, $d)]() {
    if (this.loaded || !this[up]())
      return;
    const t2 = this[lp].beginActivity(), e2 = this.src;
    try {
      await this[np].setSource(e2, (e3) => t2(0.95 * e3));
      const n2 = { url: e2 };
      this.dispatchEvent(new CustomEvent("preload", { detail: n2 }));
    } catch (t3) {
      this.dispatchEvent(new CustomEvent("error", { detail: t3 }));
    } finally {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          t2(1);
        });
      });
    }
  }
}
Ud([Z({ type: String })], gp.prototype, "alt", void 0), Ud([Z({ type: String })], gp.prototype, "src", void 0);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var vp = function(t2, e2, n2, i2) {
  for (var r2, s2 = arguments.length, a2 = s2 < 3 ? e2 : i2 === null ? i2 = Object.getOwnPropertyDescriptor(e2, n2) : i2, o2 = t2.length - 1; o2 >= 0; o2--)
    (r2 = t2[o2]) && (a2 = (s2 < 3 ? r2(a2) : s2 > 3 ? r2(e2, n2, a2) : r2(e2, n2)) || a2);
  return s2 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
};
const yp = Symbol("changeAnimation"), xp = Symbol("paused"), bp = { repetitions: 1 / 0, pingpong: false }, wp = Symbol("hotspotMap"), _p = Symbol("mutationCallback"), Mp = Symbol("observer"), Sp = Symbol("addHotspot"), Tp = Symbol("removeHotspot"), Ep = new re(), Ap = new ft();
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var Rp = function(t2) {
  return URL.createObjectURL(new Blob([t2], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(Rp(""));
} catch (t2) {
  Rp = function(t3) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(t3);
  };
}
var Lp = Uint8Array, Cp = Uint16Array, Pp = Uint32Array, Ip = new Lp([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Dp = new Lp([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Np = new Lp([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Fp = function(t2, e2) {
  for (var n2 = new Cp(31), i2 = 0; i2 < 31; ++i2)
    n2[i2] = e2 += 1 << t2[i2 - 1];
  var r2 = new Pp(n2[30]);
  for (i2 = 1; i2 < 30; ++i2)
    for (var s2 = n2[i2]; s2 < n2[i2 + 1]; ++s2)
      r2[s2] = s2 - n2[i2] << 5 | i2;
  return [n2, r2];
}, Op = Fp(Ip, 2), Up = Op[0], kp = Op[1];
Up[28] = 258, kp[258] = 28;
for (var zp = Fp(Dp, 0)[1], Bp = new Cp(32768), Hp = 0; Hp < 32768; ++Hp) {
  var Vp = (43690 & Hp) >>> 1 | (21845 & Hp) << 1;
  Vp = (61680 & (Vp = (52428 & Vp) >>> 2 | (13107 & Vp) << 2)) >>> 4 | (3855 & Vp) << 4, Bp[Hp] = ((65280 & Vp) >>> 8 | (255 & Vp) << 8) >>> 1;
}
var Gp = function(t2, e2, n2) {
  for (var i2 = t2.length, r2 = 0, s2 = new Cp(e2); r2 < i2; ++r2)
    ++s2[t2[r2] - 1];
  var a2, o2 = new Cp(e2);
  for (r2 = 0; r2 < e2; ++r2)
    o2[r2] = o2[r2 - 1] + s2[r2 - 1] << 1;
  if (n2) {
    a2 = new Cp(1 << e2);
    var l2 = 15 - e2;
    for (r2 = 0; r2 < i2; ++r2)
      if (t2[r2])
        for (var c2 = r2 << 4 | t2[r2], h2 = e2 - t2[r2], u2 = o2[t2[r2] - 1]++ << h2, d2 = u2 | (1 << h2) - 1; u2 <= d2; ++u2)
          a2[Bp[u2] >>> l2] = c2;
  } else
    for (a2 = new Cp(i2), r2 = 0; r2 < i2; ++r2)
      t2[r2] && (a2[r2] = Bp[o2[t2[r2] - 1]++] >>> 15 - t2[r2]);
  return a2;
}, Wp = new Lp(288);
for (Hp = 0; Hp < 144; ++Hp)
  Wp[Hp] = 8;
for (Hp = 144; Hp < 256; ++Hp)
  Wp[Hp] = 9;
for (Hp = 256; Hp < 280; ++Hp)
  Wp[Hp] = 7;
for (Hp = 280; Hp < 288; ++Hp)
  Wp[Hp] = 8;
var jp = new Lp(32);
for (Hp = 0; Hp < 32; ++Hp)
  jp[Hp] = 5;
var qp = Gp(Wp, 9, 0), Xp = Gp(jp, 5, 0), Yp = function(t2) {
  return (t2 / 8 | 0) + (7 & t2 && 1);
}, Zp = function(t2, e2, n2) {
  (e2 == null || e2 < 0) && (e2 = 0), (n2 == null || n2 > t2.length) && (n2 = t2.length);
  var i2 = new (t2 instanceof Cp ? Cp : t2 instanceof Pp ? Pp : Lp)(n2 - e2);
  return i2.set(t2.subarray(e2, n2)), i2;
}, Jp = function(t2, e2, n2) {
  n2 <<= 7 & e2;
  var i2 = e2 / 8 | 0;
  t2[i2] |= n2, t2[i2 + 1] |= n2 >>> 8;
}, $p = function(t2, e2, n2) {
  n2 <<= 7 & e2;
  var i2 = e2 / 8 | 0;
  t2[i2] |= n2, t2[i2 + 1] |= n2 >>> 8, t2[i2 + 2] |= n2 >>> 16;
}, Kp = function(t2, e2) {
  for (var n2 = [], i2 = 0; i2 < t2.length; ++i2)
    t2[i2] && n2.push({ s: i2, f: t2[i2] });
  var r2 = n2.length, s2 = n2.slice();
  if (!r2)
    return [sm, 0];
  if (r2 == 1) {
    var a2 = new Lp(n2[0].s + 1);
    return a2[n2[0].s] = 1, [a2, 1];
  }
  n2.sort(function(t3, e3) {
    return t3.f - e3.f;
  }), n2.push({ s: -1, f: 25001 });
  var o2 = n2[0], l2 = n2[1], c2 = 0, h2 = 1, u2 = 2;
  for (n2[0] = { s: -1, f: o2.f + l2.f, l: o2, r: l2 }; h2 != r2 - 1; )
    o2 = n2[n2[c2].f < n2[u2].f ? c2++ : u2++], l2 = n2[c2 != h2 && n2[c2].f < n2[u2].f ? c2++ : u2++], n2[h2++] = { s: -1, f: o2.f + l2.f, l: o2, r: l2 };
  var d2 = s2[0].s;
  for (i2 = 1; i2 < r2; ++i2)
    s2[i2].s > d2 && (d2 = s2[i2].s);
  var p2 = new Cp(d2 + 1), m2 = Qp(n2[h2 - 1], p2, 0);
  if (m2 > e2) {
    i2 = 0;
    var f2 = 0, g2 = m2 - e2, v2 = 1 << g2;
    for (s2.sort(function(t3, e3) {
      return p2[e3.s] - p2[t3.s] || t3.f - e3.f;
    }); i2 < r2; ++i2) {
      var y2 = s2[i2].s;
      if (!(p2[y2] > e2))
        break;
      f2 += v2 - (1 << m2 - p2[y2]), p2[y2] = e2;
    }
    for (f2 >>>= g2; f2 > 0; ) {
      var x2 = s2[i2].s;
      p2[x2] < e2 ? f2 -= 1 << e2 - p2[x2]++ - 1 : ++i2;
    }
    for (; i2 >= 0 && f2; --i2) {
      var b2 = s2[i2].s;
      p2[b2] == e2 && (--p2[b2], ++f2);
    }
    m2 = e2;
  }
  return [new Lp(p2), m2];
}, Qp = function(t2, e2, n2) {
  return t2.s == -1 ? Math.max(Qp(t2.l, e2, n2 + 1), Qp(t2.r, e2, n2 + 1)) : e2[t2.s] = n2;
}, tm = function(t2) {
  for (var e2 = t2.length; e2 && !t2[--e2]; )
    ;
  for (var n2 = new Cp(++e2), i2 = 0, r2 = t2[0], s2 = 1, a2 = function(t3) {
    n2[i2++] = t3;
  }, o2 = 1; o2 <= e2; ++o2)
    if (t2[o2] == r2 && o2 != e2)
      ++s2;
    else {
      if (!r2 && s2 > 2) {
        for (; s2 > 138; s2 -= 138)
          a2(32754);
        s2 > 2 && (a2(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
      } else if (s2 > 3) {
        for (a2(r2), --s2; s2 > 6; s2 -= 6)
          a2(8304);
        s2 > 2 && (a2(s2 - 3 << 5 | 8208), s2 = 0);
      }
      for (; s2--; )
        a2(r2);
      s2 = 1, r2 = t2[o2];
    }
  return [n2.subarray(0, i2), e2];
}, em = function(t2, e2) {
  for (var n2 = 0, i2 = 0; i2 < e2.length; ++i2)
    n2 += t2[i2] * e2[i2];
  return n2;
}, nm = function(t2, e2, n2) {
  var i2 = n2.length, r2 = Yp(e2 + 2);
  t2[r2] = 255 & i2, t2[r2 + 1] = i2 >>> 8, t2[r2 + 2] = 255 ^ t2[r2], t2[r2 + 3] = 255 ^ t2[r2 + 1];
  for (var s2 = 0; s2 < i2; ++s2)
    t2[r2 + s2 + 4] = n2[s2];
  return 8 * (r2 + 4 + i2);
}, im = function(t2, e2, n2, i2, r2, s2, a2, o2, l2, c2, h2) {
  Jp(e2, h2++, n2), ++r2[256];
  for (var u2 = Kp(r2, 15), d2 = u2[0], p2 = u2[1], m2 = Kp(s2, 15), f2 = m2[0], g2 = m2[1], v2 = tm(d2), y2 = v2[0], x2 = v2[1], b2 = tm(f2), w2 = b2[0], _2 = b2[1], M2 = new Cp(19), S2 = 0; S2 < y2.length; ++S2)
    M2[31 & y2[S2]]++;
  for (S2 = 0; S2 < w2.length; ++S2)
    M2[31 & w2[S2]]++;
  for (var T2 = Kp(M2, 7), E2 = T2[0], A2 = T2[1], R2 = 19; R2 > 4 && !E2[Np[R2 - 1]]; --R2)
    ;
  var L2, C2, P2, I2, D2 = c2 + 5 << 3, N2 = em(r2, Wp) + em(s2, jp) + a2, F2 = em(r2, d2) + em(s2, f2) + a2 + 14 + 3 * R2 + em(M2, E2) + (2 * M2[16] + 3 * M2[17] + 7 * M2[18]);
  if (D2 <= N2 && D2 <= F2)
    return nm(e2, h2, t2.subarray(l2, l2 + c2));
  if (Jp(e2, h2, 1 + (F2 < N2)), h2 += 2, F2 < N2) {
    L2 = Gp(d2, p2, 0), C2 = d2, P2 = Gp(f2, g2, 0), I2 = f2;
    var O2 = Gp(E2, A2, 0);
    Jp(e2, h2, x2 - 257), Jp(e2, h2 + 5, _2 - 1), Jp(e2, h2 + 10, R2 - 4), h2 += 14;
    for (S2 = 0; S2 < R2; ++S2)
      Jp(e2, h2 + 3 * S2, E2[Np[S2]]);
    h2 += 3 * R2;
    for (var U2 = [y2, w2], k2 = 0; k2 < 2; ++k2) {
      var z2 = U2[k2];
      for (S2 = 0; S2 < z2.length; ++S2) {
        var B2 = 31 & z2[S2];
        Jp(e2, h2, O2[B2]), h2 += E2[B2], B2 > 15 && (Jp(e2, h2, z2[S2] >>> 5 & 127), h2 += z2[S2] >>> 12);
      }
    }
  } else
    L2 = qp, C2 = Wp, P2 = Xp, I2 = jp;
  for (S2 = 0; S2 < o2; ++S2)
    if (i2[S2] > 255) {
      B2 = i2[S2] >>> 18 & 31;
      $p(e2, h2, L2[B2 + 257]), h2 += C2[B2 + 257], B2 > 7 && (Jp(e2, h2, i2[S2] >>> 23 & 31), h2 += Ip[B2]);
      var H2 = 31 & i2[S2];
      $p(e2, h2, P2[H2]), h2 += I2[H2], H2 > 3 && ($p(e2, h2, i2[S2] >>> 5 & 8191), h2 += Dp[H2]);
    } else
      $p(e2, h2, L2[i2[S2]]), h2 += C2[i2[S2]];
  return $p(e2, h2, L2[256]), h2 + C2[256];
}, rm = new Pp([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), sm = new Lp(0), am = function() {
  for (var t2 = new Pp(256), e2 = 0; e2 < 256; ++e2) {
    for (var n2 = e2, i2 = 9; --i2; )
      n2 = (1 & n2 && 3988292384) ^ n2 >>> 1;
    t2[e2] = n2;
  }
  return t2;
}(), om = function() {
  var t2 = -1;
  return { p: function(e2) {
    for (var n2 = t2, i2 = 0; i2 < e2.length; ++i2)
      n2 = am[255 & n2 ^ e2[i2]] ^ n2 >>> 8;
    t2 = n2;
  }, d: function() {
    return ~t2;
  } };
}, lm = function(t2, e2, n2, i2, r2) {
  return function(t3, e3, n3, i3, r3, s2) {
    var a2 = t3.length, o2 = new Lp(i3 + a2 + 5 * (1 + Math.ceil(a2 / 7e3)) + r3), l2 = o2.subarray(i3, o2.length - r3), c2 = 0;
    if (!e3 || a2 < 8)
      for (var h2 = 0; h2 <= a2; h2 += 65535) {
        var u2 = h2 + 65535;
        u2 < a2 ? c2 = nm(l2, c2, t3.subarray(h2, u2)) : (l2[h2] = s2, c2 = nm(l2, c2, t3.subarray(h2, a2)));
      }
    else {
      for (var d2 = rm[e3 - 1], p2 = d2 >>> 13, m2 = 8191 & d2, f2 = (1 << n3) - 1, g2 = new Cp(32768), v2 = new Cp(f2 + 1), y2 = Math.ceil(n3 / 3), x2 = 2 * y2, b2 = function(e4) {
        return (t3[e4] ^ t3[e4 + 1] << y2 ^ t3[e4 + 2] << x2) & f2;
      }, w2 = new Pp(25e3), _2 = new Cp(288), M2 = new Cp(32), S2 = 0, T2 = 0, E2 = (h2 = 0, 0), A2 = 0, R2 = 0; h2 < a2; ++h2) {
        var L2 = b2(h2), C2 = 32767 & h2, P2 = v2[L2];
        if (g2[C2] = P2, v2[L2] = C2, A2 <= h2) {
          var I2 = a2 - h2;
          if ((S2 > 7e3 || E2 > 24576) && I2 > 423) {
            c2 = im(t3, l2, 0, w2, _2, M2, T2, E2, R2, h2 - R2, c2), E2 = S2 = T2 = 0, R2 = h2;
            for (var D2 = 0; D2 < 286; ++D2)
              _2[D2] = 0;
            for (D2 = 0; D2 < 30; ++D2)
              M2[D2] = 0;
          }
          var N2 = 2, F2 = 0, O2 = m2, U2 = C2 - P2 & 32767;
          if (I2 > 2 && L2 == b2(h2 - U2))
            for (var k2 = Math.min(p2, I2) - 1, z2 = Math.min(32767, h2), B2 = Math.min(258, I2); U2 <= z2 && --O2 && C2 != P2; ) {
              if (t3[h2 + N2] == t3[h2 + N2 - U2]) {
                for (var H2 = 0; H2 < B2 && t3[h2 + H2] == t3[h2 + H2 - U2]; ++H2)
                  ;
                if (H2 > N2) {
                  if (N2 = H2, F2 = U2, H2 > k2)
                    break;
                  var V2 = Math.min(U2, H2 - 2), G2 = 0;
                  for (D2 = 0; D2 < V2; ++D2) {
                    var W2 = h2 - U2 + D2 + 32768 & 32767, j2 = W2 - g2[W2] + 32768 & 32767;
                    j2 > G2 && (G2 = j2, P2 = W2);
                  }
                }
              }
              U2 += (C2 = P2) - (P2 = g2[C2]) + 32768 & 32767;
            }
          if (F2) {
            w2[E2++] = 268435456 | kp[N2] << 18 | zp[F2];
            var q2 = 31 & kp[N2], X2 = 31 & zp[F2];
            T2 += Ip[q2] + Dp[X2], ++_2[257 + q2], ++M2[X2], A2 = h2 + N2, ++S2;
          } else
            w2[E2++] = t3[h2], ++_2[t3[h2]];
        }
      }
      c2 = im(t3, l2, s2, w2, _2, M2, T2, E2, R2, h2 - R2, c2), !s2 && 7 & c2 && (c2 = nm(l2, c2 + 1, sm));
    }
    return Zp(o2, 0, i3 + Yp(c2) + r3);
  }(t2, e2.level == null ? 6 : e2.level, e2.mem == null ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t2.length)))) : 12 + e2.mem, n2, i2, !r2);
}, cm = function(t2, e2) {
  var n2 = {};
  for (var i2 in t2)
    n2[i2] = t2[i2];
  for (var i2 in e2)
    n2[i2] = e2[i2];
  return n2;
}, hm = function(t2, e2, n2) {
  for (; n2; ++e2)
    t2[e2] = n2, n2 >>>= 8;
};
function um(t2, e2) {
  return lm(t2, e2 || {}, 0, 0);
}
var dm = function(t2, e2, n2, i2) {
  for (var r2 in t2) {
    var s2 = t2[r2], a2 = e2 + r2;
    s2 instanceof Lp ? n2[a2] = [s2, i2] : Array.isArray(s2) ? n2[a2] = [s2[0], cm(i2, s2[1])] : dm(s2, a2 + "/", n2, i2);
  }
}, pm = typeof TextEncoder != "undefined" && new TextEncoder(), mm = typeof TextDecoder != "undefined" && new TextDecoder();
try {
  mm.decode(sm, { stream: true }), 1;
} catch (t2) {
}
function fm(t2, e2) {
  if (e2) {
    for (var n2 = new Lp(t2.length), i2 = 0; i2 < t2.length; ++i2)
      n2[i2] = t2.charCodeAt(i2);
    return n2;
  }
  if (pm)
    return pm.encode(t2);
  var r2 = t2.length, s2 = new Lp(t2.length + (t2.length >> 1)), a2 = 0, o2 = function(t3) {
    s2[a2++] = t3;
  };
  for (i2 = 0; i2 < r2; ++i2) {
    if (a2 + 5 > s2.length) {
      var l2 = new Lp(a2 + 8 + (r2 - i2 << 1));
      l2.set(s2), s2 = l2;
    }
    var c2 = t2.charCodeAt(i2);
    c2 < 128 || e2 ? o2(c2) : c2 < 2048 ? (o2(192 | c2 >> 6), o2(128 | 63 & c2)) : c2 > 55295 && c2 < 57344 ? (o2(240 | (c2 = 65536 + (1047552 & c2) | 1023 & t2.charCodeAt(++i2)) >> 18), o2(128 | c2 >> 12 & 63), o2(128 | c2 >> 6 & 63), o2(128 | 63 & c2)) : (o2(224 | c2 >> 12), o2(128 | c2 >> 6 & 63), o2(128 | 63 & c2));
  }
  return Zp(s2, 0, a2);
}
var gm = function(t2) {
  var e2 = 0;
  if (t2)
    for (var n2 in t2) {
      var i2 = t2[n2].length;
      if (i2 > 65535)
        throw "extra field too long";
      e2 += i2 + 4;
    }
  return e2;
}, vm = function(t2, e2, n2, i2, r2, s2, a2, o2) {
  var l2 = i2.length, c2 = n2.extra, h2 = o2 && o2.length, u2 = gm(c2);
  hm(t2, e2, a2 != null ? 33639248 : 67324752), e2 += 4, a2 != null && (t2[e2++] = 20, t2[e2++] = n2.os), t2[e2] = 20, e2 += 2, t2[e2++] = n2.flag << 1 | (s2 == null && 8), t2[e2++] = r2 && 8, t2[e2++] = 255 & n2.compression, t2[e2++] = n2.compression >> 8;
  var d2 = new Date(n2.mtime == null ? Date.now() : n2.mtime), p2 = d2.getFullYear() - 1980;
  if (p2 < 0 || p2 > 119)
    throw "date not in range 1980-2099";
  if (hm(t2, e2, p2 << 25 | d2.getMonth() + 1 << 21 | d2.getDate() << 16 | d2.getHours() << 11 | d2.getMinutes() << 5 | d2.getSeconds() >>> 1), e2 += 4, s2 != null && (hm(t2, e2, n2.crc), hm(t2, e2 + 4, s2), hm(t2, e2 + 8, n2.size)), hm(t2, e2 + 12, l2), hm(t2, e2 + 14, u2), e2 += 16, a2 != null && (hm(t2, e2, h2), hm(t2, e2 + 6, n2.attrs), hm(t2, e2 + 10, a2), e2 += 14), t2.set(i2, e2), e2 += l2, u2)
    for (var m2 in c2) {
      var f2 = c2[m2], g2 = f2.length;
      hm(t2, e2, +m2), hm(t2, e2 + 2, g2), t2.set(f2, e2 + 4), e2 += 4 + g2;
    }
  return h2 && (t2.set(o2, e2), e2 += h2), e2;
};
function ym(t2, e2) {
  e2 || (e2 = {});
  var n2 = {}, i2 = [];
  dm(t2, "", n2, e2);
  var r2 = 0, s2 = 0;
  for (var a2 in n2) {
    var o2 = n2[a2], l2 = o2[0], c2 = o2[1], h2 = c2.level == 0 ? 0 : 8, u2 = (M2 = fm(a2)).length, d2 = c2.comment, p2 = d2 && fm(d2), m2 = p2 && p2.length, f2 = gm(c2.extra);
    if (u2 > 65535)
      throw "filename too long";
    var g2 = h2 ? um(l2, c2) : l2, v2 = g2.length, y2 = om();
    y2.p(l2), i2.push(cm(c2, { size: l2.length, crc: y2.d(), c: g2, f: M2, m: p2, u: u2 != a2.length || p2 && d2.length != m2, o: r2, compression: h2 })), r2 += 30 + u2 + f2 + v2, s2 += 76 + 2 * (u2 + f2) + (m2 || 0) + v2;
  }
  for (var x2 = new Lp(s2 + 22), b2 = r2, w2 = s2 - r2, _2 = 0; _2 < i2.length; ++_2) {
    var M2 = i2[_2];
    vm(x2, M2.o, M2, M2.f, M2.u, M2.c.length);
    var S2 = 30 + M2.f.length + gm(M2.extra);
    x2.set(M2.c, M2.o + S2), vm(x2, r2, M2, M2.f, M2.u, M2.c.length, M2.o, M2.m), r2 += 16 + S2 + (M2.m ? M2.m.length : 0);
  }
  return function(t3, e3, n3, i3, r3) {
    hm(t3, e3, 101010256), hm(t3, e3 + 8, n3), hm(t3, e3 + 10, n3), hm(t3, e3 + 12, i3), hm(t3, e3 + 16, r3);
  }(x2, r2, i2.length, w2, b2), x2;
}
class xm {
  async parse(t2) {
    const e2 = {};
    e2["model.usda"] = null;
    let n2 = wm();
    const i2 = {}, r2 = {};
    t2.traverseVisible((t3) => {
      if (t3.isMesh)
        if (t3.material.isMeshStandardMaterial) {
          const r3 = t3.geometry, s3 = t3.material, a2 = "geometries/Geometry_" + r3.id + ".usd";
          if (!(a2 in e2)) {
            const t4 = function(t5) {
              return `
def "Geometry"
{
  ${function(t6) {
                const e3 = "Geometry", n3 = t6.attributes, i3 = n3.position.count;
                return `
    def Mesh "${e3}"
    {
        int[] faceVertexCounts = [${function(t7) {
                  const e4 = t7.index !== null ? t7.index.count : t7.attributes.position.count;
                  return Array(e4 / 3).fill(3).join(", ");
                }(t6)}]
        int[] faceVertexIndices = [${function(t7) {
                  const e4 = t7.index, n4 = [];
                  if (e4 !== null)
                    for (let t8 = 0; t8 < e4.count; t8++)
                      n4.push(e4.getX(t8));
                  else {
                    const e5 = t7.attributes.position.count;
                    for (let t8 = 0; t8 < e5; t8++)
                      n4.push(t8);
                  }
                  return n4.join(", ");
                }(t6)}]
        normal3f[] normals = [${Mm(n3.normal, i3)}] (
            interpolation = "vertex"
        )
        point3f[] points = [${Mm(n3.position, i3)}]
        float2[] primvars:st = [${function(t7, e4) {
                  if (t7 === void 0)
                    return console.warn("USDZExporter: UVs missing."), Array(e4).fill("(0, 0)").join(", ");
                  const n4 = [];
                  for (let e5 = 0; e5 < t7.count; e5++) {
                    const i4 = t7.getX(e5), r4 = t7.getY(e5);
                    n4.push(`(${i4.toPrecision(7)}, ${1 - r4.toPrecision(7)})`);
                  }
                  return n4.join(", ");
                }(n3.uv, i3)}] (
            interpolation = "vertex"
        )
        uniform token subdivisionScheme = "none"
    }
`;
              }(t5)}
}
`;
            }(r3);
            e2[a2] = function(t5) {
              let e3 = wm();
              return e3 += t5, fm(e3);
            }(t4);
          }
          s3.uuid in i2 || (i2[s3.uuid] = s3), n2 += function(t4, e3, n3) {
            const i3 = "Object_" + t4.id, r4 = function(t5) {
              const e4 = t5.elements;
              return `( ${_m(e4, 0)}, ${_m(e4, 4)}, ${_m(e4, 8)}, ${_m(e4, 12)} )`;
            }(t4.matrixWorld);
            t4.matrixWorld.determinant() < 0 && console.warn("THREE.USDZExporter: USDZ does not support negative scales", t4);
            return `def Xform "${i3}" (
    prepend references = @./geometries/Geometry_${e3.id}.usd@</Geometry>
)
{
    matrix4d xformOp:transform = ${r4}
    uniform token[] xformOpOrder = ["xformOp:transform"]

    rel material:binding = </Materials/Material_${n3.id}>
}

`;
          }(t3, r3, s3);
        } else
          console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", t3);
    }), n2 += function(t3, e3) {
      const n3 = [];
      for (const i3 in t3) {
        const r3 = t3[i3];
        n3.push(Sm(r3, e3));
      }
      return `def "Materials"
{
${n3.join("")}
}

`;
    }(i2, r2), e2["model.usda"] = fm(n2), n2 = null;
    for (const t3 in r2) {
      const n3 = r2[t3], i3 = t3.split("_")[1], s3 = n3.format === 1023, a2 = bm(n3.image, i3), o2 = await new Promise((t4) => a2.toBlob(t4, s3 ? "image/png" : "image/jpeg", 1));
      e2[`textures/Texture_${t3}.${s3 ? "png" : "jpg"}`] = new Uint8Array(await o2.arrayBuffer());
    }
    let s2 = 0;
    for (const t3 in e2) {
      const n3 = e2[t3];
      s2 += 34 + t3.length;
      const i3 = 63 & s2;
      if (i3 !== 4) {
        const r3 = new Uint8Array(64 - i3);
        e2[t3] = [n3, { extra: { 12345: r3 } }];
      }
      s2 = n3.length;
    }
    return ym(e2, { level: 0 });
  }
}
function bm(t2, e2) {
  if (typeof HTMLImageElement != "undefined" && t2 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t2 instanceof HTMLCanvasElement || typeof OffscreenCanvas != "undefined" && t2 instanceof OffscreenCanvas || typeof ImageBitmap != "undefined" && t2 instanceof ImageBitmap) {
    const n2 = 1024 / Math.max(t2.width, t2.height), i2 = document.createElement("canvas");
    i2.width = t2.width * Math.min(1, n2), i2.height = t2.height * Math.min(1, n2);
    const r2 = i2.getContext("2d");
    if (r2.drawImage(t2, 0, 0, i2.width, i2.height), e2 !== void 0) {
      const t3 = parseInt(e2, 16), n3 = (t3 >> 16 & 255) / 255, s2 = (t3 >> 8 & 255) / 255, a2 = (255 & t3) / 255, o2 = r2.getImageData(0, 0, i2.width, i2.height), l2 = o2.data;
      for (let t4 = 0; t4 < l2.length; t4 += 4)
        l2[t4 + 0] = l2[t4 + 0] * n3, l2[t4 + 1] = l2[t4 + 1] * s2, l2[t4 + 2] = l2[t4 + 2] * a2;
      r2.putImageData(o2, 0, 0);
    }
    return i2;
  }
}
function wm() {
  return '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
}
function _m(t2, e2) {
  return `(${t2[e2 + 0]}, ${t2[e2 + 1]}, ${t2[e2 + 2]}, ${t2[e2 + 3]})`;
}
function Mm(t2, e2) {
  if (t2 === void 0)
    return console.warn("USDZExporter: Normals missing."), Array(e2).fill("(0, 0, 0)").join(", ");
  const n2 = [];
  for (let e3 = 0; e3 < t2.count; e3++) {
    const i2 = t2.getX(e3), r2 = t2.getY(e3), s2 = t2.getZ(e3);
    n2.push(`(${i2.toPrecision(7)}, ${r2.toPrecision(7)}, ${s2.toPrecision(7)})`);
  }
  return n2.join(", ");
}
function Sm(t2, e2) {
  const n2 = "            ", i2 = [], r2 = [];
  function s2(n3, i3, r3) {
    const s3 = n3.id + (r3 ? "_" + r3.getHexString() : ""), a2 = n3.format === 1023;
    return e2[s3] = n3, `
        def Shader "Transform2d_${i3}" (
            sdrMetadata = {
                string role = "math"
            }
        )
        {
            uniform token info:id = "UsdTransform2d"
            float2 inputs:in.connect = </Materials/Material_${t2.id}/uvReader_st.outputs:result>
            float2 inputs:scale = ${Em(n3.repeat)}
            float2 inputs:translation = ${Em(n3.offset)}
            float2 outputs:result
        }

        def Shader "Texture_${n3.id}_${i3}"
        {
            uniform token info:id = "UsdUVTexture"
            asset inputs:file = @textures/Texture_${s3}.${a2 ? "png" : "jpg"}@
            float2 inputs:st.connect = </Materials/Material_${t2.id}/Transform2d_${i3}.outputs:result>
            token inputs:wrapS = "repeat"
            token inputs:wrapT = "repeat"
            float outputs:r
            float outputs:g
            float outputs:b
            float3 outputs:rgb
        }`;
  }
  return t2.map !== null ? (i2.push(`${n2}color3f inputs:diffuseColor.connect = </Materials/Material_${t2.id}/Texture_${t2.map.id}_diffuse.outputs:rgb>`), r2.push(s2(t2.map, "diffuse", t2.color))) : i2.push(`${n2}color3f inputs:diffuseColor = ${Tm(t2.color)}`), t2.emissiveMap !== null ? (i2.push(`${n2}color3f inputs:emissiveColor.connect = </Materials/Material_${t2.id}/Texture_${t2.emissiveMap.id}_emissive.outputs:rgb>`), r2.push(s2(t2.emissiveMap, "emissive"))) : t2.emissive.getHex() > 0 && i2.push(`${n2}color3f inputs:emissiveColor = ${Tm(t2.emissive)}`), t2.normalMap !== null && (i2.push(`${n2}normal3f inputs:normal.connect = </Materials/Material_${t2.id}/Texture_${t2.normalMap.id}_normal.outputs:rgb>`), r2.push(s2(t2.normalMap, "normal"))), t2.aoMap !== null && (i2.push(`${n2}float inputs:occlusion.connect = </Materials/Material_${t2.id}/Texture_${t2.aoMap.id}_occlusion.outputs:r>`), r2.push(s2(t2.aoMap, "occlusion"))), t2.roughnessMap !== null && t2.roughness === 1 ? (i2.push(`${n2}float inputs:roughness.connect = </Materials/Material_${t2.id}/Texture_${t2.roughnessMap.id}_roughness.outputs:g>`), r2.push(s2(t2.roughnessMap, "roughness"))) : i2.push(`${n2}float inputs:roughness = ${t2.roughness}`), t2.metalnessMap !== null && t2.metalness === 1 ? (i2.push(`${n2}float inputs:metallic.connect = </Materials/Material_${t2.id}/Texture_${t2.metalnessMap.id}_metallic.outputs:b>`), r2.push(s2(t2.metalnessMap, "metallic"))) : i2.push(`${n2}float inputs:metallic = ${t2.metalness}`), t2.alphaMap !== null ? (i2.push(`${n2}float inputs:opacity.connect = </Materials/Material_${t2.id}/Texture_${t2.alphaMap.id}_opacity.outputs:r>`), i2.push(`${n2}float inputs:opacityThreshold = 0.0001`), r2.push(s2(t2.alphaMap, "opacity"))) : i2.push(`${n2}float inputs:opacity = ${t2.opacity}`), t2.isMeshPhysicalMaterial && (i2.push(`${n2}float inputs:clearcoat = ${t2.clearcoat}`), i2.push(`${n2}float inputs:clearcoatRoughness = ${t2.clearcoatRoughness}`), i2.push(`${n2}float inputs:ior = ${t2.ior}`)), `
    def Material "Material_${t2.id}"
    {
        def Shader "PreviewSurface"
        {
            uniform token info:id = "UsdPreviewSurface"
${i2.join("\n")}
            int inputs:useSpecularWorkflow = 0
            token outputs:surface
        }

        token outputs:surface.connect = </Materials/Material_${t2.id}/PreviewSurface.outputs:surface>
        token inputs:frame:stPrimvarName = "st"

        def Shader "uvReader_st"
        {
            uniform token info:id = "UsdPrimvarReader_float2"
            token inputs:varname.connect = </Materials/Material_${t2.id}.inputs:frame:stPrimvarName>
            float2 inputs:fallback = (0.0, 0.0)
            float2 outputs:result
        }

${r2.join("\n")}

    }
`;
}
function Tm(t2) {
  return `(${t2.r}, ${t2.g}, ${t2.b})`;
}
function Em(t2) {
  return `(${t2.x}, ${t2.y})`;
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Am = function(t2, e2, n2, i2) {
  for (var r2, s2 = arguments.length, a2 = s2 < 3 ? e2 : i2 === null ? i2 = Object.getOwnPropertyDescriptor(e2, n2) : i2, o2 = t2.length - 1; o2 >= 0; o2--)
    (r2 = t2[o2]) && (a2 = (s2 < 3 ? r2(a2) : s2 > 3 ? r2(e2, n2, a2) : r2(e2, n2)) || a2);
  return s2 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
};
let Rm = false, Lm = false;
const Cm = (Pm = ["quick-look", "scene-viewer", "webxr", "none"], (t2) => {
  try {
    const e2 = ou(t2), n2 = (e2.length ? e2[0].terms : []).filter((t3) => t3 && t3.type === "ident").map((t3) => t3.value).filter((t3) => Pm.indexOf(t3) > -1), i2 = /* @__PURE__ */ new Set();
    for (const t3 of n2)
      i2.add(t3);
    return i2;
  } catch (t3) {
  }
  return /* @__PURE__ */ new Set();
});
var Pm;
const Im = "quick-look", Dm = "scene-viewer", Nm = "webxr", Fm = "none", Om = Symbol("arButtonContainer"), Um = Symbol("enterARWithWebXR"), km = Symbol("openSceneViewer"), zm = Symbol("openIOSARQuickLook"), Bm = Symbol("canActivateAR"), Hm = Symbol("arMode"), Vm = Symbol("arModes"), Gm = Symbol("arAnchor"), Wm = Symbol("preload"), jm = Symbol("onARButtonContainerClick"), qm = Symbol("onARStatus"), Xm = Symbol("onARTracking"), Ym = Symbol("onARTap"), Zm = Symbol("selectARMode"), Jm = Symbol("triggerLoad");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var $m, Km, Qm;
const tf = Symbol("evaluate"), ef = Symbol("lastValue");
class nf {
  constructor() {
    this[$m] = null;
  }
  static evaluatableFor(t2, e2 = fu) {
    if (t2 instanceof nf)
      return t2;
    if (t2.type === "number")
      return t2.unit === "%" ? new af(t2, e2) : t2;
    switch (t2.name.value) {
      case "calc":
        return new uf(t2, e2);
      case "env":
        return new lf(t2);
    }
    return fu;
  }
  static evaluate(t2) {
    return t2 instanceof nf ? t2.evaluate() : t2;
  }
  static isConstant(t2) {
    return !(t2 instanceof nf) || t2.isConstant;
  }
  static applyIntrinsics(t2, e2) {
    const { basis: n2, keywords: i2 } = e2, { auto: r2 } = i2;
    return n2.map((e3, n3) => {
      const s2 = r2[n3] == null ? e3 : r2[n3];
      let a2 = t2[n3] ? t2[n3] : s2;
      if (a2.type === "ident") {
        const t3 = a2.value;
        t3 in i2 && (a2 = i2[t3][n3]);
      }
      return a2 != null && a2.type !== "ident" || (a2 = s2), a2.unit === "%" ? au(a2.number / 100 * e3.number, e3.unit) : (a2 = yu(a2, e3), a2.unit !== e3.unit ? e3 : a2);
    });
  }
  get isConstant() {
    return false;
  }
  evaluate() {
    return this.isConstant && this[ef] != null || (this[ef] = this[tf]()), this[ef];
  }
}
$m = ef;
const rf = Symbol("percentage"), sf = Symbol("basis");
class af extends nf {
  constructor(t2, e2) {
    super(), this[rf] = t2, this[sf] = e2;
  }
  get isConstant() {
    return true;
  }
  [tf]() {
    return au(this[rf].number / 100 * this[sf].number, this[sf].unit);
  }
}
const of = Symbol("identNode");
class lf extends nf {
  constructor(t2) {
    super(), this[Km] = null;
    const e2 = t2.arguments.length ? t2.arguments[0].terms[0] : null;
    e2 != null && e2.type === "ident" && (this[of] = e2);
  }
  get isConstant() {
    return false;
  }
  [(Km = of, tf)]() {
    if (this[of] != null && this[of].value === "window-scroll-y") {
      return { type: "number", number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0, unit: null };
    }
    return fu;
  }
}
const cf = /[\*\/]/, hf = Symbol("evalutor");
class uf extends nf {
  constructor(t2, e2 = fu) {
    if (super(), this[Qm] = null, t2.arguments.length !== 1)
      return;
    const n2 = t2.arguments[0].terms.slice(), i2 = [];
    for (; n2.length; ) {
      const t3 = n2.shift();
      if (i2.length > 0) {
        const n3 = i2[i2.length - 1];
        if (n3.type === "operator" && cf.test(n3.value)) {
          const n4 = i2.pop(), r2 = i2.pop();
          if (r2 == null)
            return;
          i2.push(new ff(n4, nf.evaluatableFor(r2, e2), nf.evaluatableFor(t3, e2)));
          continue;
        }
      }
      i2.push(t3.type === "operator" ? t3 : nf.evaluatableFor(t3, e2));
    }
    for (; i2.length > 2; ) {
      const [t3, n3, r2] = i2.splice(0, 3);
      if (n3.type !== "operator")
        return;
      i2.unshift(new ff(n3, nf.evaluatableFor(t3, e2), nf.evaluatableFor(r2, e2)));
    }
    i2.length === 1 && (this[hf] = i2[0]);
  }
  get isConstant() {
    return this[hf] == null || nf.isConstant(this[hf]);
  }
  [(Qm = hf, tf)]() {
    return this[hf] != null ? nf.evaluate(this[hf]) : fu;
  }
}
const df = Symbol("operator"), pf = Symbol("left"), mf = Symbol("right");
class ff extends nf {
  constructor(t2, e2, n2) {
    super(), this[df] = t2, this[pf] = e2, this[mf] = n2;
  }
  get isConstant() {
    return nf.isConstant(this[pf]) && nf.isConstant(this[mf]);
  }
  [tf]() {
    const t2 = yu(nf.evaluate(this[pf])), e2 = yu(nf.evaluate(this[mf])), { number: n2, unit: i2 } = t2, { number: r2, unit: s2 } = e2;
    if (s2 != null && i2 != null && s2 != i2)
      return fu;
    const a2 = i2 || s2;
    let o2;
    switch (this[df].value) {
      case "+":
        o2 = n2 + r2;
        break;
      case "-":
        o2 = n2 - r2;
        break;
      case "/":
        o2 = n2 / r2;
        break;
      case "*":
        o2 = n2 * r2;
        break;
      default:
        return fu;
    }
    return { type: "number", number: o2, unit: a2 };
  }
}
const gf = Symbol("evaluatables"), vf = Symbol("intrinsics");
class yf extends nf {
  constructor(t2, e2) {
    super(), this[vf] = e2;
    const n2 = t2[0], i2 = n2 != null ? n2.terms : [];
    this[gf] = e2.basis.map((t3, e3) => {
      const n3 = i2[e3];
      return n3 == null ? { type: "ident", value: "auto" } : n3.type === "ident" ? n3 : nf.evaluatableFor(n3, t3);
    });
  }
  get isConstant() {
    for (const t2 of this[gf])
      if (!nf.isConstant(t2))
        return false;
    return true;
  }
  [tf]() {
    const t2 = this[gf].map((t3) => nf.evaluate(t3));
    return nf.applyIntrinsics(t2, this[vf]).map((t3) => t3.number);
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var xf, bf, wf, _f;
const Mf = Symbol("instances"), Sf = Symbol("activateListener"), Tf = Symbol("deactivateListener"), Ef = Symbol("notifyInstances"), Af = Symbol("notify"), Rf = Symbol("callback");
class Lf {
  constructor(t2) {
    this[Rf] = t2;
  }
  static [Ef]() {
    for (const t2 of Lf[Mf])
      t2[Af]();
  }
  static [(xf = Mf, Sf)]() {
    window.addEventListener("scroll", this[Ef], { passive: true });
  }
  static [Tf]() {
    window.removeEventListener("scroll", this[Ef]);
  }
  observe() {
    Lf[Mf].size === 0 && Lf[Sf](), Lf[Mf].add(this);
  }
  disconnect() {
    Lf[Mf].delete(this), Lf[Mf].size === 0 && Lf[Tf]();
  }
  [Af]() {
    this[Rf]();
  }
}
Lf[xf] = /* @__PURE__ */ new Set();
const Cf = Symbol("computeStyleCallback"), Pf = Symbol("astWalker"), If = Symbol("dependencies"), Df = Symbol("onScroll");
class Nf {
  constructor(t2) {
    this[bf] = {}, this[wf] = new mu(["function"]), this[_f] = () => {
      this[Cf]({ relatedState: "window-scroll" });
    }, this[Cf] = t2;
  }
  observeEffectsFor(t2) {
    const e2 = {}, n2 = this[If];
    this[Pf].walk(t2, (t3) => {
      const { name: i2 } = t3, r2 = t3.arguments[0].terms[0];
      if (i2.value === "env" && r2 != null && r2.type === "ident" && r2.value === "window-scroll-y") {
        if (e2["window-scroll"] == null) {
          const t4 = "window-scroll" in n2 ? n2["window-scroll"] : new Lf(this[Df]);
          t4.observe(), delete n2["window-scroll"], e2["window-scroll"] = t4;
        }
      }
    });
    for (const t3 in n2) {
      n2[t3].disconnect();
    }
    this[If] = e2;
  }
  dispose() {
    for (const t2 in this[If]) {
      this[If][t2].disconnect();
    }
  }
}
bf = If, wf = Pf, _f = Df;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ff = (t2) => {
  const e2 = t2.observeEffects || false, n2 = t2.intrinsics instanceof Function ? t2.intrinsics : () => t2.intrinsics;
  return (i2, r2) => {
    const s2 = i2.updated, a2 = i2.connectedCallback, o2 = i2.disconnectedCallback, l2 = Symbol(`${r2}StyleEffector`), c2 = Symbol(`${r2}StyleEvaluator`), h2 = Symbol(`${r2}UpdateEvaluator`), u2 = Symbol(`${r2}EvaluateAndSync`);
    Object.defineProperties(i2, { [l2]: { value: null, writable: true }, [c2]: { value: null, writable: true }, [h2]: { value: function() {
      const t3 = ou(this[r2]);
      this[c2] = new yf(t3, n2(this)), this[l2] == null && e2 && (this[l2] = new Nf(() => this[u2]())), this[l2] != null && this[l2].observeEffectsFor(t3);
    } }, [u2]: { value: function() {
      if (this[c2] == null)
        return;
      const e3 = this[c2].evaluate();
      this[t2.updateHandler](e3);
    } }, updated: { value: function(t3) {
      t3.has(r2) && (this[h2](), this[u2]()), s2.call(this, t3);
    } }, connectedCallback: { value: function() {
      a2.call(this), this.requestUpdate(r2, this[r2]);
    } }, disconnectedCallback: { value: function() {
      o2.call(this), this[l2] != null && (this[l2].dispose(), this[l2] = null);
    } } });
  };
}, Of = Object.freeze({ minimumRadius: 0, maximumRadius: 1 / 0, minimumPolarAngle: Math.PI / 8, maximumPolarAngle: Math.PI - Math.PI / 8, minimumAzimuthalAngle: -1 / 0, maximumAzimuthalAngle: 1 / 0, minimumFieldOfView: 10, maximumFieldOfView: 45, interactionPolicy: "always-allow", touchAction: "pan-y" }), Uf = Math.PI / 8, kf = 33, zf = 34, Bf = 37, Hf = 38, Vf = 39, Gf = 40, Wf = "user-interaction", jf = "none";
/* @license
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qf extends et {
  constructor(t2, e2) {
    super(), this.camera = t2, this.element = e2, this.sensitivity = 1, this._interactionEnabled = false, this._disableZoom = false, this.isUserChange = false, this.isUserPointing = false, this.spherical = new Yl(), this.goalSpherical = new Yl(), this.thetaDamper = new su(), this.phiDamper = new su(), this.radiusDamper = new su(), this.logFov = Math.log(Of.maximumFieldOfView), this.goalLogFov = this.logFov, this.fovDamper = new su(), this.touchMode = null, this.lastPointerPosition = { clientX: 0, clientY: 0 }, this.touchDecided = false, this.onMouseMove = (t3) => {
      this.handleSinglePointerMove(t3), t3.cancelable && t3.preventDefault();
    }, this.onTouchMove = (t3) => {
      this.touchMode !== null && (this.touchMode(t3), this.touchMode !== null && t3.cancelable && t3.preventDefault());
    }, this.touchModeZoom = (t3) => {
      const { targetTouches: e3 } = t3;
      if (this.lastTouches.length > 1 && e3.length > 1) {
        const t4 = 0.04 * (this.twoTouchDistance(this.lastTouches[0], this.lastTouches[1]) - this.twoTouchDistance(e3[0], e3[1])) / 10;
        this.userAdjustOrbit(0, 0, t4), this.lastTouches = e3;
      }
    }, this.touchModeRotate = (t3) => {
      const { targetTouches: e3 } = t3, { touchAction: n2 } = this._options;
      if (!this.touchDecided && n2 !== "none") {
        this.touchDecided = true;
        const { clientX: t4, clientY: i2 } = e3[0], r2 = Math.abs(t4 - this.lastPointerPosition.clientX), s2 = Math.abs(i2 - this.lastPointerPosition.clientY);
        if (n2 === "pan-y" && s2 > r2 || n2 === "pan-x" && r2 > s2)
          return void (this.touchMode = null);
      }
      this.handleSinglePointerMove(e3[0]), this.lastTouches = e3;
    }, this.onMouseDown = (t3) => {
      this.onPointerDown(() => {
        self.addEventListener("mousemove", this.onMouseMove), self.addEventListener("mouseup", this.onMouseUp, { once: true }), this.handleSinglePointerDown(t3);
      });
    }, this.onTouchStart = (t3) => {
      this.onPointerDown(() => {
        const { targetTouches: e3, changedTouches: n2, touches: i2 } = t3;
        e3.length === n2.length && (this.touchMode = null, this.touchDecided = false), e3.length === i2.length && this.onTouchChange(t3);
      });
    }, this.onMouseUp = (t3) => {
      self.removeEventListener("mousemove", this.onMouseMove), this.onPointerUp();
    }, this.onTouchEnd = (t3) => {
      t3.targetTouches.length > 0 && this.touchMode !== null && this.onTouchChange(t3), this.onPointerUp();
    }, this.onWheel = (t3) => {
      if (!this.canInteract)
        return;
      const e3 = t3.deltaY * (t3.deltaMode == 1 ? 18 : 1) * 0.04 / 30;
      this.userAdjustOrbit(0, 0, e3), t3.cancelable && t3.preventDefault();
    }, this.onKeyDown = (t3) => {
      let e3 = false;
      switch (t3.keyCode) {
        case kf:
          e3 = true, this.userAdjustOrbit(0, 0, 0.04);
          break;
        case zf:
          e3 = true, this.userAdjustOrbit(0, 0, -0.04);
          break;
        case Hf:
          e3 = true, this.userAdjustOrbit(0, -Uf, 0);
          break;
        case Gf:
          e3 = true, this.userAdjustOrbit(0, Uf, 0);
          break;
        case Bf:
          e3 = true, this.userAdjustOrbit(-Uf, 0, 0);
          break;
        case Vf:
          e3 = true, this.userAdjustOrbit(Uf, 0, 0);
      }
      e3 && t3.cancelable && t3.preventDefault();
    }, this._options = Object.assign({}, Of), this.setOrbit(0, Math.PI / 2, 1), this.setFieldOfView(100), this.jumpToGoal();
  }
  get interactionEnabled() {
    return this._interactionEnabled;
  }
  enableInteraction() {
    if (this._interactionEnabled === false) {
      const { element: t2 } = this;
      t2.addEventListener("mousedown", this.onMouseDown), this._disableZoom || t2.addEventListener("wheel", this.onWheel), t2.addEventListener("keydown", this.onKeyDown), t2.addEventListener("touchstart", this.onTouchStart, { passive: true }), t2.addEventListener("touchmove", this.onTouchMove, { passive: false }), t2.addEventListener("touchend", this.onTouchEnd), this.element.style.cursor = "grab", this._interactionEnabled = true, this.updateTouchActionStyle();
    }
  }
  disableInteraction() {
    if (this._interactionEnabled === true) {
      const { element: t2 } = this;
      self.removeEventListener("mousemove", this.onMouseMove), t2.removeEventListener("mousedown", this.onMouseDown), this._disableZoom || t2.removeEventListener("wheel", this.onWheel), t2.removeEventListener("keydown", this.onKeyDown), t2.removeEventListener("touchstart", this.onTouchStart), t2.removeEventListener("touchmove", this.onTouchMove), self.removeEventListener("mouseup", this.onMouseUp), t2.removeEventListener("touchend", this.onTouchEnd), t2.style.cursor = "", this.touchMode = null, this._interactionEnabled = false, this.updateTouchActionStyle();
    }
  }
  get options() {
    return this._options;
  }
  set disableZoom(t2) {
    this._disableZoom != t2 && (this._disableZoom = t2, t2 === true ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel), this.updateTouchActionStyle());
  }
  getCameraSpherical(t2 = new Yl()) {
    return t2.copy(this.spherical);
  }
  getFieldOfView() {
    return this.camera.fov;
  }
  applyOptions(t2) {
    Object.assign(this._options, t2), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov));
  }
  updateNearFar(t2, e2) {
    this.camera.near = Math.max(t2, e2 / 1e3), this.camera.far = e2, this.camera.updateProjectionMatrix();
  }
  updateAspect(t2) {
    this.camera.aspect = t2, this.camera.updateProjectionMatrix();
  }
  setOrbit(t2 = this.goalSpherical.theta, e2 = this.goalSpherical.phi, n2 = this.goalSpherical.radius) {
    const { minimumAzimuthalAngle: i2, maximumAzimuthalAngle: r2, minimumPolarAngle: s2, maximumPolarAngle: a2, minimumRadius: o2, maximumRadius: l2 } = this._options, { theta: c2, phi: h2, radius: u2 } = this.goalSpherical, d2 = eu(t2, i2, r2);
    isFinite(i2) || isFinite(r2) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d2) + d2);
    const p2 = eu(e2, s2, a2), m2 = eu(n2, o2, l2);
    return (d2 !== c2 || p2 !== h2 || m2 !== u2) && (this.goalSpherical.theta = d2, this.goalSpherical.phi = p2, this.goalSpherical.radius = m2, this.goalSpherical.makeSafe(), this.isUserChange = false, true);
  }
  setRadius(t2) {
    this.goalSpherical.radius = t2, this.setOrbit();
  }
  setFieldOfView(t2) {
    const { minimumFieldOfView: e2, maximumFieldOfView: n2 } = this._options;
    t2 = eu(t2, e2, n2), this.goalLogFov = Math.log(t2);
  }
  setDamperDecayTime(t2) {
    this.thetaDamper.setDecayTime(t2), this.phiDamper.setDecayTime(t2), this.radiusDamper.setDecayTime(t2), this.fovDamper.setDecayTime(t2);
  }
  adjustOrbit(t2, e2, n2) {
    const { theta: i2, phi: r2, radius: s2 } = this.goalSpherical, { minimumRadius: a2, maximumRadius: o2, minimumFieldOfView: l2, maximumFieldOfView: c2 } = this._options, h2 = this.spherical.theta - i2, u2 = Math.PI - 1e-3, d2 = i2 - eu(t2, -u2 - h2, u2 - h2), p2 = r2 - e2, m2 = n2 === 0 ? 0 : ((n2 > 0 ? o2 : a2) - s2) / (Math.log(n2 > 0 ? c2 : l2) - this.goalLogFov), f2 = s2 + n2 * (isFinite(m2) ? m2 : 2 * (o2 - a2));
    if (this.setOrbit(d2, p2, f2), n2 !== 0) {
      const t3 = this.goalLogFov + n2;
      this.setFieldOfView(Math.exp(t3));
    }
  }
  jumpToGoal() {
    this.update(0, 1e4);
  }
  update(t2, e2) {
    if (this.isStationary())
      return;
    const { maximumPolarAngle: n2, maximumRadius: i2 } = this._options, r2 = this.spherical.theta - this.goalSpherical.theta;
    Math.abs(r2) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(r2) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, e2, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e2, n2), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, e2, i2), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e2, 1), this.moveCamera();
  }
  updateTouchActionStyle() {
    const { style: t2 } = this.element;
    if (this._interactionEnabled) {
      const { touchAction: e2 } = this._options;
      this._disableZoom && e2 !== "none" ? t2.touchAction = "manipulation" : t2.touchAction = e2;
    } else
      t2.touchAction = "";
  }
  isStationary() {
    return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;
  }
  moveCamera() {
    this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new me(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix());
    const t2 = this.isUserChange ? Wf : jf;
    this.dispatchEvent({ type: "change", source: t2 });
  }
  get canInteract() {
    if (this._options.interactionPolicy == "allow-when-focused") {
      return this.element.getRootNode().activeElement === this.element;
    }
    return this._options.interactionPolicy === "always-allow";
  }
  userAdjustOrbit(t2, e2, n2) {
    this.adjustOrbit(t2 * this.sensitivity, e2 * this.sensitivity, n2), this.isUserChange = true, this.dispatchEvent({ type: "change", source: Wf });
  }
  wrapAngle(t2) {
    const e2 = (t2 + Math.PI) / (2 * Math.PI);
    return 2 * (e2 - Math.floor(e2)) * Math.PI - Math.PI;
  }
  pixelLengthToSphericalAngle(t2) {
    return 2 * Math.PI * t2 / this.element.clientHeight;
  }
  twoTouchDistance(t2, e2) {
    const { clientX: n2, clientY: i2 } = t2, { clientX: r2, clientY: s2 } = e2, a2 = r2 - n2, o2 = s2 - i2;
    return Math.sqrt(a2 * a2 + o2 * o2);
  }
  handleSinglePointerMove(t2) {
    const { clientX: e2, clientY: n2 } = t2, i2 = this.pixelLengthToSphericalAngle(e2 - this.lastPointerPosition.clientX), r2 = this.pixelLengthToSphericalAngle(n2 - this.lastPointerPosition.clientY);
    this.lastPointerPosition.clientX = e2, this.lastPointerPosition.clientY = n2, this.isUserPointing === false && (this.isUserPointing = true, this.dispatchEvent({ type: "pointer-change-start", pointer: Object.assign({}, t2) })), this.userAdjustOrbit(i2, r2, 0);
  }
  onPointerDown(t2) {
    this.canInteract && (this.isUserPointing = false, t2());
  }
  onTouchChange(t2) {
    const { targetTouches: e2 } = t2;
    switch (e2.length) {
      default:
      case 1:
        this.touchMode = this.touchModeRotate, this.handleSinglePointerDown(e2[0]);
        break;
      case 2:
        this.touchMode = this._disableZoom || this.touchDecided && this.touchMode === null ? null : this.touchModeZoom, this.touchDecided = true;
    }
    this.lastTouches = e2;
  }
  handleSinglePointerDown(t2) {
    this.lastPointerPosition.clientX = t2.clientX, this.lastPointerPosition.clientY = t2.clientY, this.element.style.cursor = "grabbing";
  }
  onPointerUp() {
    this.element.style.cursor = "grab", this.isUserPointing && this.dispatchEvent({ type: "pointer-change-end", pointer: Object.assign({}, this.lastPointerPosition) });
  }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Xf = (t2) => t2 < 0.5 ? 2 * t2 * t2 : (4 - 2 * t2) * t2 - 1, Yf = (t2, e2, n2 = Xf) => (i2) => t2 + (e2 - t2) * n2(i2), Zf = (t2, e2) => {
  const n2 = [], i2 = [];
  let r2 = t2;
  for (let t3 = 0; t3 < e2.length; ++t3) {
    const s2 = e2[t3], { value: a2, frames: o2 } = s2, l2 = s2.ease || Xf, c2 = Yf(r2, a2, l2);
    n2.push(c2), i2.push(o2), r2 = a2;
  }
  return ((t3, e3) => {
    const n3 = e3.reduce((t4, e4) => t4 + e4, 0), i3 = e3.map((t4) => t4 / n3);
    return (e4) => {
      let n4 = 0, r3 = 1 / 0, s2 = () => 0;
      for (let a2 = 0; a2 < i3.length && (r3 = i3[a2], s2 = t3[a2], !(e4 <= n4 + r3)); ++a2)
        n4 += r3;
      return s2((e4 - n4) / r3);
    };
  })(n2, i2);
};
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Jf = function(t2, e2, n2, i2) {
  for (var r2, s2 = arguments.length, a2 = s2 < 3 ? e2 : i2 === null ? i2 = Object.getOwnPropertyDescriptor(e2, n2) : i2, o2 = t2.length - 1; o2 >= 0; o2--)
    (r2 = t2[o2]) && (a2 = (s2 < 3 ? r2(a2) : s2 > 3 ? r2(e2, n2, a2) : r2(e2, n2)) || a2);
  return s2 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
};
const $f = Zf(0, [{ frames: 5, value: -1 }, { frames: 1, value: -1 }, { frames: 8, value: 1 }, { frames: 1, value: 1 }, { frames: 5, value: 0 }, { frames: 18, value: 0 }]), Kf = Zf(0, [{ frames: 1, value: 1 }, { frames: 5, value: 1 }, { frames: 1, value: 0 }, { frames: 6, value: 0 }]), Qf = ["front", "right", "back", "left"], tg = ["upper-", "", "lower-"], eg = "auto", ng = "when-focused", ig = "wiggle", rg = "always-allow", sg = "pan-y", ag = () => ({ basis: [gu(au(45, "deg"))], keywords: { auto: [null] } }), og = { basis: [gu(au(25, "deg"))], keywords: { auto: [null] } }, lg = () => ({ basis: [gu(au(45, "deg"))], keywords: { auto: [null] } }), cg = (() => {
  const t2 = ou("0deg 75deg 105%")[0].terms, e2 = yu(t2[0]), n2 = yu(t2[1]);
  return (t3) => {
    const i2 = t3[np].idealCameraDistance();
    return { basis: [e2, n2, au(i2, "m")], keywords: { auto: [null, null, au(105, "%")] } };
  };
})(), hg = (t2) => {
  const e2 = 1.1 * t2[np].boundingRadius;
  return { basis: [au(-1 / 0, "rad"), au(Math.PI / 8, "rad"), au(e2, "m")], keywords: { auto: [null, null, null] } };
}, ug = (t2) => {
  const e2 = cg(t2), n2 = new yf([], e2).evaluate()[2];
  return { basis: [au(1 / 0, "rad"), au(Math.PI - Math.PI / 8, "rad"), au(n2, "m")], keywords: { auto: [null, null, null] } };
}, dg = (t2) => {
  const e2 = t2[np].boundingBox.getCenter(new At());
  return { basis: [au(e2.x, "m"), au(e2.y, "m"), au(e2.z, "m")], keywords: { auto: [null, null, null] } };
}, pg = Math.PI / 2, mg = Math.PI / 3, fg = pg / 2, gg = 2 * Math.PI, vg = Symbol("controls"), yg = Symbol("promptElement"), xg = Symbol("promptAnimatedContainer"), bg = Symbol("deferInteractionPrompt"), wg = Symbol("updateAria"), _g = Symbol("updateCameraForRadius"), Mg = Symbol("onBlur"), Sg = Symbol("onFocus"), Tg = Symbol("onChange"), Eg = Symbol("onPointerChange"), Ag = Symbol("waitingToPromptUser"), Rg = Symbol("userHasInteracted"), Lg = Symbol("promptElementVisibleTime"), Cg = Symbol("lastPromptOffset"), Pg = Symbol("focusedTime"), Ig = Symbol("lastSpherical"), Dg = Symbol("jumpCamera"), Ng = Symbol("initialized"), Fg = Symbol("maintainThetaPhi"), Og = Symbol("syncCameraOrbit"), Ug = Symbol("syncFieldOfView"), kg = Symbol("syncCameraTarget"), zg = Symbol("syncMinCameraOrbit"), Bg = Symbol("syncMaxCameraOrbit"), Hg = Symbol("syncMinFieldOfView"), Vg = Symbol("syncMaxFieldOfView");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Gg, Wg;
const jg = Symbol("modelViewerStatusInstance"), qg = Symbol("updateStatus");
Gg = jg, Wg = qg;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Xg = function(t2, e2, n2, i2) {
  for (var r2, s2 = arguments.length, a2 = s2 < 3 ? e2 : i2 === null ? i2 = Object.getOwnPropertyDescriptor(e2, n2) : i2, o2 = t2.length - 1; o2 >= 0; o2--)
    (r2 = t2[o2]) && (a2 = (s2 < 3 ? r2(a2) : s2 > 3 ? r2(e2, n2, a2) : r2(e2, n2)) || a2);
  return s2 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
};
const Yg = "auto", Zg = "manual", Jg = "auto", $g = "eager", Kg = "interaction", Qg = new class extends et {
  constructor() {
    super(), this[Gg] = null, this.registeredInstanceStatuses = /* @__PURE__ */ new Map(), this.loadingPromises = [], this.statusElement = document.createElement("p"), this.statusUpdateInProgress = false, this[Wg] = tu(() => this.updateStatus(), 100);
    const { statusElement: t2 } = this, { style: e2 } = t2;
    t2.setAttribute("role", "status"), t2.classList.add("screen-reader-only"), e2.top = e2.left = "0", e2.pointerEvents = "none";
  }
  registerInstance(t2) {
    if (this.registeredInstanceStatuses.has(t2))
      return;
    let e2 = () => {
    };
    const n2 = t2.loaded === false && !!t2.src, i2 = new Promise((i3) => {
      if (!n2)
        return void i3();
      const r2 = () => {
        i3(), t2.removeEventListener("load", r2), t2.removeEventListener("error", r2);
      };
      t2.addEventListener("load", r2), t2.addEventListener("error", r2), e2 = r2;
    });
    this.registeredInstanceStatuses.set(t2, { onUnregistered: e2 }), this.loadingPromises.push(i2), this.modelViewerStatusInstance == null && (this.modelViewerStatusInstance = t2);
  }
  unregisterInstance(t2) {
    if (!this.registeredInstanceStatuses.has(t2))
      return;
    const e2 = this.registeredInstanceStatuses, n2 = e2.get(t2);
    e2.delete(t2), n2.onUnregistered(), this.modelViewerStatusInstance === t2 && (this.modelViewerStatusInstance = e2.size > 0 ? ((t3) => {
      if (t3.keys != null)
        return t3.keys().next().value || null;
      let e3 = null;
      try {
        t3.forEach((t4, n3, i2) => {
          throw e3 = n3, new Error();
        });
      } catch (t4) {
      }
      return e3;
    })(e2) : null);
  }
  get modelViewerStatusInstance() {
    return this[jg];
  }
  set modelViewerStatusInstance(t2) {
    if (this[jg] === t2)
      return;
    const { statusElement: e2 } = this;
    t2 != null && t2.shadowRoot != null ? t2.shadowRoot.appendChild(e2) : e2.parentNode != null && e2.parentNode.removeChild(e2), this[jg] = t2, this[qg]();
  }
  async updateStatus() {
    if (!this.statusUpdateInProgress && this.loadingPromises.length !== 0) {
      for (this.statusElement.textContent = "This page includes one or more 3D models that are loading", this.statusUpdateInProgress = true, this.dispatchEvent({ type: "initial-status-announced" }); this.loadingPromises.length; ) {
        const { loadingPromises: t2 } = this;
        this.loadingPromises = [], await Promise.all(t2);
      }
      this.statusElement.textContent = "All 3D models in the page have loaded", this.statusUpdateInProgress = false, this.dispatchEvent({ type: "finished-loading-announced" });
    }
  }
}(), tv = Symbol("defaultProgressBarElement"), ev = Symbol("defaultProgressMaskElement"), nv = Symbol("posterContainerElement"), iv = Symbol("defaultPosterElement"), rv = Symbol("posterDismissalSource"), sv = Symbol("hidePoster"), av = Symbol("modelIsRevealed"), ov = Symbol("updateProgressBar"), lv = Symbol("lastReportedProgress"), cv = Symbol("transitioned"), hv = Symbol("onTransitionEnd"), uv = Symbol("ariaLabelCallToAction"), dv = Symbol("onClick"), pv = Symbol("onKeydown"), mv = Symbol("onProgress");
class fv {
  constructor() {
    this.pluginCallbacks = [], this.register(function(t2) {
      return new Gv(t2);
    }), this.register(function(t2) {
      return new Wv(t2);
    }), this.register(function(t2) {
      return new jv(t2);
    }), this.register(function(t2) {
      return new Xv(t2);
    }), this.register(function(t2) {
      return new Yv(t2);
    }), this.register(function(t2) {
      return new qv(t2);
    });
  }
  register(t2) {
    return this.pluginCallbacks.indexOf(t2) === -1 && this.pluginCallbacks.push(t2), this;
  }
  unregister(t2) {
    return this.pluginCallbacks.indexOf(t2) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t2), 1), this;
  }
  parse(t2, e2, n2, i2) {
    typeof n2 == "object" && (console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."), i2 = n2);
    const r2 = new Vv(), s2 = [];
    for (let t3 = 0, e3 = this.pluginCallbacks.length; t3 < e3; t3++)
      s2.push(this.pluginCallbacks[t3](r2));
    r2.setPlugins(s2), r2.write(t2, e2, i2).catch(n2);
  }
  parseAsync(t2, e2) {
    const n2 = this;
    return new Promise(function(i2, r2) {
      n2.parse(t2, i2, r2, e2);
    });
  }
}
const gv = 0, vv = 1, yv = 2, xv = 3, bv = 4, wv = 5121, _v = 5123, Mv = 5126, Sv = 5125, Tv = 34962, Ev = 34963, Av = 9728, Rv = 9729, Lv = 9984, Cv = 9985, Pv = 9986, Iv = 9987, Dv = 33071, Nv = 33648, Fv = 10497, Ov = {};
Ov[1003] = Av, Ov[1004] = Lv, Ov[1005] = Pv, Ov[1006] = Rv, Ov[1007] = Cv, Ov[1008] = Iv, Ov[1001] = Dv, Ov[1e3] = Fv, Ov[1002] = Nv;
const Uv = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" };
function kv(t2, e2) {
  return t2.length === e2.length && t2.every(function(t3, n2) {
    return t3 === e2[n2];
  });
}
function zv(t2) {
  return 4 * Math.ceil(t2 / 4);
}
function Bv(t2, e2 = 0) {
  const n2 = zv(t2.byteLength);
  if (n2 !== t2.byteLength) {
    const i2 = new Uint8Array(n2);
    if (i2.set(new Uint8Array(t2)), e2 !== 0)
      for (let r2 = t2.byteLength; r2 < n2; r2++)
        i2[r2] = e2;
    return i2.buffer;
  }
  return t2;
}
let Hv = null;
class Vv {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: /* @__PURE__ */ new Map(), attributes: /* @__PURE__ */ new Map(), attributesNormalized: /* @__PURE__ */ new Map(), materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), images: /* @__PURE__ */ new Map() };
  }
  setPlugins(t2) {
    this.plugins = t2;
  }
  async write(t2, e2, n2) {
    this.options = Object.assign({}, { binary: false, trs: false, onlyVisible: true, truncateDrawRange: true, embedImages: true, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: false }, n2), this.options.animations.length > 0 && (this.options.trs = true), this.processInput(t2), await Promise.all(this.pending);
    const i2 = this, r2 = i2.buffers, s2 = i2.json;
    n2 = i2.options;
    const a2 = i2.extensionsUsed, o2 = new Blob(r2, { type: "application/octet-stream" }), l2 = Object.keys(a2);
    if (l2.length > 0 && (s2.extensionsUsed = l2), s2.buffers && s2.buffers.length > 0 && (s2.buffers[0].byteLength = o2.size), n2.binary === true) {
      const t3 = new window.FileReader();
      t3.readAsArrayBuffer(o2), t3.onloadend = function() {
        const n3 = Bv(t3.result), i3 = new DataView(new ArrayBuffer(8));
        i3.setUint32(0, n3.byteLength, true), i3.setUint32(4, 5130562, true);
        const r3 = Bv(function(t4) {
          if (window.TextEncoder !== void 0)
            return new TextEncoder().encode(t4).buffer;
          const e3 = new Uint8Array(new ArrayBuffer(t4.length));
          for (let n4 = 0, i4 = t4.length; n4 < i4; n4++) {
            const i5 = t4.charCodeAt(n4);
            e3[n4] = i5 > 255 ? 32 : i5;
          }
          return e3.buffer;
        }(JSON.stringify(s2)), 32), a3 = new DataView(new ArrayBuffer(8));
        a3.setUint32(0, r3.byteLength, true), a3.setUint32(4, 1313821514, true);
        const o3 = new ArrayBuffer(12), l3 = new DataView(o3);
        l3.setUint32(0, 1179937895, true), l3.setUint32(4, 2, true);
        const c2 = 12 + a3.byteLength + r3.byteLength + i3.byteLength + n3.byteLength;
        l3.setUint32(8, c2, true);
        const h2 = new Blob([o3, a3, r3, i3, n3], { type: "application/octet-stream" }), u2 = new window.FileReader();
        u2.readAsArrayBuffer(h2), u2.onloadend = function() {
          e2(u2.result);
        };
      };
    } else if (s2.buffers && s2.buffers.length > 0) {
      const t3 = new window.FileReader();
      t3.readAsDataURL(o2), t3.onloadend = function() {
        const n3 = t3.result;
        s2.buffers[0].uri = n3, e2(s2);
      };
    } else
      e2(s2);
  }
  serializeUserData(t2, e2) {
    if (Object.keys(t2.userData).length === 0)
      return;
    const n2 = this.options, i2 = this.extensionsUsed;
    try {
      const r2 = JSON.parse(JSON.stringify(t2.userData));
      if (n2.includeCustomExtensions && r2.gltfExtensions) {
        e2.extensions === void 0 && (e2.extensions = {});
        for (const t3 in r2.gltfExtensions)
          e2.extensions[t3] = r2.gltfExtensions[t3], i2[t3] = true;
        delete r2.gltfExtensions;
      }
      Object.keys(r2).length > 0 && (e2.extras = r2);
    } catch (e3) {
      console.warn("THREE.GLTFExporter: userData of '" + t2.name + "' won't be serialized because of JSON.stringify error - " + e3.message);
    }
  }
  getUID(t2) {
    return this.uids.has(t2) || this.uids.set(t2, this.uid++), this.uids.get(t2);
  }
  isNormalizedNormalAttribute(t2) {
    if (this.cache.attributesNormalized.has(t2))
      return false;
    const e2 = new At();
    for (let n2 = 0, i2 = t2.count; n2 < i2; n2++)
      if (Math.abs(e2.fromBufferAttribute(t2, n2).length() - 1) > 5e-4)
        return false;
    return true;
  }
  createNormalizedNormalAttribute(t2) {
    const e2 = this.cache;
    if (e2.attributesNormalized.has(t2))
      return e2.attributesNormalized.get(t2);
    const n2 = t2.clone(), i2 = new At();
    for (let t3 = 0, e3 = n2.count; t3 < e3; t3++)
      i2.fromBufferAttribute(n2, t3), i2.x === 0 && i2.y === 0 && i2.z === 0 ? i2.setX(1) : i2.normalize(), n2.setXYZ(t3, i2.x, i2.y, i2.z);
    return e2.attributesNormalized.set(t2, n2), n2;
  }
  applyTextureTransform(t2, e2) {
    let n2 = false;
    const i2 = {};
    e2.offset.x === 0 && e2.offset.y === 0 || (i2.offset = e2.offset.toArray(), n2 = true), e2.rotation !== 0 && (i2.rotation = e2.rotation, n2 = true), e2.repeat.x === 1 && e2.repeat.y === 1 || (i2.scale = e2.repeat.toArray(), n2 = true), n2 && (t2.extensions = t2.extensions || {}, t2.extensions.KHR_texture_transform = i2, this.extensionsUsed.KHR_texture_transform = true);
  }
  processBuffer(t2) {
    const e2 = this.json, n2 = this.buffers;
    return e2.buffers || (e2.buffers = [{ byteLength: 0 }]), n2.push(t2), 0;
  }
  processBufferView(t2, e2, n2, i2, r2) {
    const s2 = this.json;
    let a2;
    s2.bufferViews || (s2.bufferViews = []), a2 = e2 === wv ? 1 : e2 === _v ? 2 : 4;
    const o2 = zv(i2 * t2.itemSize * a2), l2 = new DataView(new ArrayBuffer(o2));
    let c2 = 0;
    for (let r3 = n2; r3 < n2 + i2; r3++)
      for (let n3 = 0; n3 < t2.itemSize; n3++) {
        let i3;
        t2.itemSize > 4 ? i3 = t2.array[r3 * t2.itemSize + n3] : n3 === 0 ? i3 = t2.getX(r3) : n3 === 1 ? i3 = t2.getY(r3) : n3 === 2 ? i3 = t2.getZ(r3) : n3 === 3 && (i3 = t2.getW(r3)), e2 === Mv ? l2.setFloat32(c2, i3, true) : e2 === Sv ? l2.setUint32(c2, i3, true) : e2 === _v ? l2.setUint16(c2, i3, true) : e2 === wv && l2.setUint8(c2, i3), c2 += a2;
      }
    const h2 = { buffer: this.processBuffer(l2.buffer), byteOffset: this.byteOffset, byteLength: o2 };
    r2 !== void 0 && (h2.target = r2), r2 === Tv && (h2.byteStride = t2.itemSize * a2), this.byteOffset += o2, s2.bufferViews.push(h2);
    return { id: s2.bufferViews.length - 1, byteLength: 0 };
  }
  processBufferViewImage(t2) {
    const e2 = this, n2 = e2.json;
    return n2.bufferViews || (n2.bufferViews = []), new Promise(function(i2) {
      const r2 = new window.FileReader();
      r2.readAsArrayBuffer(t2), r2.onloadend = function() {
        const t3 = Bv(r2.result), s2 = { buffer: e2.processBuffer(t3), byteOffset: e2.byteOffset, byteLength: t3.byteLength };
        e2.byteOffset += t3.byteLength, i2(n2.bufferViews.push(s2) - 1);
      };
    });
  }
  processAccessor(t2, e2, n2, i2) {
    const r2 = this.options, s2 = this.json;
    let a2;
    if (t2.array.constructor === Float32Array)
      a2 = Mv;
    else if (t2.array.constructor === Uint32Array)
      a2 = Sv;
    else if (t2.array.constructor === Uint16Array)
      a2 = _v;
    else {
      if (t2.array.constructor !== Uint8Array)
        throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
      a2 = wv;
    }
    if (n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = t2.count), r2.truncateDrawRange && e2 !== void 0 && e2.index === null) {
      const r3 = n2 + i2, s3 = e2.drawRange.count === 1 / 0 ? t2.count : e2.drawRange.start + e2.drawRange.count;
      n2 = Math.max(n2, e2.drawRange.start), (i2 = Math.min(r3, s3) - n2) < 0 && (i2 = 0);
    }
    if (i2 === 0)
      return null;
    const o2 = function(t3, e3, n3) {
      const i3 = { min: new Array(t3.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(t3.itemSize).fill(Number.NEGATIVE_INFINITY) };
      for (let r3 = e3; r3 < e3 + n3; r3++)
        for (let e4 = 0; e4 < t3.itemSize; e4++) {
          let n4;
          t3.itemSize > 4 ? n4 = t3.array[r3 * t3.itemSize + e4] : e4 === 0 ? n4 = t3.getX(r3) : e4 === 1 ? n4 = t3.getY(r3) : e4 === 2 ? n4 = t3.getZ(r3) : e4 === 3 && (n4 = t3.getW(r3)), i3.min[e4] = Math.min(i3.min[e4], n4), i3.max[e4] = Math.max(i3.max[e4], n4);
        }
      return i3;
    }(t2, n2, i2);
    let l2;
    e2 !== void 0 && (l2 = t2 === e2.index ? Ev : Tv);
    const c2 = this.processBufferView(t2, a2, n2, i2, l2), h2 = { bufferView: c2.id, byteOffset: c2.byteOffset, componentType: a2, count: i2, max: o2.max, min: o2.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }[t2.itemSize] };
    return t2.normalized === true && (h2.normalized = true), s2.accessors || (s2.accessors = []), s2.accessors.push(h2) - 1;
  }
  processImage(t2, e2, n2) {
    const i2 = this, r2 = i2.cache, s2 = i2.json, a2 = i2.options, o2 = i2.pending;
    r2.images.has(t2) || r2.images.set(t2, {});
    const l2 = r2.images.get(t2), c2 = e2 === 1023 ? "image/png" : "image/jpeg", h2 = c2 + ":flipY/" + n2.toString();
    if (l2[h2] !== void 0)
      return l2[h2];
    s2.images || (s2.images = []);
    const u2 = { mimeType: c2 };
    if (a2.embedImages) {
      const r3 = Hv = Hv || document.createElement("canvas");
      r3.width = Math.min(t2.width, a2.maxTextureSize), r3.height = Math.min(t2.height, a2.maxTextureSize);
      const s3 = r3.getContext("2d");
      if (n2 === true && (s3.translate(0, r3.height), s3.scale(1, -1)), typeof HTMLImageElement != "undefined" && t2 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t2 instanceof HTMLCanvasElement || typeof OffscreenCanvas != "undefined" && t2 instanceof OffscreenCanvas || typeof ImageBitmap != "undefined" && t2 instanceof ImageBitmap)
        s3.drawImage(t2, 0, 0, r3.width, r3.height);
      else {
        e2 !== 1023 && e2 !== 1022 && console.error("GLTFExporter: Only RGB and RGBA formats are supported."), (t2.width > a2.maxTextureSize || t2.height > a2.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", t2);
        const n3 = new Uint8ClampedArray(t2.height * t2.width * 4);
        if (e2 === 1023)
          for (let e3 = 0; e3 < n3.length; e3 += 4)
            n3[e3 + 0] = t2.data[e3 + 0], n3[e3 + 1] = t2.data[e3 + 1], n3[e3 + 2] = t2.data[e3 + 2], n3[e3 + 3] = t2.data[e3 + 3];
        else
          for (let e3 = 0, i3 = 0; e3 < n3.length; e3 += 4, i3 += 3)
            n3[e3 + 0] = t2.data[i3 + 0], n3[e3 + 1] = t2.data[i3 + 1], n3[e3 + 2] = t2.data[i3 + 2], n3[e3 + 3] = 255;
        s3.putImageData(new ImageData(n3, t2.width, t2.height), 0, 0);
      }
      a2.binary === true ? o2.push(new Promise(function(t3) {
        r3.toBlob(function(e3) {
          i2.processBufferViewImage(e3).then(function(e4) {
            u2.bufferView = e4, t3();
          });
        }, c2);
      })) : u2.uri = r3.toDataURL(c2);
    } else
      u2.uri = t2.src;
    const d2 = s2.images.push(u2) - 1;
    return l2[h2] = d2, d2;
  }
  processSampler(t2) {
    const e2 = this.json;
    e2.samplers || (e2.samplers = []);
    const n2 = { magFilter: Ov[t2.magFilter], minFilter: Ov[t2.minFilter], wrapS: Ov[t2.wrapS], wrapT: Ov[t2.wrapT] };
    return e2.samplers.push(n2) - 1;
  }
  processTexture(t2) {
    const e2 = this.cache, n2 = this.json;
    if (e2.textures.has(t2))
      return e2.textures.get(t2);
    n2.textures || (n2.textures = []);
    const i2 = { sampler: this.processSampler(t2), source: this.processImage(t2.image, t2.format, t2.flipY) };
    t2.name && (i2.name = t2.name), this._invokeAll(function(e3) {
      e3.writeTexture && e3.writeTexture(t2, i2);
    });
    const r2 = n2.textures.push(i2) - 1;
    return e2.textures.set(t2, r2), r2;
  }
  processMaterial(t2) {
    const e2 = this.cache, n2 = this.json;
    if (e2.materials.has(t2))
      return e2.materials.get(t2);
    if (t2.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    n2.materials || (n2.materials = []);
    const i2 = { pbrMetallicRoughness: {} };
    t2.isMeshStandardMaterial !== true && t2.isMeshBasicMaterial !== true && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const r2 = t2.color.toArray().concat([t2.opacity]);
    if (kv(r2, [1, 1, 1, 1]) || (i2.pbrMetallicRoughness.baseColorFactor = r2), t2.isMeshStandardMaterial ? (i2.pbrMetallicRoughness.metallicFactor = t2.metalness, i2.pbrMetallicRoughness.roughnessFactor = t2.roughness) : (i2.pbrMetallicRoughness.metallicFactor = 0.5, i2.pbrMetallicRoughness.roughnessFactor = 0.5), t2.metalnessMap || t2.roughnessMap)
      if (t2.metalnessMap === t2.roughnessMap) {
        const e3 = { index: this.processTexture(t2.metalnessMap) };
        this.applyTextureTransform(e3, t2.metalnessMap), i2.pbrMetallicRoughness.metallicRoughnessTexture = e3;
      } else
        console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");
    if (t2.map) {
      const e3 = { index: this.processTexture(t2.map) };
      this.applyTextureTransform(e3, t2.map), i2.pbrMetallicRoughness.baseColorTexture = e3;
    }
    if (t2.emissive) {
      const e3 = t2.emissive.clone().multiplyScalar(t2.emissiveIntensity), n3 = Math.max(e3.r, e3.g, e3.b);
      if (n3 > 1 && (e3.multiplyScalar(1 / n3), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), n3 > 0 && (i2.emissiveFactor = e3.toArray()), t2.emissiveMap) {
        const e4 = { index: this.processTexture(t2.emissiveMap) };
        this.applyTextureTransform(e4, t2.emissiveMap), i2.emissiveTexture = e4;
      }
    }
    if (t2.normalMap) {
      const e3 = { index: this.processTexture(t2.normalMap) };
      t2.normalScale && t2.normalScale.x !== 1 && (e3.scale = t2.normalScale.x), this.applyTextureTransform(e3, t2.normalMap), i2.normalTexture = e3;
    }
    if (t2.aoMap) {
      const e3 = { index: this.processTexture(t2.aoMap), texCoord: 1 };
      t2.aoMapIntensity !== 1 && (e3.strength = t2.aoMapIntensity), this.applyTextureTransform(e3, t2.aoMap), i2.occlusionTexture = e3;
    }
    t2.transparent ? i2.alphaMode = "BLEND" : t2.alphaTest > 0 && (i2.alphaMode = "MASK", i2.alphaCutoff = t2.alphaTest), t2.side === 2 && (i2.doubleSided = true), t2.name !== "" && (i2.name = t2.name), this.serializeUserData(t2, i2), this._invokeAll(function(e3) {
      e3.writeMaterial && e3.writeMaterial(t2, i2);
    });
    const s2 = n2.materials.push(i2) - 1;
    return e2.materials.set(t2, s2), s2;
  }
  processMesh(t2) {
    const e2 = this.cache, n2 = this.json, i2 = [t2.geometry.uuid];
    if (Array.isArray(t2.material))
      for (let e3 = 0, n3 = t2.material.length; e3 < n3; e3++)
        i2.push(t2.material[e3].uuid);
    else
      i2.push(t2.material.uuid);
    const r2 = i2.join(":");
    if (e2.meshes.has(r2))
      return e2.meshes.get(r2);
    const s2 = t2.geometry;
    let a2;
    if (a2 = t2.isLineSegments ? vv : t2.isLineLoop ? yv : t2.isLine ? xv : t2.isPoints ? gv : t2.material.wireframe ? vv : bv, s2.isBufferGeometry !== true)
      throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
    const o2 = {}, l2 = {}, c2 = [], h2 = [], u2 = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, d2 = s2.getAttribute("normal");
    d2 === void 0 || this.isNormalizedNormalAttribute(d2) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), s2.setAttribute("normal", this.createNormalizedNormalAttribute(d2)));
    let p2 = null;
    for (let t3 in s2.attributes) {
      if (t3.substr(0, 5) === "morph")
        continue;
      const n3 = s2.attributes[t3];
      t3 = u2[t3] || t3.toUpperCase();
      if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t3) || (t3 = "_" + t3), e2.attributes.has(this.getUID(n3))) {
        l2[t3] = e2.attributes.get(this.getUID(n3));
        continue;
      }
      p2 = null;
      const i3 = n3.array;
      t3 !== "JOINTS_0" || i3 instanceof Uint16Array || i3 instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), p2 = new Qe(new Uint16Array(i3), n3.itemSize, n3.normalized));
      const r3 = this.processAccessor(p2 || n3, s2);
      r3 !== null && (l2[t3] = r3, e2.attributes.set(this.getUID(n3), r3));
    }
    if (d2 !== void 0 && s2.setAttribute("normal", d2), Object.keys(l2).length === 0)
      return null;
    if (t2.morphTargetInfluences !== void 0 && t2.morphTargetInfluences.length > 0) {
      const n3 = [], i3 = [], r3 = {};
      if (t2.morphTargetDictionary !== void 0)
        for (const e3 in t2.morphTargetDictionary)
          r3[t2.morphTargetDictionary[e3]] = e3;
      for (let a3 = 0; a3 < t2.morphTargetInfluences.length; ++a3) {
        const o3 = {};
        let l3 = false;
        for (const t3 in s2.morphAttributes) {
          if (t3 !== "position" && t3 !== "normal") {
            l3 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l3 = true);
            continue;
          }
          const n4 = s2.morphAttributes[t3][a3], i4 = t3.toUpperCase(), r4 = s2.attributes[t3];
          if (e2.attributes.has(this.getUID(n4))) {
            o3[i4] = e2.attributes.get(this.getUID(n4));
            continue;
          }
          const c3 = n4.clone();
          if (!s2.morphTargetsRelative)
            for (let t4 = 0, e3 = n4.count; t4 < e3; t4++)
              c3.setXYZ(t4, n4.getX(t4) - r4.getX(t4), n4.getY(t4) - r4.getY(t4), n4.getZ(t4) - r4.getZ(t4));
          o3[i4] = this.processAccessor(c3, s2), e2.attributes.set(this.getUID(r4), o3[i4]);
        }
        h2.push(o3), n3.push(t2.morphTargetInfluences[a3]), t2.morphTargetDictionary !== void 0 && i3.push(r3[a3]);
      }
      o2.weights = n3, i3.length > 0 && (o2.extras = {}, o2.extras.targetNames = i3);
    }
    const m2 = Array.isArray(t2.material);
    if (m2 && s2.groups.length === 0)
      return null;
    const f2 = m2 ? t2.material : [t2.material], g2 = m2 ? s2.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let t3 = 0, n3 = g2.length; t3 < n3; t3++) {
      const n4 = { mode: a2, attributes: l2 };
      if (this.serializeUserData(s2, n4), h2.length > 0 && (n4.targets = h2), s2.index !== null) {
        let i4 = this.getUID(s2.index);
        g2[t3].start === void 0 && g2[t3].count === void 0 || (i4 += ":" + g2[t3].start + ":" + g2[t3].count), e2.attributes.has(i4) ? n4.indices = e2.attributes.get(i4) : (n4.indices = this.processAccessor(s2.index, s2, g2[t3].start, g2[t3].count), e2.attributes.set(i4, n4.indices)), n4.indices === null && delete n4.indices;
      }
      const i3 = this.processMaterial(f2[g2[t3].materialIndex]);
      i3 !== null && (n4.material = i3), c2.push(n4);
    }
    o2.primitives = c2, n2.meshes || (n2.meshes = []), this._invokeAll(function(e3) {
      e3.writeMesh && e3.writeMesh(t2, o2);
    });
    const v2 = n2.meshes.push(o2) - 1;
    return e2.meshes.set(r2, v2), v2;
  }
  processCamera(t2) {
    const e2 = this.json;
    e2.cameras || (e2.cameras = []);
    const n2 = t2.isOrthographicCamera, i2 = { type: n2 ? "orthographic" : "perspective" };
    return n2 ? i2.orthographic = { xmag: 2 * t2.right, ymag: 2 * t2.top, zfar: t2.far <= 0 ? 1e-3 : t2.far, znear: t2.near < 0 ? 0 : t2.near } : i2.perspective = { aspectRatio: t2.aspect, yfov: pt.degToRad(t2.fov), zfar: t2.far <= 0 ? 1e-3 : t2.far, znear: t2.near < 0 ? 0 : t2.near }, t2.name !== "" && (i2.name = t2.type), e2.cameras.push(i2) - 1;
  }
  processAnimation(t2, e2) {
    const n2 = this.json, i2 = this.nodeMap;
    n2.animations || (n2.animations = []);
    const r2 = (t2 = fv.Utils.mergeMorphTargetTracks(t2.clone(), e2)).tracks, s2 = [], a2 = [];
    for (let t3 = 0; t3 < r2.length; ++t3) {
      const n3 = r2[t3], o2 = Gl.parseTrackName(n3.name);
      let l2 = Gl.findNode(e2, o2.nodeName);
      const c2 = Uv[o2.propertyName];
      if (o2.objectName === "bones" && (l2 = l2.isSkinnedMesh === true ? l2.skeleton.getBoneByName(o2.objectIndex) : void 0), !l2 || !c2)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', n3.name), null;
      const h2 = 1;
      let u2, d2 = n3.values.length / n3.times.length;
      c2 === Uv.morphTargetInfluences && (d2 /= l2.morphTargetInfluences.length), n3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ? (u2 = "CUBICSPLINE", d2 /= 3) : u2 = n3.getInterpolation() === 2300 ? "STEP" : "LINEAR", a2.push({ input: this.processAccessor(new Qe(n3.times, h2)), output: this.processAccessor(new Qe(n3.values, d2)), interpolation: u2 }), s2.push({ sampler: a2.length - 1, target: { node: i2.get(l2), path: c2 } });
    }
    return n2.animations.push({ name: t2.name || "clip_" + n2.animations.length, samplers: a2, channels: s2 }), n2.animations.length - 1;
  }
  processSkin(t2) {
    const e2 = this.json, n2 = this.nodeMap, i2 = e2.nodes[n2.get(t2)], r2 = t2.skeleton;
    if (r2 === void 0)
      return null;
    const s2 = t2.skeleton.bones[0];
    if (s2 === void 0)
      return null;
    const a2 = [], o2 = new Float32Array(16 * r2.bones.length), l2 = new re();
    for (let e3 = 0; e3 < r2.bones.length; ++e3)
      a2.push(n2.get(r2.bones[e3])), l2.copy(r2.boneInverses[e3]), l2.multiply(t2.bindMatrix).toArray(o2, 16 * e3);
    e2.skins === void 0 && (e2.skins = []), e2.skins.push({ inverseBindMatrices: this.processAccessor(new Qe(o2, 16)), joints: a2, skeleton: n2.get(s2) });
    return i2.skin = e2.skins.length - 1;
  }
  processNode(t2) {
    const e2 = this.json, n2 = this.options, i2 = this.nodeMap;
    e2.nodes || (e2.nodes = []);
    const r2 = {};
    if (n2.trs) {
      const e3 = t2.quaternion.toArray(), n3 = t2.position.toArray(), i3 = t2.scale.toArray();
      kv(e3, [0, 0, 0, 1]) || (r2.rotation = e3), kv(n3, [0, 0, 0]) || (r2.translation = n3), kv(i3, [1, 1, 1]) || (r2.scale = i3);
    } else
      t2.matrixAutoUpdate && t2.updateMatrix(), kv(t2.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) === false && (r2.matrix = t2.matrix.elements);
    if (t2.name !== "" && (r2.name = String(t2.name)), this.serializeUserData(t2, r2), t2.isMesh || t2.isLine || t2.isPoints) {
      const e3 = this.processMesh(t2);
      e3 !== null && (r2.mesh = e3);
    } else
      t2.isCamera && (r2.camera = this.processCamera(t2));
    if (t2.isSkinnedMesh && this.skins.push(t2), t2.children.length > 0) {
      const e3 = [];
      for (let i3 = 0, r3 = t2.children.length; i3 < r3; i3++) {
        const r4 = t2.children[i3];
        if (r4.visible || n2.onlyVisible === false) {
          const t3 = this.processNode(r4);
          t3 !== null && e3.push(t3);
        }
      }
      e3.length > 0 && (r2.children = e3);
    }
    this._invokeAll(function(e3) {
      e3.writeNode && e3.writeNode(t2, r2);
    });
    const s2 = e2.nodes.push(r2) - 1;
    return i2.set(t2, s2), s2;
  }
  processScene(t2) {
    const e2 = this.json, n2 = this.options;
    e2.scenes || (e2.scenes = [], e2.scene = 0);
    const i2 = {};
    t2.name !== "" && (i2.name = t2.name), e2.scenes.push(i2);
    const r2 = [];
    for (let e3 = 0, i3 = t2.children.length; e3 < i3; e3++) {
      const i4 = t2.children[e3];
      if (i4.visible || n2.onlyVisible === false) {
        const t3 = this.processNode(i4);
        t3 !== null && r2.push(t3);
      }
    }
    r2.length > 0 && (i2.nodes = r2), this.serializeUserData(t2, i2);
  }
  processObjects(t2) {
    const e2 = new Bs();
    e2.name = "AuxScene";
    for (let n2 = 0; n2 < t2.length; n2++)
      e2.children.push(t2[n2]);
    this.processScene(e2);
  }
  processInput(t2) {
    const e2 = this.options;
    t2 = t2 instanceof Array ? t2 : [t2], this._invokeAll(function(e3) {
      e3.beforeParse && e3.beforeParse(t2);
    });
    const n2 = [];
    for (let e3 = 0; e3 < t2.length; e3++)
      t2[e3] instanceof Bs ? this.processScene(t2[e3]) : n2.push(t2[e3]);
    n2.length > 0 && this.processObjects(n2);
    for (let t3 = 0; t3 < this.skins.length; ++t3)
      this.processSkin(this.skins[t3]);
    for (let n3 = 0; n3 < e2.animations.length; ++n3)
      this.processAnimation(e2.animations[n3], t2[0]);
    this._invokeAll(function(e3) {
      e3.afterParse && e3.afterParse(t2);
    });
  }
  _invokeAll(t2) {
    for (let e2 = 0, n2 = this.plugins.length; e2 < n2; e2++)
      t2(this.plugins[e2]);
  }
}
class Gv {
  constructor(t2) {
    this.writer = t2, this.name = "KHR_lights_punctual";
  }
  writeNode(t2, e2) {
    if (!t2.isLight)
      return;
    if (!t2.isDirectionalLight && !t2.isPointLight && !t2.isSpotLight)
      return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", t2);
    const n2 = this.writer, i2 = n2.json, r2 = n2.extensionsUsed, s2 = {};
    t2.name && (s2.name = t2.name), s2.color = t2.color.toArray(), s2.intensity = t2.intensity, t2.isDirectionalLight ? s2.type = "directional" : t2.isPointLight ? (s2.type = "point", t2.distance > 0 && (s2.range = t2.distance)) : t2.isSpotLight && (s2.type = "spot", t2.distance > 0 && (s2.range = t2.distance), s2.spot = {}, s2.spot.innerConeAngle = (t2.penumbra - 1) * t2.angle * -1, s2.spot.outerConeAngle = t2.angle), t2.decay !== void 0 && t2.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !t2.target || t2.target.parent === t2 && t2.target.position.x === 0 && t2.target.position.y === 0 && t2.target.position.z === -1 || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), r2[this.name] || (i2.extensions = i2.extensions || {}, i2.extensions[this.name] = { lights: [] }, r2[this.name] = true);
    const a2 = i2.extensions[this.name].lights;
    a2.push(s2), e2.extensions = e2.extensions || {}, e2.extensions[this.name] = { light: a2.length - 1 };
  }
}
class Wv {
  constructor(t2) {
    this.writer = t2, this.name = "KHR_materials_unlit";
  }
  writeMaterial(t2, e2) {
    if (!t2.isMeshBasicMaterial)
      return;
    const n2 = this.writer.extensionsUsed;
    e2.extensions = e2.extensions || {}, e2.extensions[this.name] = {}, n2[this.name] = true, e2.pbrMetallicRoughness.metallicFactor = 0, e2.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}
class jv {
  constructor(t2) {
    this.writer = t2, this.name = "KHR_materials_pbrSpecularGlossiness";
  }
  writeMaterial(t2, e2) {
    if (!t2.isGLTFSpecularGlossinessMaterial)
      return;
    const n2 = this.writer, i2 = n2.extensionsUsed, r2 = {};
    e2.pbrMetallicRoughness.baseColorFactor && (r2.diffuseFactor = e2.pbrMetallicRoughness.baseColorFactor);
    const s2 = [1, 1, 1];
    if (t2.specular.toArray(s2, 0), r2.specularFactor = s2, r2.glossinessFactor = t2.glossiness, e2.pbrMetallicRoughness.baseColorTexture && (r2.diffuseTexture = e2.pbrMetallicRoughness.baseColorTexture), t2.specularMap) {
      const e3 = { index: n2.processTexture(t2.specularMap) };
      n2.applyTextureTransform(e3, t2.specularMap), r2.specularGlossinessTexture = e3;
    }
    e2.extensions = e2.extensions || {}, e2.extensions[this.name] = r2, i2[this.name] = true;
  }
}
class qv {
  constructor(t2) {
    this.writer = t2, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(t2, e2) {
    if (!t2.isMeshPhysicalMaterial)
      return;
    const n2 = this.writer, i2 = n2.extensionsUsed, r2 = {};
    if (r2.clearcoatFactor = t2.clearcoat, t2.clearcoatMap) {
      const e3 = { index: n2.processTexture(t2.clearcoatMap) };
      n2.applyTextureTransform(e3, t2.clearcoatMap), r2.clearcoatTexture = e3;
    }
    if (r2.clearcoatRoughnessFactor = t2.clearcoatRoughness, t2.clearcoatRoughnessMap) {
      const e3 = { index: n2.processTexture(t2.clearcoatRoughnessMap) };
      n2.applyTextureTransform(e3, t2.clearcoatRoughnessMap), r2.clearcoatRoughnessTexture = e3;
    }
    if (t2.clearcoatNormalMap) {
      const e3 = { index: n2.processTexture(t2.clearcoatNormalMap) };
      n2.applyTextureTransform(e3, t2.clearcoatNormalMap), r2.clearcoatNormalTexture = e3;
    }
    e2.extensions = e2.extensions || {}, e2.extensions[this.name] = r2, i2[this.name] = true;
  }
}
class Xv {
  constructor(t2) {
    this.writer = t2, this.name = "KHR_materials_transmission";
  }
  writeMaterial(t2, e2) {
    if (!t2.isMeshPhysicalMaterial || t2.transmission === 0)
      return;
    const n2 = this.writer, i2 = n2.extensionsUsed, r2 = {};
    if (r2.transmissionFactor = t2.transmission, t2.transmissionMap) {
      const e3 = { index: n2.processTexture(t2.transmissionMap) };
      n2.applyTextureTransform(e3, t2.transmissionMap), r2.transmissionTexture = e3;
    }
    e2.extensions = e2.extensions || {}, e2.extensions[this.name] = r2, i2[this.name] = true;
  }
}
class Yv {
  constructor(t2) {
    this.writer = t2, this.name = "KHR_materials_volume";
  }
  writeMaterial(t2, e2) {
    if (!t2.isMeshPhysicalMaterial || t2.transmission === 0)
      return;
    const n2 = this.writer, i2 = n2.extensionsUsed, r2 = {};
    if (r2.thicknessFactor = t2.thickness, t2.thicknessMap) {
      const e3 = { index: n2.processTexture(t2.thicknessMap) };
      n2.applyTextureTransform(e3, t2.thicknessMap), r2.thicknessTexture = e3;
    }
    r2.attenuationDistance = t2.attenuationDistance, r2.attenuationColor = t2.attenuationColor.toArray(), e2.extensions = e2.extensions || {}, e2.extensions[this.name] = r2, i2[this.name] = true;
  }
}
fv.Utils = { insertKeyframe: function(t2, e2) {
  const n2 = 1e-3, i2 = t2.getValueSize(), r2 = new t2.TimeBufferType(t2.times.length + 1), s2 = new t2.ValueBufferType(t2.values.length + i2), a2 = t2.createInterpolant(new t2.ValueBufferType(i2));
  let o2;
  if (t2.times.length === 0) {
    r2[0] = e2;
    for (let t3 = 0; t3 < i2; t3++)
      s2[t3] = 0;
    o2 = 0;
  } else if (e2 < t2.times[0]) {
    if (Math.abs(t2.times[0] - e2) < n2)
      return 0;
    r2[0] = e2, r2.set(t2.times, 1), s2.set(a2.evaluate(e2), 0), s2.set(t2.values, i2), o2 = 0;
  } else if (e2 > t2.times[t2.times.length - 1]) {
    if (Math.abs(t2.times[t2.times.length - 1] - e2) < n2)
      return t2.times.length - 1;
    r2[r2.length - 1] = e2, r2.set(t2.times, 0), s2.set(t2.values, 0), s2.set(a2.evaluate(e2), t2.values.length), o2 = r2.length - 1;
  } else
    for (let l2 = 0; l2 < t2.times.length; l2++) {
      if (Math.abs(t2.times[l2] - e2) < n2)
        return l2;
      if (t2.times[l2] < e2 && t2.times[l2 + 1] > e2) {
        r2.set(t2.times.slice(0, l2 + 1), 0), r2[l2 + 1] = e2, r2.set(t2.times.slice(l2 + 1), l2 + 2), s2.set(t2.values.slice(0, (l2 + 1) * i2), 0), s2.set(a2.evaluate(e2), (l2 + 1) * i2), s2.set(t2.values.slice((l2 + 1) * i2), (l2 + 2) * i2), o2 = l2 + 1;
        break;
      }
    }
  return t2.times = r2, t2.values = s2, o2;
}, mergeMorphTargetTracks: function(t2, e2) {
  const n2 = [], i2 = {}, r2 = t2.tracks;
  for (let t3 = 0; t3 < r2.length; ++t3) {
    let s2 = r2[t3];
    const a2 = Gl.parseTrackName(s2.name), o2 = Gl.findNode(e2, a2.nodeName);
    if (a2.propertyName !== "morphTargetInfluences" || a2.propertyIndex === void 0) {
      n2.push(s2);
      continue;
    }
    if (s2.createInterpolant !== s2.InterpolantFactoryMethodDiscrete && s2.createInterpolant !== s2.InterpolantFactoryMethodLinear) {
      if (s2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
        throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
      console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), s2 = s2.clone(), s2.setInterpolation(2301);
    }
    const l2 = o2.morphTargetInfluences.length, c2 = o2.morphTargetDictionary[a2.propertyIndex];
    if (c2 === void 0)
      throw new Error("THREE.GLTFExporter: Morph target name not found: " + a2.propertyIndex);
    let h2;
    if (i2[o2.uuid] === void 0) {
      h2 = s2.clone();
      const t4 = new h2.ValueBufferType(l2 * h2.times.length);
      for (let e3 = 0; e3 < h2.times.length; e3++)
        t4[e3 * l2 + c2] = h2.values[e3];
      h2.name = (a2.nodeName || "") + ".morphTargetInfluences", h2.values = t4, i2[o2.uuid] = h2, n2.push(h2);
      continue;
    }
    const u2 = s2.createInterpolant(new s2.ValueBufferType(1));
    h2 = i2[o2.uuid];
    for (let t4 = 0; t4 < h2.times.length; t4++)
      h2.values[t4 * l2 + c2] = u2.evaluate(h2.times[t4]);
    for (let t4 = 0; t4 < s2.times.length; t4++) {
      const e3 = this.insertKeyframe(h2, s2.times[t4]);
      h2.values[e3 * l2 + c2] = s2.values[t4];
    }
  }
  return t2.tracks = n2, t2;
} };
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Zv = (t2) => t2.material !== void 0 && t2.userData && t2.userData.variantMaterials && !!Array.from(t2.userData.variantMaterials.values()).filter((t3) => Jv(t3.material)), Jv = (t2) => t2 && t2.isMaterial && !Array.isArray(t2);
class $v {
  constructor(t2) {
    this.writer = t2, this.name = "KHR_materials_variants", this.variantNames = [];
  }
  beforeParse(t2) {
    const e2 = /* @__PURE__ */ new Set();
    for (const n2 of t2)
      n2.traverse((t3) => {
        if (!Zv(t3))
          return;
        const n3 = t3.userData.variantMaterials, i2 = t3.userData.variantData;
        for (const [t4, r2] of i2) {
          const i3 = n3.get(r2.index);
          Jv(i3.material) && e2.add(t4);
        }
      });
    e2.forEach((t3) => this.variantNames.push(t3));
  }
  writeMesh(t2, e2) {
    if (!Zv(t2))
      return;
    const n2 = t2.userData, i2 = n2.variantMaterials, r2 = n2.variantData, s2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Map(), o2 = Array.from(r2.values()).sort((t3, e3) => t3.index - e3.index);
    for (const [t3, e3] of o2.entries())
      a2.set(e3.index, t3);
    for (const t3 of r2.values()) {
      const e3 = i2.get(t3.index).material;
      if (!Jv(e3))
        continue;
      const n3 = this.writer.processMaterial(e3);
      s2.has(n3) || s2.set(n3, { material: n3, variants: [] }), s2.get(n3).variants.push(a2.get(t3.index));
    }
    const l2 = Array.from(s2.values()).map((t3) => t3.variants.sort((t4, e3) => t4 - e3) && t3).sort((t3, e3) => t3.material - e3.material);
    if (l2.length === 0)
      return;
    const c2 = Jv(n2.originalMaterial) ? this.writer.processMaterial(n2.originalMaterial) : -1;
    for (const t3 of e2.primitives)
      c2 >= 0 && (t3.material = c2), t3.extensions = t3.extensions || {}, t3.extensions[this.name] = { mappings: l2 };
  }
  afterParse() {
    if (this.variantNames.length === 0)
      return;
    const t2 = this.writer.json;
    t2.extensions = t2.extensions || {};
    const e2 = this.variantNames.map((t3) => ({ name: t3 }));
    t2.extensions[this.name] = { variants: e2 }, this.writer.extensionsUsed[this.name] = true;
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Kv = Symbol("correlatedObjects"), Qv = Symbol("sourceObject"), ty = Symbol("onUpdate");
class ey {
  constructor(t2, e2, n2 = null) {
    this[ty] = t2, this[Qv] = e2, this[Kv] = n2;
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ny = new cl(), iy = new Je(), ry = new Jn(2, 2);
let sy = 0;
const ay = Symbol("threeTexture");
class oy extends ey {
  get [ay]() {
    var t2;
    return console.assert(this[Kv] != null && this[Kv].size > 0, "Image correlated object is undefined"), (t2 = this[Kv]) === null || t2 === void 0 ? void 0 : t2.values().next().value;
  }
  constructor(t2, e2, n2) {
    super(t2, n2 = n2 != null ? n2 : { name: "adhoc_image", uri: e2 && e2.image && e2.image.src ? e2.image.src : "adhoc_image" + sy++ }, new Set(e2 ? [e2] : []));
  }
  get name() {
    return this[Qv].name || "";
  }
  get uri() {
    return this[Qv].uri;
  }
  get bufferView() {
    return this[Qv].bufferView;
  }
  get type() {
    return this.uri != null ? "external" : "embedded";
  }
  async setURI(t2) {
    this[Qv].uri = t2;
    const e2 = await new Promise((e3, n3) => {
      ny.load(t2, e3, void 0, n3);
    }), n2 = this[ay];
    n2.image = e2, n2.needsUpdate = true, this[ty]();
  }
  async createThumbnail(t2, e2) {
    const n2 = new Bs();
    iy.map = this[ay];
    const i2 = new Ln(ry, iy);
    n2.add(i2);
    const r2 = new ai(-1, 1, 1, -1, 0, 1), { threeRenderer: s2 } = Td.singleton, a2 = new St(t2, e2);
    s2.setRenderTarget(a2), s2.render(n2, r2), s2.setRenderTarget(null);
    const o2 = new Uint8Array(t2 * e2 * 4);
    s2.readRenderTargetPixels(a2, 0, 0, t2, e2, o2), kd.width = t2, kd.height = e2;
    const l2 = kd.getContext("2d"), c2 = l2.createImageData(t2, e2);
    return c2.data.set(o2), l2.putImageData(c2, 0, 0), new Promise(async (t3, e3) => {
      kd.toBlob((n3) => {
        if (!n3)
          return e3("Failed to capture thumbnail.");
        t3(URL.createObjectURL(n3));
      }, "image/png");
    });
  }
}
var ly, cy;
!function(t2) {
  t2[t2.Nearest = 9728] = "Nearest", t2[t2.Linear = 9729] = "Linear", t2[t2.NearestMipmapNearest = 9984] = "NearestMipmapNearest", t2[t2.LinearMipmapNearest = 9985] = "LinearMipmapNearest", t2[t2.NearestMipmapLinear = 9986] = "NearestMipmapLinear", t2[t2.LinearMipmapLinear = 9987] = "LinearMipmapLinear";
}(ly || (ly = {})), function(t2) {
  t2[t2.ClampToEdge = 33071] = "ClampToEdge", t2[t2.MirroredRepeat = 33648] = "MirroredRepeat", t2[t2.Repeat = 10497] = "Repeat";
}(cy || (cy = {}));
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hy = (() => {
  const t2 = [ly.Nearest, ly.Linear, ly.NearestMipmapNearest, ly.LinearMipmapLinear, ly.NearestMipmapLinear, ly.LinearMipmapLinear];
  return (e2) => t2.indexOf(e2) > -1;
})(), uy = (() => {
  const t2 = [ly.Nearest, ly.Linear];
  return (e2) => t2.indexOf(e2) > -1;
})(), dy = (() => {
  const t2 = [cy.ClampToEdge, cy.MirroredRepeat, cy.Repeat];
  return (e2) => t2.indexOf(e2) > -1;
})(), py = Symbol("threeTextures"), my = Symbol("setProperty"), fy = Symbol("sourceSampler");
class gy extends ey {
  get [py]() {
    return console.assert(this[Kv] != null && this[Kv].size > 0, "Sampler correlated object is undefined"), this[Kv];
  }
  get [fy]() {
    return console.assert(this[Qv] != null, "Sampler source is undefined"), this[Qv];
  }
  constructor(t2, e2, n2) {
    (n2 = n2 != null ? n2 : {}).minFilter == null && (n2.minFilter = e2 ? e2.minFilter : ly.LinearMipmapLinear), n2.magFilter == null && (n2.magFilter = e2 ? e2.magFilter : ly.Linear), n2.wrapS == null && (n2.wrapS = e2 ? e2.wrapS : cy.Repeat), n2.wrapT == null && (n2.wrapT = e2 ? e2.wrapT : cy.Repeat), super(t2, n2, new Set(e2 ? [e2] : []));
  }
  get name() {
    return this[Qv].name || "";
  }
  get minFilter() {
    return this[fy].minFilter;
  }
  get magFilter() {
    return this[fy].magFilter;
  }
  get wrapS() {
    return this[fy].wrapS;
  }
  get wrapT() {
    return this[fy].wrapT;
  }
  setMinFilter(t2) {
    this[my]("minFilter", t2);
  }
  setMagFilter(t2) {
    this[my]("magFilter", t2);
  }
  setWrapS(t2) {
    this[my]("wrapS", t2);
  }
  setWrapT(t2) {
    this[my]("wrapT", t2);
  }
  [my](t2, e2) {
    const n2 = this[fy];
    if (n2 != null) {
      if (((t3, e3) => {
        switch (t3) {
          case "minFilter":
            return hy(e3);
          case "magFilter":
            return uy(e3);
          case "wrapS":
          case "wrapT":
            return dy(e3);
          default:
            throw new Error(`Cannot configure property "${t3}" on Sampler`);
        }
      })(t2, e2)) {
        n2[t2] = e2;
        for (const n3 of this[py])
          n3[t2] = e2, n3.needsUpdate = true;
      }
      this[ty]();
    }
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vy = Symbol("image"), yy = Symbol("sampler");
class xy extends ey {
  constructor(t2, e2, n2 = null, i2 = null, r2 = null) {
    super(t2, n2 || {}, new Set(e2 ? [e2] : [])), this[yy] = new gy(t2, e2, i2), this[vy] = new oy(t2, e2, r2);
  }
  get name() {
    return this[Qv].name || "";
  }
  get sampler() {
    return this[yy];
  }
  get source() {
    return this[vy];
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var by;
const wy = Symbol("texture"), _y = Symbol("materials"), My = Symbol("usage");
var Sy;
!function(t2) {
  t2[t2.Base = 0] = "Base", t2[t2.MetallicRoughness = 1] = "MetallicRoughness", t2[t2.Normal = 2] = "Normal", t2[t2.Occlusion = 3] = "Occlusion", t2[t2.Emissive = 4] = "Emissive";
}(Sy || (Sy = {}));
class Ty {
  constructor(t2, e2, n2, i2, r2, s2) {
    if (this[by] = null, s2) {
      const e3 = r2.textures ? r2.textures[s2.index] : null, i3 = e3 && r2.samplers ? r2.samplers[e3.sampler] : null, a2 = e3 && r2.images ? r2.images[e3.source] : null;
      this[wy] = new xy(t2, n2, e3, i3, a2);
    }
    this.onUpdate = t2, this[_y] = i2, this[My] = e2;
  }
  get texture() {
    return this[wy];
  }
  setTexture(t2) {
    const e2 = t2 != null ? t2.source[ay] : null;
    let n2 = 3001;
    if (this[wy] = t2, this[_y])
      for (const t3 of this[_y]) {
        switch (this[My]) {
          case Sy.Base:
            t3.map = e2;
            break;
          case Sy.MetallicRoughness:
            n2 = 3e3, t3.metalnessMap = e2, t3.roughnessMap = e2;
            break;
          case Sy.Normal:
            n2 = 3e3, t3.normalMap = e2;
            break;
          case Sy.Occlusion:
            n2 = 3e3, t3.aoMap = e2;
            break;
          case Sy.Emissive:
            t3.emissiveMap = e2;
        }
        t3.needsUpdate = true;
      }
    e2 && (e2.encoding = n2), this.onUpdate();
  }
}
by = wy;
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ey = Symbol("threeMaterials"), Ay = Symbol("baseColorTexture"), Ry = Symbol("metallicRoughnessTexture");
class Ly extends ey {
  constructor(t2, e2, n2, i2) {
    super(t2, n2, i2), n2.baseColorFactor == null && (n2.baseColorFactor = [1, 1, 1, 1]), n2.roughnessFactor == null && (n2.roughnessFactor = 1), n2.metallicFactor == null && (n2.metallicFactor = 1);
    const { baseColorTexture: r2, metallicRoughnessTexture: s2 } = n2, { map: a2, metalnessMap: o2 } = i2.values().next().value;
    this[Ay] = new Ty(t2, Sy.Base, a2, i2, e2, r2 || null), this[Ry] = new Ty(t2, Sy.MetallicRoughness, o2, i2, e2, s2 || null);
  }
  get [Ey]() {
    return this[Kv];
  }
  get baseColorFactor() {
    return this[Qv].baseColorFactor;
  }
  get metallicFactor() {
    return this[Qv].metallicFactor;
  }
  get roughnessFactor() {
    return this[Qv].roughnessFactor;
  }
  get baseColorTexture() {
    return this[Ay];
  }
  get metallicRoughnessTexture() {
    return this[Ry];
  }
  setBaseColorFactor(t2) {
    for (const e2 of this[Ey])
      e2.color.fromArray(t2), e2.opacity = t2[3];
    this[Qv].baseColorFactor = t2, this[ty]();
  }
  setMetallicFactor(t2) {
    for (const e2 of this[Ey])
      e2.metalness = t2;
    this[Qv].metallicFactor = t2, this[ty]();
  }
  setRoughnessFactor(t2) {
    for (const e2 of this[Ey])
      e2.roughness = t2;
    this[Qv].roughnessFactor = t2, this[ty]();
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Cy;
const Py = Symbol("pbrMetallicRoughness"), Iy = Symbol("normalTexture"), Dy = Symbol("occlusionTexture"), Ny = Symbol("emissiveTexture"), Fy = Symbol("backingThreeMaterial"), Oy = Symbol("applyAlphaCutoff"), Uy = Symbol("lazyLoadGLTFInfo"), ky = Symbol("initialize"), zy = Symbol("getLoadedMaterial"), By = Symbol("ensureMaterialIsLoaded"), Hy = Symbol("gltfIndex"), Vy = Symbol("setActive"), Gy = Symbol("variantIndices"), Wy = Symbol("isActive"), jy = Symbol("variantSet"), qy = Symbol("modelVariants");
class Xy extends ey {
  constructor(t2, e2, n2, i2, r2, s2, a2, o2) {
    super(t2, n2, a2), this[Cy] = /* @__PURE__ */ new Set(), this[Hy] = i2, this[Wy] = r2, this[qy] = s2, o2 == null ? this[ky](e2) : this[Uy] = o2;
  }
  get [(Cy = jy, Fy)]() {
    return this[Kv].values().next().value;
  }
  [ky](t2) {
    const e2 = this[ty], n2 = this[Qv], i2 = this[Kv];
    n2.extensions && n2.extensions.KHR_materials_pbrSpecularGlossiness && console.warn(`Material ${n2.name} uses a deprecated extension
          "KHR_materials_pbrSpecularGlossiness", please use
          "pbrMetallicRoughness" instead. Specular Glossiness materials are
          currently supported for rendering, but not for our scene-graph API,
          nor for auto-generation of USDZ for Quick Look.`), n2.pbrMetallicRoughness == null && (n2.pbrMetallicRoughness = {}), this[Py] = new Ly(e2, t2, n2.pbrMetallicRoughness, i2), n2.emissiveFactor == null && (n2.emissiveFactor = [0, 0, 0]), n2.doubleSided == null && (n2.doubleSided = false), n2.alphaMode == null && (n2.alphaMode = "OPAQUE"), n2.alphaCutoff == null && (n2.alphaCutoff = 0.5);
    const { normalTexture: r2, occlusionTexture: s2, emissiveTexture: a2 } = n2, { normalMap: o2, aoMap: l2, emissiveMap: c2 } = i2.values().next().value;
    this[Iy] = new Ty(e2, Sy.Normal, o2, i2, t2, r2 || null), this[Dy] = new Ty(e2, Sy.Occlusion, l2, i2, t2, s2 || null), this[Ny] = new Ty(e2, Sy.Emissive, c2, i2, t2, a2 || null);
  }
  async [zy]() {
    if (this[Uy] != null) {
      const { set: t2, material: e2 } = await this[Uy].doLazyLoad();
      return this[Kv] = t2, this[ky](this[Uy].gltf), this[Uy] = void 0, this.ensureLoaded = async () => {
      }, e2;
    }
    return this[Kv].values().next().value;
  }
  [By]() {
    if (this[Uy] != null)
      throw new Error(`Material "${this.name}" has not been loaded, call 'await
    myMaterial.ensureLoaded()' before using an unloaded material.`);
  }
  async ensureLoaded() {
    await this[zy]();
  }
  get isLoaded() {
    return this[Uy] == null;
  }
  get isActive() {
    return this[Wy];
  }
  [Vy](t2) {
    this[Wy] = t2;
  }
  get name() {
    return this[Qv].name;
  }
  set name(t2) {
    const e2 = this[Qv];
    if (e2 != null && (e2.name = t2), this[Kv] != null)
      for (const e3 of this[Kv])
        e3.name = t2;
  }
  get pbrMetallicRoughness() {
    return this[By](), this[Py];
  }
  get normalTexture() {
    return this[By](), this[Iy];
  }
  get occlusionTexture() {
    return this[By](), this[Dy];
  }
  get emissiveTexture() {
    return this[By](), this[Ny];
  }
  get emissiveFactor() {
    return this[By](), this[Qv].emissiveFactor;
  }
  get index() {
    return this[Hy];
  }
  [Gy]() {
    return this[jy];
  }
  hasVariant(t2) {
    const e2 = this[qy].get(t2);
    return e2 != null && this[jy].has(e2.index);
  }
  setEmissiveFactor(t2) {
    this[By]();
    for (const e2 of this[Kv])
      e2.emissive.fromArray(t2);
    this[Qv].emissiveFactor = t2, this[ty]();
  }
  [Oy]() {
    this[By]();
    const t2 = this[Qv];
    for (const e2 of this[Kv])
      this[Qv].alphaMode === "MASK" ? e2.alphaTest = t2.alphaCutoff : e2.alphaTest = void 0, e2.needsUpdate = true;
  }
  setAlphaCutoff(t2) {
    this[By](), this[Qv].alphaCutoff = t2, this[Oy](), this[ty]();
  }
  getAlphaCutoff() {
    return this[By](), this[Qv].alphaCutoff;
  }
  setDoubleSided(t2) {
    this[By]();
    for (const e2 of this[Kv])
      e2.side = t2 ? 2 : 0, e2.needsUpdate = true;
    this[Qv].doubleSided = t2, this[ty]();
  }
  getDoubleSided() {
    return this[By](), this[Qv].doubleSided;
  }
  setAlphaMode(t2) {
    this[By]();
    const e2 = (t3, e3) => {
      t3.transparent = e3, t3.depthWrite = !e3;
    };
    this[Qv].alphaMode = t2;
    for (const n2 of this[Kv])
      e2(n2, t2 !== "OPAQUE"), this[Oy](), n2.needsUpdate = true;
    this[ty]();
  }
  getAlphaMode() {
    return this[By](), this[Qv].alphaMode;
  }
}
var Yy, Zy, Jy;
const $y = Symbol("materials"), Ky = Symbol("variantToMaterialMap"), Qy = Symbol("modelVariants"), tx = Symbol("mesh"), ex = Symbol("children"), nx = Symbol("initialMaterialIdx"), ix = Symbol("activeMaterialIdx");
class rx {
  constructor(t2) {
    this.name = "", this[Yy] = new Array(), this.name = t2;
  }
}
Yy = ex;
class sx extends rx {
  constructor(t2, e2, n2, i2) {
    super(t2.name), this[Zy] = /* @__PURE__ */ new Map(), this[Jy] = /* @__PURE__ */ new Map(), this[tx] = t2;
    const { gltf: r2, threeGLTF: s2, threeObjectMap: a2 } = i2;
    this[Qy] = n2, this.mesh.userData.variantData = n2;
    const o2 = a2.get(t2.material);
    o2.materials != null ? this[nx] = this[ix] = o2.materials : console.error(`Primitive (${t2.name}) missing initial material reference.`);
    const l2 = t2.userData.associations || {};
    if (l2.meshes == null)
      return void console.error("Mesh is missing primitive index association");
    const c2 = ((r2.meshes || [])[l2.meshes].primitives || [])[l2.primitives];
    if (c2 != null) {
      if (c2.material != null)
        this[$y].set(c2.material, e2[c2.material]);
      else {
        const t3 = e2.findIndex((t4) => t4.name === "Default");
        t3 >= 0 ? this[$y].set(t3, e2[t3]) : console.warn("gltfPrimitive has no material!");
      }
      if (c2.extensions && c2.extensions.KHR_materials_variants) {
        const t3 = c2.extensions.KHR_materials_variants, i3 = s2.parser.json.extensions.KHR_materials_variants.variants;
        for (const r3 of t3.mappings) {
          const t4 = e2[r3.material];
          this[$y].set(r3.material, t4);
          for (const e3 of r3.variants) {
            const { name: r4 } = i3[e3];
            this[Ky].set(e3, t4), t4[Gy]().add(e3), n2.has(r4) || n2.set(r4, { name: r4, index: e3 });
          }
        }
      }
    } else
      console.error("Mesh primitive definition is missing.");
  }
  get mesh() {
    return this[tx];
  }
  async setActiveMaterial(t2) {
    const e2 = this[$y].get(t2);
    return e2 != null && (this.mesh.material = await e2[zy](), this[ix] = t2), this.mesh.material;
  }
  getActiveMaterial() {
    return this[$y].get(this[ix]);
  }
  getMaterial(t2) {
    return this[$y].get(t2);
  }
  async enableVariant(t2) {
    if (t2 == null)
      return this.setActiveMaterial(this[nx]);
    if (this[Ky] != null && this[Qy].has(t2)) {
      const e2 = this[Qy].get(t2);
      return this.enableVariantHelper(e2.index);
    }
    return null;
  }
  async enableVariantHelper(t2) {
    if (this[Ky] != null && t2 != null) {
      const e2 = this[Ky].get(t2);
      if (e2 != null)
        return this.setActiveMaterial(e2.index);
    }
    return null;
  }
  async instantiateVariants() {
    if (this[Ky] != null)
      for (const t2 of this[Ky].keys()) {
        if (this.mesh.userData.variantMaterials.get(t2).material != null)
          continue;
        const e2 = await this.enableVariantHelper(t2);
        e2 != null && (this.mesh.userData.variantMaterials.get(t2).material = e2);
      }
  }
  get variantInfo() {
    return this[Ky];
  }
  addVariant(t2, e2) {
    if (!this.ensureVariantIsUnused(e2))
      return false;
    this[Qy].has(e2) || this[Qy].set(e2, { name: e2, index: this[Qy].size });
    const n2 = this[Qy].get(e2).index;
    return t2[Gy]().add(n2), this[Ky].set(n2, t2), this[$y].set(t2.index, t2), this.updateVariantUserData(n2, t2), true;
  }
  deleteVariant(t2) {
    if (this.variantInfo.has(t2)) {
      this.variantInfo.delete(t2);
      const e2 = this.mesh.userData.variantMaterials;
      e2 != null && e2.delete(t2);
    }
  }
  updateVariantUserData(t2, e2) {
    e2[Gy]().add(t2), this.mesh.userData.variantData = this[Qy], this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || /* @__PURE__ */ new Map();
    this.mesh.userData.variantMaterials.set(t2, { material: e2[Kv].values().next().value, gltfMaterialIndex: e2.index });
  }
  ensureVariantIsUnused(t2) {
    const e2 = this[Qy].get(t2);
    return e2 == null || !this.variantInfo.has(e2.index) || (console.warn(`Primitive cannot add variant '${t2}' for this material, it already exists.`), false);
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ax, ox, lx, cx, hx, ux;
Zy = $y, Jy = Ky;
const dx = Symbol("materials"), px = Symbol("hierarchy"), mx = Symbol("roots"), fx = Symbol("primitives"), gx = Symbol("correlatedSceneGraph"), vx = Symbol("prepareVariantsForExport"), yx = Symbol("switchVariant"), xx = Symbol("threeScene"), bx = Symbol("materialsFromPoint"), wx = Symbol("materialFromPoint"), _x = Symbol("variantData"), Mx = Symbol("availableVariants"), Sx = Symbol("modelOnUpdate"), Tx = Symbol("cloneMaterial");
class Ex {
  constructor(t2, e2, n2, i2) {
    this.gltf = t2, this.gltfElementMap = e2, this.mapKey = n2, this.doLazyLoad = i2;
  }
}
class Ax {
  constructor(t2, e2 = () => {
  }) {
    this[ax] = new Array(), this[ox] = new Array(), this[lx] = new Array(), this[cx] = new Array(), this[hx] = () => {
    }, this[ux] = /* @__PURE__ */ new Map(), this[Sx] = e2, this[gx] = t2;
    const { gltf: n2, threeGLTF: i2, gltfElementMap: r2 } = t2;
    this[xx] = i2.scene;
    for (const [t3, s3] of n2.materials.entries()) {
      const a3 = r2.get(s3);
      if (a3 != null)
        this[dx].push(new Xy(e2, n2, s3, t3, true, this[_x], a3));
      else {
        const s4 = (n2.materials || [])[t3], o2 = t3, l2 = async () => {
          const t4 = await i2.parser.getDependency("material", o2), e3 = /* @__PURE__ */ new Set();
          return r2.set(s4, e3), e3.add(t4), { set: e3, material: t4 };
        };
        this[dx].push(new Xy(e2, n2, s4, t3, false, this[_x], a3, new Ex(n2, r2, s4, l2)));
      }
    }
    const s2 = /* @__PURE__ */ new Map(), a2 = new Array();
    for (const t3 of i2.scene.children)
      a2.push(t3);
    for (; a2.length > 0; ) {
      const e3 = a2.pop();
      let n3 = null;
      e3 instanceof Ln ? (n3 = new sx(e3, this.materials, this[_x], t2), this[fx].push(n3)) : n3 = new rx(e3.name);
      const i3 = s2.get(e3);
      i3 != null ? i3[ex].push(n3) : this[mx].push(n3), this[px].push(n3);
      for (const t3 of e3.children)
        a2.push(t3), s2.set(e3, n3);
    }
  }
  get materials() {
    return this[dx];
  }
  [(ax = dx, ox = px, lx = mx, cx = fx, hx = Sx, ux = _x, Mx)]() {
    const t2 = Array.from(this[_x].values());
    return t2.sort((t3, e2) => t3.index - e2.index), t2.map((t3) => t3.name);
  }
  getMaterialByName(t2) {
    const e2 = this[dx].filter((e3) => e3.name === t2);
    return e2.length > 0 ? e2[0] : null;
  }
  [bx](t2) {
    return t2.intersectObject(this[xx], true).map((t3) => {
      const e2 = this[px].find((e3) => {
        if (e3 instanceof sx) {
          if (e3.mesh === t3.object)
            return true;
        }
        return false;
      });
      return e2 != null ? e2.getActiveMaterial() : null;
    });
  }
  [wx](t2) {
    const e2 = this[bx](t2);
    return e2.length > 0 ? e2[0] : null;
  }
  async [yx](t2) {
    for (const e2 of this[fx])
      await e2.enableVariant(t2);
    for (const t3 of this.materials)
      t3[Vy](false);
    for (const t3 of this[fx])
      this.materials[t3.getActiveMaterial().index][Vy](true);
  }
  async [vx]() {
    const t2 = new Array();
    for (const e2 of this[fx])
      t2.push(e2.instantiateVariants());
    await Promise.all(t2);
  }
  [Tx](t2, e2) {
    const n2 = this.materials[t2];
    n2.isLoaded || console.error("Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.");
    const i2 = n2[Kv], r2 = JSON.parse(JSON.stringify(n2[Qv]));
    r2.name = e2;
    this[gx].gltf.materials.push(r2);
    const s2 = /* @__PURE__ */ new Set();
    for (const [t3, n3] of i2.entries()) {
      const r3 = n3.clone();
      r3.name = e2 + (i2.size > 1 ? "_inst" + t3 : ""), s2.add(r3);
    }
    const a2 = new Xy(this[Sx], this[gx].gltf, r2, this[dx].length, false, this[_x], s2);
    return this[dx].push(a2), a2;
  }
  createMaterialInstanceForVariant(t2, e2, n2, i2 = true) {
    let r2 = null;
    for (const i3 of this[fx]) {
      const s2 = this[_x].get(n2);
      s2 != null && i3.variantInfo.has(s2.index) || i3.getMaterial(t2) != null && (this.hasVariant(n2) || this.createVariant(n2), r2 == null && (r2 = this[Tx](t2, e2)), i3.addVariant(r2, n2));
    }
    if (i2 && r2 != null) {
      r2[Vy](true), this.materials[t2][Vy](false);
      for (const t3 of this[fx])
        t3.enableVariant(n2);
    }
    return r2;
  }
  createVariant(t2) {
    this[_x].has(t2) ? console.warn(`Variant '${t2}'' already exists`) : this[_x].set(t2, { name: t2, index: this[_x].size });
  }
  hasVariant(t2) {
    return this[_x].has(t2);
  }
  setMaterialToVariant(t2, e2) {
    if (this[Mx]().find((t3) => t3 === e2) != null)
      if (t2 < 0 || t2 >= this.materials.length)
        console.error("setMaterialToVariant(): materialIndex is out of bounds.");
      else
        for (const n2 of this[fx]) {
          const i2 = n2.getMaterial(t2);
          i2 != null && n2.addVariant(i2, e2);
        }
    else
      console.warn(`Can't add material to '${e2}', the variant does not exist.'`);
  }
  updateVariantName(t2, e2) {
    const n2 = this[_x].get(t2);
    n2 != null && (n2.name = e2, this[_x].set(e2, n2), this[_x].delete(t2));
  }
  deleteVariant(t2) {
    const e2 = this[_x].get(t2);
    if (e2 != null) {
      for (const n2 of this.materials)
        n2.hasVariant(t2) && n2[jy].delete(e2.index);
      for (const t3 of this[fx])
        t3.deleteVariant(e2.index);
      this[_x].delete(t2);
    }
  }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Rx = function(t2, e2, n2, i2) {
  for (var r2, s2 = arguments.length, a2 = s2 < 3 ? e2 : i2 === null ? i2 = Object.getOwnPropertyDescriptor(e2, n2) : i2, o2 = t2.length - 1; o2 >= 0; o2--)
    (r2 = t2[o2]) && (a2 = (s2 < 3 ? r2(a2) : s2 > 3 ? r2(e2, n2, a2) : r2(e2, n2)) || a2);
  return s2 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
};
const Lx = Symbol("currentGLTF"), Cx = Symbol("model"), Px = Symbol("getOnUpdateMethod"), Ix = Symbol("textureLoader"), Dx = Symbol("originalGltfJson");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Nx = function(t2, e2, n2, i2) {
  for (var r2, s2 = arguments.length, a2 = s2 < 3 ? e2 : i2 === null ? i2 = Object.getOwnPropertyDescriptor(e2, n2) : i2, o2 = t2.length - 1; o2 >= 0; o2--)
    (r2 = t2[o2]) && (a2 = (s2 < 3 ? r2(a2) : s2 > 3 ? r2(e2, n2, a2) : r2(e2, n2)) || a2);
  return s2 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
};
const Fx = Math.PI / 32, Ox = { basis: [gu(au(Fx, "rad"))], keywords: { auto: [null] } }, Ux = Symbol("autoRotateStartTime"), kx = Symbol("radiansPerSecond"), zx = Symbol("syncRotationRate"), Bx = Symbol("onCameraChange"), Hx = ((t2) => {
  var e2, n2, i2;
  class r2 extends t2 {
    constructor() {
      super(...arguments), this[e2] = /* @__PURE__ */ new Map(), this[n2] = (t3) => {
        t3.forEach((t4) => {
          t4 instanceof MutationRecord && t4.type !== "childList" || (t4.addedNodes.forEach((t5) => {
            this[Sp](t5);
          }), t4.removedNodes.forEach((t5) => {
            this[Tp](t5);
          }), this[ip]());
        });
      }, this[i2] = new MutationObserver(this[_p]);
    }
    connectedCallback() {
      super.connectedCallback();
      for (let t4 = 0; t4 < this.children.length; ++t4)
        this[Sp](this.children[t4]);
      const { ShadyDOM: t3 } = self;
      t3 == null ? this[Mp].observe(this, { childList: true }) : this[Mp] = t3.observeChildren(this, this[_p]);
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      const { ShadyDOM: t3 } = self;
      t3 == null ? this[Mp].disconnect() : t3.unobserveChildren(this[Mp]);
    }
    [(e2 = wp, n2 = _p, i2 = Mp, rp)](t3, e3) {
      super[rp](t3, e3);
      const n3 = this[np], { annotationRenderer: i3 } = n3, r3 = n3.getCamera();
      n3.shouldRender() && (n3.updateHotspots(r3.position), i3.domElement.style.display = "", i3.render(n3, r3));
    }
    updateHotspot(t3) {
      const e3 = this[wp].get(t3.name);
      e3 != null && (e3.updatePosition(t3.position), e3.updateNormal(t3.normal), this[ip]());
    }
    positionAndNormalFromPoint(t3, e3) {
      const n3 = this[np], i3 = n3.getNDC(t3, e3), r3 = n3.positionAndNormalFromPoint(i3);
      if (r3 == null)
        return null;
      Ep.copy(n3.target.matrixWorld).invert();
      const s2 = mp(r3.position.applyMatrix4(Ep));
      Ap.getNormalMatrix(Ep);
      const a2 = mp(r3.normal.applyNormalMatrix(Ap));
      let o2 = null;
      return r3.uv != null && (o2 = fp(r3.uv)), { position: s2, normal: a2, uv: o2 };
    }
    [Sp](t3) {
      if (!(t3 instanceof HTMLElement && t3.slot.indexOf("hotspot") === 0))
        return;
      let e3 = this[wp].get(t3.slot);
      e3 != null ? e3.increment() : (e3 = new xu({ name: t3.slot, position: t3.dataset.position, normal: t3.dataset.normal }), this[wp].set(t3.slot, e3), this[np].addHotspot(e3)), this[np].queueRender();
    }
    [Tp](t3) {
      if (!(t3 instanceof HTMLElement))
        return;
      const e3 = this[wp].get(t3.slot);
      e3 && (e3.decrement() && (this[np].removeHotspot(e3), this[wp].delete(t3.slot)), this[np].queueRender());
    }
  }
  return r2;
})(((t2) => {
  var e2, n2, i2, r2;
  class s2 extends t2 {
    constructor() {
      super(...arguments), this[e2] = void 0, this[n2] = null, this[i2] = new dl(), this[r2] = null, this.variantName = null, this.orientation = "0 0 0", this.scale = "1 1 1";
    }
    get model() {
      return this[Cx];
    }
    get availableVariants() {
      return this.model ? this.model[Mx]() : [];
    }
    get originalGltfJson() {
      return this[Dx];
    }
    [(e2 = Cx, n2 = Lx, i2 = Ix, r2 = Dx, Px)]() {
      return () => {
        this[ip]();
      };
    }
    async createTexture(t3, e3 = "image/png") {
      const n3 = this[Lx], i3 = await new Promise((e4) => this[Ix].load(t3, e4));
      return n3 && i3 ? (i3.encoding = 3001, i3.wrapS = 1e3, i3.wrapT = 1e3, i3.flipY = false, e3 === "image/jpeg" && (i3.format = 1022), new xy(this[Px](), i3)) : null;
    }
    async updated(t3) {
      if (super.updated(t3), t3.has("variantName")) {
        const t4 = this[Lx], { variantName: e3 } = this;
        t4 != null && (await this[Cx][yx](e3), this[ip](), this.dispatchEvent(new CustomEvent("variant-applied")));
      }
      if (t3.has("orientation") || t3.has("scale")) {
        const { modelContainer: t4 } = this[np], e3 = ou(this.orientation)[0].terms, n3 = yu(e3[0]).number, i3 = yu(e3[1]).number, r3 = yu(e3[2]).number;
        t4.quaternion.setFromEuler(new me(i3, r3, n3, "YXZ"));
        const s3 = ou(this.scale)[0].terms;
        t4.scale.set(s3[0].number, s3[1].number, s3[2].number), this[np].updateBoundingBox(), this[np].updateShadow(), this[op].arRenderer.onUpdateScene(), this[ip]();
      }
    }
    [sp]() {
      super[sp]();
      const { currentGLTF: t3 } = this[np];
      if (t3 != null) {
        const { correlatedSceneGraph: e3 } = t3;
        e3 != null && t3 !== this[Lx] && (this[Cx] = new Ax(e3, this[Px]()), this[Dx] = JSON.parse(JSON.stringify(e3.gltf))), "variants" in t3.userData && this.requestUpdate("variantName");
      }
      this[Lx] = t3, this.dispatchEvent(new CustomEvent("scene-graph-ready"));
    }
    async exportScene(t3) {
      const e3 = this[np];
      return new Promise(async (n3) => {
        const i3 = { binary: true, onlyVisible: true, maxTextureSize: 1 / 0, forcePowerOfTwoTextures: false, includeCustomExtensions: false, embedImages: true };
        Object.assign(i3, t3), i3.animations = e3.animations, i3.truncateDrawRange = true;
        const r3 = e3.shadow;
        let s3 = false;
        r3 != null && (s3 = r3.visible, r3.visible = false), await this[Cx][vx]();
        new fv().register((t4) => new $v(t4)).parse(e3.modelContainer.children[0], (t4) => n3(new Blob([i3.binary ? t4 : JSON.stringify(t4)], { type: i3.binary ? "application/octet-stream" : "application/json" })), i3), r3 != null && (r3.visible = s3);
      });
    }
    materialFromPoint(t3, e3) {
      const n3 = this[np], i3 = n3.getNDC(t3, e3);
      return n3.raycaster.setFromCamera(i3, n3.getCamera()), this[Cx][wx](n3.raycaster);
    }
  }
  return Rx([Z({ type: String, attribute: "variant-name" })], s2.prototype, "variantName", void 0), Rx([Z({ type: String, attribute: "orientation" })], s2.prototype, "orientation", void 0), Rx([Z({ type: String, attribute: "scale" })], s2.prototype, "scale", void 0), s2;
})(((t2) => {
  var e2, n2, i2;
  class r2 extends t2 {
    constructor() {
      super(...arguments), this.autoRotate = false, this.autoRotateDelay = 3e3, this.rotationPerSecond = "auto", this[e2] = performance.now(), this[n2] = 0, this[i2] = (t3) => {
        this.autoRotate && t3.detail.source === "user-interaction" && (this[Ux] = performance.now());
      };
    }
    connectedCallback() {
      super.connectedCallback(), this.addEventListener("camera-change", this[Bx]), this[Ux] = performance.now();
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this.removeEventListener("camera-change", this[Bx]), this[Ux] = performance.now();
    }
    updated(t3) {
      super.updated(t3), t3.has("autoRotate") && (this[Ux] = performance.now());
    }
    [(e2 = Ux, n2 = kx, zx)](t3) {
      this[kx] = t3[0];
    }
    [rp](t3, e3) {
      if (super[rp](t3, e3), !this.autoRotate || !this[pp]() || this[op].isPresenting)
        return;
      const n3 = Math.min(e3, t3 - this[Ux] - this.autoRotateDelay);
      n3 > 0 && (this[np].yaw = this.turntableRotation + this[kx] * n3 * 1e-3);
    }
    get turntableRotation() {
      return this[np].yaw;
    }
    resetTurntableRotation(t3 = 0) {
      this[np].yaw = t3;
    }
  }
  return i2 = Bx, Nx([Z({ type: Boolean, attribute: "auto-rotate" })], r2.prototype, "autoRotate", void 0), Nx([Z({ type: Number, attribute: "auto-rotate-delay" })], r2.prototype, "autoRotateDelay", void 0), Nx([Ff({ intrinsics: Ox, updateHandler: zx }), Z({ type: String, attribute: "rotation-per-second" })], r2.prototype, "rotationPerSecond", void 0), r2;
})(((t2) => {
  var e2, n2, i2;
  class r2 extends t2 {
    constructor() {
      super(...arguments), this.environmentImage = null, this.skyboxImage = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.exposure = 1, this[e2] = null, this[n2] = null, this[i2] = (t3) => {
        t3.element === this && this[Iu]();
      };
    }
    connectedCallback() {
      super.connectedCallback(), this[op].loader.addEventListener("preload", this[Nu]);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this[op].loader.removeEventListener("preload", this[Nu]);
    }
    updated(t3) {
      super.updated(t3), t3.has("shadowIntensity") && (this[np].setShadowIntensity(0.1 * this.shadowIntensity), this[ip]()), t3.has("shadowSoftness") && (this[np].setShadowSoftness(this.shadowSoftness), this[ip]()), t3.has("exposure") && (this[np].exposure = this.exposure, this[ip]()), (t3.has("environmentImage") || t3.has("skyboxImage")) && this[up]() && this[Iu]();
    }
    [(e2 = Cu, n2 = Du, i2 = Nu, sp)]() {
      super[sp](), this[Cu] != null && this[Pu](this[Cu]);
    }
    async [Iu]() {
      const { skyboxImage: t3, environmentImage: e3 } = this;
      this[Du] != null && (this[Du](), this[Du] = null);
      const { textureUtils: n3 } = this[op];
      if (n3 != null)
        try {
          const { environmentMap: i3, skybox: r3 } = await new Promise(async (i4, r4) => {
            const s2 = n3.generateEnvironmentMapAndSkybox($h(t3), e3, { progressTracker: this[lp] });
            this[Du] = () => r4(s2), i4(await s2);
          });
          this[np].background = r3 != null ? r3.name === i3.name ? i3 : r3 : null, this[Pu](i3), this[np].dispatchEvent({ type: "envmap-update" });
        } catch (t4) {
          if (t4 instanceof Error)
            throw this[Pu](null), t4;
        }
    }
    [Pu](t3) {
      this[np].environment !== t3 && (this[Cu] = t3, this[np].environment = this[Cu], this.dispatchEvent(new CustomEvent("environment-change")), this[ip]());
    }
  }
  return Lu([Z({ type: String, attribute: "environment-image" })], r2.prototype, "environmentImage", void 0), Lu([Z({ type: String, attribute: "skybox-image" })], r2.prototype, "skyboxImage", void 0), Lu([Z({ type: Number, attribute: "shadow-intensity" })], r2.prototype, "shadowIntensity", void 0), Lu([Z({ type: Number, attribute: "shadow-softness" })], r2.prototype, "shadowSoftness", void 0), Lu([Z({ type: Number })], r2.prototype, "exposure", void 0), r2;
})(((t2) => {
  var e2, n2, i2, r2, s2, a2, o2, l2, c2, h2, u2, d2, p2, m2, f2, g2;
  class v2 extends t2 {
    constructor() {
      super(...arguments), this.cameraControls = false, this.cameraOrbit = "0deg 75deg 105%", this.cameraTarget = "auto auto auto", this.fieldOfView = "auto", this.minCameraOrbit = "auto", this.maxCameraOrbit = "auto", this.minFieldOfView = "auto", this.maxFieldOfView = "auto", this.interactionPromptThreshold = 3e3, this.interactionPromptStyle = ig, this.interactionPrompt = eg, this.interactionPolicy = rg, this.orbitSensitivity = 1, this.touchAction = sg, this.disableZoom = false, this.interpolationDecay = 50, this.bounds = "legacy", this[e2] = this.shadowRoot.querySelector(".interaction-prompt"), this[n2] = this.shadowRoot.querySelector(".interaction-prompt > .animated-container"), this[i2] = 1 / 0, this[r2] = 0, this[s2] = 1 / 0, this[a2] = false, this[o2] = false, this[l2] = new qf(this[np].camera, this[tp]), this[c2] = new Yl(), this[h2] = false, this[u2] = false, this[d2] = false, this[p2] = () => {
        const t3 = this[tp];
        isFinite(this[Pg]) || (this[Pg] = performance.now());
        const e3 = this[Zd];
        t3.getAttribute("aria-label") !== e3 && t3.setAttribute("aria-label", e3), this.interactionPrompt !== ng || this[Rg] || (this[Ag] = true);
      }, this[m2] = () => {
        this.interactionPrompt === ng && (this[Ag] = false, this[yg].classList.remove("visible"), this[Lg] = 1 / 0, this[Pg] = 1 / 0);
      }, this[f2] = ({ source: t3 }) => {
        this[wg](), this[ip](), t3 === Wf && (this[Rg] = true, this[bg]()), this.dispatchEvent(new CustomEvent("camera-change", { detail: { source: t3 } }));
      }, this[g2] = (t3) => {
        t3.type === "pointer-change-start" ? this[Qd].classList.add("pointer-tumbling") : this[Qd].classList.remove("pointer-tumbling");
      };
    }
    getCameraOrbit() {
      const { theta: t3, phi: e3, radius: n3 } = this[Ig];
      return { theta: t3, phi: e3, radius: n3, toString() {
        return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
      } };
    }
    getCameraTarget() {
      return mp(this[op].isPresenting ? this[op].arRenderer.target : this[np].getTarget());
    }
    getFieldOfView() {
      return this[vg].getFieldOfView();
    }
    getMinimumFieldOfView() {
      return this[vg].options.minimumFieldOfView;
    }
    getMaximumFieldOfView() {
      return this[vg].options.maximumFieldOfView;
    }
    getIdealAspect() {
      return this[np].idealAspect;
    }
    jumpCameraToGoal() {
      this[Dg] = true, this.requestUpdate(Dg, false);
    }
    resetInteractionPrompt() {
      this[Cg] = 0, this[Lg] = 1 / 0, this[Rg] = false, this[Ag] = this.interactionPrompt === eg && this.cameraControls;
    }
    zoom(t3) {
      const e3 = new WheelEvent("wheel", { deltaY: -30 * t3 });
      this[tp].dispatchEvent(e3);
    }
    connectedCallback() {
      super.connectedCallback(), this[vg].addEventListener("change", this[Tg]), this[vg].addEventListener("pointer-change-start", this[Eg]), this[vg].addEventListener("pointer-change-end", this[Eg]);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this[vg].removeEventListener("change", this[Tg]), this[vg].removeEventListener("pointer-change-start", this[Eg]), this[vg].removeEventListener("pointer-change-end", this[Eg]);
    }
    updated(t3) {
      super.updated(t3);
      const e3 = this[vg], n3 = this[tp];
      if (t3.has("cameraControls") && (this.cameraControls ? (e3.enableInteraction(), this.interactionPrompt === eg && (this[Ag] = true), n3.addEventListener("focus", this[Sg]), n3.addEventListener("blur", this[Mg])) : (n3.removeEventListener("focus", this[Sg]), n3.removeEventListener("blur", this[Mg]), e3.disableInteraction(), this[bg]())), t3.has("disableZoom") && (e3.disableZoom = this.disableZoom), t3.has("bounds") && (this[np].tightBounds = this.bounds === "tight"), (t3.has("interactionPrompt") || t3.has("cameraControls") || t3.has("src")) && (this.interactionPrompt === eg && this.cameraControls && !this[Rg] ? this[Ag] = true : this[bg]()), t3.has("interactionPromptStyle") && this[yg].classList.toggle("wiggle", this.interactionPromptStyle === ig), t3.has("interactionPolicy")) {
        const t4 = this.interactionPolicy;
        e3.applyOptions({ interactionPolicy: t4 });
      }
      if (t3.has("touchAction")) {
        const t4 = this.touchAction;
        e3.applyOptions({ touchAction: t4 }), e3.updateTouchActionStyle();
      }
      t3.has("orbitSensitivity") && (e3.sensitivity = this.orbitSensitivity), t3.has("interpolationDecay") && (e3.setDamperDecayTime(this.interpolationDecay), this[np].setTargetDamperDecayTime(this.interpolationDecay)), this[Dg] === true && Promise.resolve().then(() => {
        e3.jumpToGoal(), this[np].jumpToGoal(), this[Dg] = false;
      });
    }
    async updateFraming() {
      const t3 = this[np], e3 = t3.adjustedFoV(t3.framedFoVDeg);
      await t3.updateFraming();
      const n3 = t3.adjustedFoV(t3.framedFoVDeg), i3 = this[vg].getFieldOfView() / e3;
      this[vg].setFieldOfView(n3 * i3), this[Fg] = true, this.requestUpdate("maxFieldOfView"), this.requestUpdate("fieldOfView"), this.requestUpdate("minCameraOrbit"), this.requestUpdate("maxCameraOrbit"), await this.requestUpdate("cameraOrbit");
    }
    [(e2 = yg, n2 = xg, i2 = Pg, r2 = Cg, s2 = Lg, a2 = Rg, o2 = Ag, l2 = vg, c2 = Ig, h2 = Dg, u2 = Ng, d2 = Fg, Ug)](t3) {
      const e3 = this[np];
      e3.framedFoVDeg = 180 * t3[0] / Math.PI, this[vg].setFieldOfView(e3.adjustedFoV(e3.framedFoVDeg));
    }
    [Og](t3) {
      if (this[Fg]) {
        const { theta: e3, phi: n3 } = this.getCameraOrbit();
        t3[0] = e3, t3[1] = n3, this[Fg] = false;
      }
      this[vg].setOrbit(t3[0], t3[1], t3[2]);
    }
    [zg](t3) {
      this[vg].applyOptions({ minimumAzimuthalAngle: t3[0], minimumPolarAngle: t3[1], minimumRadius: t3[2] }), this.jumpCameraToGoal();
    }
    [Bg](t3) {
      this[vg].applyOptions({ maximumAzimuthalAngle: t3[0], maximumPolarAngle: t3[1], maximumRadius: t3[2] }), this[_g](t3[2]), this.jumpCameraToGoal();
    }
    [Hg](t3) {
      this[vg].applyOptions({ minimumFieldOfView: 180 * t3[0] / Math.PI }), this.jumpCameraToGoal();
    }
    [Vg](t3) {
      const e3 = this[np].adjustedFoV(180 * t3[0] / Math.PI);
      this[vg].applyOptions({ maximumFieldOfView: e3 }), this.jumpCameraToGoal();
    }
    [kg](t3) {
      const [e3, n3, i3] = t3;
      this[np].setTarget(e3, n3, i3), this[op].arRenderer.updateTarget();
    }
    [rp](t3, e3) {
      if (super[rp](t3, e3), this[op].isPresenting || !this[pp]())
        return;
      const n3 = performance.now();
      if (this[Ag]) {
        const t4 = this.interactionPrompt === eg ? this[Jd] : this[Pg];
        this.loaded && n3 > t4 + this.interactionPromptThreshold && (this[tp].setAttribute("aria-label", "Use mouse, touch or arrow keys to control the camera!"), this[Ag] = false, this[Lg] = n3, this[yg].classList.add("visible"));
      }
      if (isFinite(this[Lg]) && this.interactionPromptStyle === ig) {
        const t4 = this[np], e4 = (n3 - this[Lg]) / 5e3 % 1, i3 = $f(e4), r3 = Kf(e4);
        if (this[xg].style.opacity = `${r3}`, i3 !== this[Cg]) {
          const e5 = i3 * t4.width * 0.05, n4 = (i3 - this[Cg]) * Math.PI / 16;
          this[xg].style.transform = `translateX(${e5}px)`, this[vg].adjustOrbit(n4, 0, 0), this[Cg] = i3;
        }
      }
      this[vg].update(t3, e3), this[np].updateTarget(e3);
    }
    [bg]() {
      this[Ag] = false, this[yg].classList.remove("visible"), this[Lg] = 1 / 0;
    }
    [_g](t3) {
      const e3 = 2 * Math.max(this[np].boundingRadius, t3);
      this[vg].updateNearFar(0, e3);
    }
    [wg]() {
      const { theta: t3, phi: e3 } = this[Ig], { theta: n3, phi: i3 } = this[vg].getCameraSpherical(this[Ig]), r3 = this.getRootNode();
      if (r3 != null && r3.activeElement === this) {
        const r4 = (4 + Math.floor((t3 % gg + fg) / pg)) % 4, s3 = (4 + Math.floor((n3 % gg + fg) / pg)) % 4, a3 = Math.floor(e3 / mg), o3 = Math.floor(i3 / mg);
        if (s3 !== r4 || o3 !== a3) {
          const t4 = `View from stage ${tg[o3]}${Qf[s3]}`;
          this[tp].setAttribute("aria-label", t4);
        }
      }
    }
    async [ap](t3) {
      const e3 = this[vg], n3 = this[np], i3 = n3.adjustedFoV(n3.framedFoVDeg);
      super[ap](t3);
      const r3 = n3.adjustedFoV(n3.framedFoVDeg), s3 = e3.getFieldOfView() / i3;
      e3.updateAspect(this[np].aspect), await this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this[vg].setFieldOfView(r3 * s3), this.jumpCameraToGoal();
    }
    [sp]() {
      super[sp](), this[Ng] ? this[Fg] = true : this[Ng] = true, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal();
    }
  }
  return p2 = Sg, m2 = Mg, f2 = Tg, g2 = Eg, Jf([Z({ type: Boolean, attribute: "camera-controls" })], v2.prototype, "cameraControls", void 0), Jf([Ff({ intrinsics: cg, observeEffects: true, updateHandler: Og }), Z({ type: String, attribute: "camera-orbit", hasChanged: () => true })], v2.prototype, "cameraOrbit", void 0), Jf([Ff({ intrinsics: dg, observeEffects: true, updateHandler: kg }), Z({ type: String, attribute: "camera-target", hasChanged: () => true })], v2.prototype, "cameraTarget", void 0), Jf([Ff({ intrinsics: ag, observeEffects: true, updateHandler: Ug }), Z({ type: String, attribute: "field-of-view", hasChanged: () => true })], v2.prototype, "fieldOfView", void 0), Jf([Ff({ intrinsics: hg, updateHandler: zg }), Z({ type: String, attribute: "min-camera-orbit", hasChanged: () => true })], v2.prototype, "minCameraOrbit", void 0), Jf([Ff({ intrinsics: ug, updateHandler: Bg }), Z({ type: String, attribute: "max-camera-orbit", hasChanged: () => true })], v2.prototype, "maxCameraOrbit", void 0), Jf([Ff({ intrinsics: og, updateHandler: Hg }), Z({ type: String, attribute: "min-field-of-view", hasChanged: () => true })], v2.prototype, "minFieldOfView", void 0), Jf([Ff({ intrinsics: lg, updateHandler: Vg }), Z({ type: String, attribute: "max-field-of-view", hasChanged: () => true })], v2.prototype, "maxFieldOfView", void 0), Jf([Z({ type: Number, attribute: "interaction-prompt-threshold" })], v2.prototype, "interactionPromptThreshold", void 0), Jf([Z({ type: String, attribute: "interaction-prompt-style" })], v2.prototype, "interactionPromptStyle", void 0), Jf([Z({ type: String, attribute: "interaction-prompt" })], v2.prototype, "interactionPrompt", void 0), Jf([Z({ type: String, attribute: "interaction-policy" })], v2.prototype, "interactionPolicy", void 0), Jf([Z({ type: Number, attribute: "orbit-sensitivity" })], v2.prototype, "orbitSensitivity", void 0), Jf([Z({ type: String, attribute: "touch-action" })], v2.prototype, "touchAction", void 0), Jf([Z({ type: Boolean, attribute: "disable-zoom" })], v2.prototype, "disableZoom", void 0), Jf([Z({ type: Number, attribute: "interpolation-decay" })], v2.prototype, "interpolationDecay", void 0), Jf([Z({ type: String, attribute: "bounds" })], v2.prototype, "bounds", void 0), v2;
})(((t2) => {
  var e2, n2, i2, r2, s2, a2, o2, l2, c2, h2;
  class u2 extends t2 {
    constructor() {
      super(...arguments), this.ar = false, this.arScale = "auto", this.arPlacement = "floor", this.arModes = "webxr scene-viewer", this.iosSrc = null, this.xrEnvironment = false, this[e2] = false, this[n2] = this.shadowRoot.querySelector(".ar-button"), this[i2] = document.createElement("a"), this[r2] = /* @__PURE__ */ new Set(), this[s2] = Fm, this[a2] = false, this[o2] = (t3) => {
        t3.preventDefault(), this.activateAR();
      }, this[l2] = ({ status: t3 }) => {
        t3 !== Hu && this[op].arRenderer.presentedScene !== this[np] || (this.setAttribute("ar-status", t3), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: t3 } })), t3 === Hu ? this.removeAttribute("ar-tracking") : t3 === Vu && this.setAttribute("ar-tracking", ju));
      }, this[c2] = ({ status: t3 }) => {
        this.setAttribute("ar-tracking", t3), this.dispatchEvent(new CustomEvent("ar-tracking", { detail: { status: t3 } }));
      }, this[h2] = (t3) => {
        t3.data == "_apple_ar_quicklook_button_tapped" && this.dispatchEvent(new CustomEvent("quick-look-button-tapped"));
      };
    }
    get canActivateAR() {
      return this[Hm] !== Fm;
    }
    connectedCallback() {
      super.connectedCallback(), this[op].arRenderer.addEventListener("status", this[qm]), this.setAttribute("ar-status", Hu), this[op].arRenderer.addEventListener("tracking", this[Xm]), this[Gm].addEventListener("message", this[Ym]);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this[op].arRenderer.removeEventListener("status", this[qm]), this[op].arRenderer.removeEventListener("tracking", this[Xm]), this[Gm].removeEventListener("message", this[Ym]);
    }
    async update(t3) {
      super.update(t3), t3.has("arScale") && (this[np].canScale = this.arScale !== "fixed"), t3.has("arPlacement") && (this[np].updateShadow(), this[ip]()), (t3.has("ar") || t3.has("arModes") || t3.has("src") || t3.has("iosSrc")) && (t3.has("arModes") && (this[Vm] = Cm(this.arModes)), this[Zm]());
    }
    async activateAR() {
      switch (this[Hm]) {
        case Im:
          this[zm]();
          break;
        case Nm:
          await this[Um]();
          break;
        case Dm:
          this[km]();
          break;
        default:
          console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities");
      }
    }
    async [(e2 = Bm, n2 = Om, i2 = Gm, r2 = Vm, s2 = Hm, a2 = Wm, o2 = jm, l2 = qm, c2 = Xm, h2 = Ym, Zm)]() {
      if (this[Hm] = Fm, this.ar) {
        if (this.src != null)
          for (const t3 of this[Vm]) {
            if (t3 === "webxr" && ac && !Rm && await this[op].arRenderer.supportsPresentation()) {
              this[Hm] = Nm;
              break;
            }
            if (t3 === "scene-viewer" && dc && !Lm) {
              this[Hm] = Dm;
              break;
            }
            if (t3 === "quick-look" && cc) {
              this[Hm] = Im;
              break;
            }
          }
        !this.canActivateAR && this.iosSrc != null && cc && (this[Hm] = Im);
      }
      if (this.canActivateAR)
        this[Om].classList.add("enabled"), this[Om].addEventListener("click", this[jm]);
      else if (this[Om].classList.contains("enabled")) {
        this[Om].removeEventListener("click", this[jm]), this[Om].classList.remove("enabled");
        const t3 = Wu;
        this.setAttribute("ar-status", t3), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: t3 } }));
      }
    }
    async [Um]() {
      console.log("Attempting to present in AR with WebXR..."), await this[Jm]();
      try {
        this[Om].removeEventListener("click", this[jm]);
        const { arRenderer: t3 } = this[op];
        t3.placeOnWall = this.arPlacement === "wall", await t3.present(this[np], this.xrEnvironment);
      } catch (t3) {
        console.warn("Error while trying to present in AR with WebXR"), console.error(t3), await this[op].arRenderer.stopPresenting(), Rm = true, console.warn("Falling back to next ar-mode"), await this[Zm](), this.activateAR();
      } finally {
        this[Zm]();
      }
    }
    async [Jm]() {
      this.loaded || (this[Wm] = true, this[$d](), await ((t3, e3, n3 = null) => new Promise((i3) => {
        t3.addEventListener(e3, function r3(s3) {
          n3 && !n3(s3) || (i3(s3), t3.removeEventListener(e3, r3));
        });
      }))(this, "load"), this[Wm] = false);
    }
    [up]() {
      return super[up]() || this[Wm];
    }
    [km]() {
      const t3 = self.location.toString(), e3 = new URL(t3), n3 = new URL(this.src, t3), i3 = new URLSearchParams(n3.search);
      if (e3.hash = "#model-viewer-no-ar-fallback", i3.set("mode", "ar_preferred"), i3.has("disable_occlusion") || i3.set("disable_occlusion", "true"), this.arScale === "fixed" && i3.set("resizable", "false"), this.arPlacement === "wall" && i3.set("enable_vertical_placement", "true"), i3.has("sound")) {
        const e4 = new URL(i3.get("sound"), t3);
        i3.set("sound", e4.toString());
      }
      if (i3.has("link")) {
        const e4 = new URL(i3.get("link"), t3);
        i3.set("link", e4.toString());
      }
      const r3 = `intent://arvr.google.com/scene-viewer/1.0?${i3.toString() + "&file=" + encodeURIComponent(n3.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(e3.toString())};end;`;
      self.addEventListener("hashchange", () => {
        self.location.hash === "#model-viewer-no-ar-fallback" && (Lm = true, self.history.back(), console.warn("Error while trying to present in AR with Scene Viewer"), console.warn("Falling back to next ar-mode"), this[Zm]());
      }, { once: true }), this[Gm].setAttribute("href", r3), console.log("Attempting to present in AR with Scene Viewer..."), this[Gm].click();
    }
    async [zm]() {
      const t3 = !this.iosSrc;
      this[Om].classList.remove("enabled");
      const e3 = t3 ? await this.prepareUSDZ() : this.iosSrc, n3 = new URL(e3, self.location.toString());
      this.arScale === "fixed" && (n3.hash && (n3.hash += "&"), n3.hash += "allowsContentScaling=0");
      const i3 = this[Gm];
      i3.setAttribute("rel", "ar");
      const r3 = document.createElement("img");
      i3.appendChild(r3), i3.setAttribute("href", n3.toString()), t3 && i3.setAttribute("download", "model.usdz"), console.log("Attempting to present in AR with Quick Look..."), i3.click(), i3.removeChild(r3), t3 && URL.revokeObjectURL(e3), this[Om].classList.add("enabled");
    }
    async prepareUSDZ() {
      const t3 = this[lp].beginActivity();
      await this[Jm]();
      const e3 = this[np], n3 = e3.shadow;
      let i3 = false;
      n3 != null && (i3 = n3.visible, n3.visible = false), t3(0.2);
      const r3 = new xm(), s3 = await r3.parse(e3.modelContainer), a3 = new Blob([s3], { type: "model/vnd.usdz+zip" }), o3 = URL.createObjectURL(a3);
      return t3(1), n3 != null && (n3.visible = i3), o3;
    }
  }
  return Am([Z({ type: Boolean, attribute: "ar" })], u2.prototype, "ar", void 0), Am([Z({ type: String, attribute: "ar-scale" })], u2.prototype, "arScale", void 0), Am([Z({ type: String, attribute: "ar-placement" })], u2.prototype, "arPlacement", void 0), Am([Z({ type: String, attribute: "ar-modes" })], u2.prototype, "arModes", void 0), Am([Z({ type: String, attribute: "ios-src" })], u2.prototype, "iosSrc", void 0), Am([Z({ type: Boolean, attribute: "xr-environment" })], u2.prototype, "xrEnvironment", void 0), u2;
})(((t2) => {
  var e2, n2, i2, r2, s2, a2, o2, l2, c2, h2, u2, d2, p2, m2;
  class f2 extends t2 {
    constructor(...t3) {
      super(...t3), this.poster = null, this.reveal = Yg, this.loading = Jg, this.generateSchema = false, this.seamlessPoster = false, this[e2] = false, this[n2] = false, this[i2] = 0, this[r2] = null, this[s2] = this.shadowRoot.querySelector(".slot.poster"), this[a2] = this.shadowRoot.querySelector("#default-poster"), this[o2] = this.shadowRoot.querySelector("#default-progress-bar > .bar"), this[l2] = this.shadowRoot.querySelector("#default-progress-bar > .mask"), this[c2] = this[iv].getAttribute("aria-label"), this[h2] = ((t4, e3) => {
        let n3 = null;
        const i3 = (...i4) => {
          n3 == null && (t4(...i4), n3 = self.setTimeout(() => n3 = null, e3));
        };
        return i3.flush = () => {
          n3 != null && (self.clearTimeout(n3), n3 = null);
        }, i3;
      })((t4) => {
        const e3 = this[tv].parentNode;
        requestAnimationFrame(() => {
          this[ev].style.opacity = "" + 0.2 * (1 - t4), this[tv].style.transform = `scaleX(${t4})`, t4 === 0 && (e3.removeChild(this[tv]), e3.appendChild(this[tv])), t4 === 1 ? this[tv].classList.add("hide") : this[tv].classList.remove("hide");
        });
      }, 100), this[u2] = () => {
        this.reveal !== Zg && this.reveal !== Yg && this.dismissPoster();
      }, this[d2] = (t4) => {
        if (this.reveal !== Zg)
          switch (t4.keyCode) {
            case 32:
            case 13:
              this.dismissPoster();
          }
      }, this[p2] = (t4) => {
        const e3 = t4.detail.totalProgress;
        this[lv] = Math.max(e3, this[lv]), e3 === 1 && (this[ov].flush(), !this[dp]() || this[rv] == null && this.reveal !== Yg || this[sv]()), this[ov](e3), this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: e3 } }));
      }, this[m2] = () => {
        this[cv] = true;
        const t4 = this.getRootNode();
        t4 && t4.activeElement === this && this[tp].focus();
        const e3 = this[iv];
        e3.setAttribute("aria-hidden", "true"), e3.tabIndex = -1, this.dispatchEvent(new CustomEvent("poster-dismissed"));
      };
      const f3 = self.ModelViewerElement || {}, g2 = f3.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.4.1/";
      Gh.setDRACODecoderLocation(g2);
      const v2 = f3.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
      Gh.setKTX2TranscoderLocation(v2), f3.meshoptDecoderLocation && Gh.setMeshoptDecoderLocation(f3.meshoptDecoderLocation);
    }
    static set dracoDecoderLocation(t3) {
      Gh.setDRACODecoderLocation(t3);
    }
    static get dracoDecoderLocation() {
      return Gh.getDRACODecoderLocation();
    }
    static set ktx2TranscoderLocation(t3) {
      Gh.setKTX2TranscoderLocation(t3);
    }
    static get ktx2TranscoderLocation() {
      return Gh.getKTX2TranscoderLocation();
    }
    static set meshoptDecoderLocation(t3) {
      Gh.setMeshoptDecoderLocation(t3);
    }
    static get meshoptDecoderLocation() {
      return Gh.getMeshoptDecoderLocation();
    }
    static mapURLs(t3) {
      Td.singleton.loader[Bh].manager.setURLModifier(t3);
    }
    dismissPoster() {
      this[dp]() ? this[sv]() : (this[rv] = Kg, this[$d]());
    }
    showPoster() {
      const t3 = this[nv], e3 = this[iv];
      e3.removeAttribute("tabindex"), e3.removeAttribute("aria-hidden"), t3.classList.add("show");
      const n3 = this.modelIsVisible;
      this[av] = false, this[Yd](n3), this[cv] = false;
    }
    getDimensions() {
      return mp(this[np].size);
    }
    connectedCallback() {
      super.connectedCallback(), this[nv].addEventListener("click", this[dv]), this[nv].addEventListener("keydown", this[pv]), this[lp].addEventListener("progress", this[mv]), Qg.registerInstance(this);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this[nv].removeEventListener("click", this[dv]), this[nv].removeEventListener("keydown", this[pv]), this[lp].removeEventListener("progress", this[mv]), Qg.unregisterInstance(this);
    }
    async updated(t3) {
      super.updated(t3), t3.has("poster") && this.poster != null && (this[iv].style.backgroundImage = `url(${this.poster})`), t3.has("alt") && this[iv].setAttribute("aria-label", `${this[Zd]}. ${this[uv]}`), (t3.has("reveal") || t3.has("loading")) && this[$d](), t3.has("generateSchema") && (this.generateSchema === true ? this[np].updateSchema(this.src) : this[np].updateSchema(null)), t3.has("seamlessPoster") && (this.seamlessPoster === true ? this[nv].classList.add("quick") : this[nv].classList.remove("quick"));
    }
    [(e2 = av, n2 = cv, i2 = lv, r2 = rv, s2 = nv, a2 = iv, o2 = tv, l2 = ev, c2 = uv, h2 = ov, u2 = dv, d2 = pv, p2 = mv, up)]() {
      return !!this.src && (this[rv] != null || this.loading === $g || this.reveal === Yg && this[Xd]);
    }
    [dp]() {
      const { src: t3 } = this;
      return !!t3 && super[dp]() && this[lv] === 1;
    }
    [(m2 = hv, sv)]() {
      this[rv] = null;
      const t3 = this[nv];
      if (t3.classList.contains("show")) {
        const e3 = this.modelIsVisible;
        this[av] = true, this[Yd](e3), requestAnimationFrame(() => {
          t3.classList.remove("show"), this.seamlessPoster === true ? this[hv]() : t3.addEventListener("transitionend", this[hv], { once: true });
        });
      } else
        this[cv] = true;
    }
    [hp]() {
      return super[hp]() && this[av];
    }
    [pp]() {
      return super[pp]() && this[cv];
    }
    async [$d]() {
      this[lv] = 0, this.generateSchema === true && this[np].updateSchema(this.src), this[np].currentGLTF != null && this.src != null && this[up]() || this.showPoster(), await super[$d]();
    }
  }
  return Xg([Z({ type: String })], f2.prototype, "poster", void 0), Xg([Z({ type: String })], f2.prototype, "reveal", void 0), Xg([Z({ type: String })], f2.prototype, "loading", void 0), Xg([Z({ type: Boolean, attribute: "generate-schema" })], f2.prototype, "generateSchema", void 0), Xg([Z({ type: Boolean, attribute: "seamless-poster" })], f2.prototype, "seamlessPoster", void 0), f2;
})(((t2) => {
  var e2;
  class n2 extends t2 {
    constructor(...t3) {
      super(t3), this.autoplay = false, this.animationName = void 0, this.animationCrossfadeDuration = 300, this[e2] = true, this[np].subscribeMixerEvent("loop", (t4) => {
        const e3 = t4.action._loopCount;
        this.dispatchEvent(new CustomEvent("loop", { detail: { count: e3 } }));
      }), this[np].subscribeMixerEvent("finished", () => {
        this.currentTime = 0, this[xp] = true, this[op].threeRenderer.shadowMap.autoUpdate = false, this[yp]({ repetitions: 1 / 0, pingpong: false }), this.dispatchEvent(new CustomEvent("finished"));
      });
    }
    get availableAnimations() {
      return this.loaded ? this[np].animationNames : [];
    }
    get duration() {
      return this[np].duration;
    }
    get paused() {
      return this[xp];
    }
    get currentTime() {
      return this[np].animationTime;
    }
    set currentTime(t3) {
      this[np].animationTime = t3, this[op].threeRenderer.shadowMap.needsUpdate = true, this[ip]();
    }
    pause() {
      this[xp] || (this[xp] = true, this[op].threeRenderer.shadowMap.autoUpdate = false, this.dispatchEvent(new CustomEvent("pause")));
    }
    play(t3 = bp) {
      this.availableAnimations.length > 0 && (this[xp] = false, this[op].threeRenderer.shadowMap.autoUpdate = true, this[yp](t3), this.dispatchEvent(new CustomEvent("play")));
    }
    [(e2 = xp, sp)]() {
      super[sp](), this[xp] = true, this.autoplay && (this[yp]({ repetitions: 1 / 0, pingpong: false }), this.play());
    }
    [rp](t3, e3) {
      super[rp](t3, e3), this[xp] || !this[pp]() && !this[op].isPresenting || (this[np].updateAnimation(e3 / 1e3), this[ip]());
    }
    updated(t3) {
      super.updated(t3), t3.has("autoplay") && this.autoplay && this.play(), t3.has("animationName") && this[yp]({ repetitions: 1 / 0, pingpong: false });
    }
    async [$d]() {
      return this[np].stopAnimation(), super[$d]();
    }
    [yp](t3) {
      var e3;
      const n3 = (e3 = t3.repetitions) !== null && e3 !== void 0 ? e3 : 1 / 0, i2 = t3.pingpong ? 2202 : n3 === 1 ? 2200 : 2201;
      this[np].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3, i2, n3), this[xp] && (this[np].updateAnimation(0), this[ip]());
    }
  }
  return vp([Z({ type: Boolean })], n2.prototype, "autoplay", void 0), vp([Z({ type: String, attribute: "animation-name" })], n2.prototype, "animationName", void 0), vp([Z({ type: Number, attribute: "animation-crossfade-duration" })], n2.prototype, "animationCrossfadeDuration", void 0), n2;
})(((t2) => {
  var e2;
  const n2 = Symbol("endPolyfillCoordination");
  return e2 = n2, class extends t2 {
    constructor() {
      super(...arguments), this[e2] = null;
    }
    connectedCallback() {
      super.connectedCallback && super.connectedCallback(), this[n2] == null && (this[n2] = ((t3) => {
        if (t3.shadowRoot == null || t3.hasAttribute("data-js-focus-visible"))
          return () => {
          };
        if (!self.applyFocusVisiblePolyfill) {
          const e3 = () => {
            self.applyFocusVisiblePolyfill(t3.shadowRoot);
          };
          return self.addEventListener("focus-visible-polyfill-ready", e3, { once: true }), () => {
            self.removeEventListener("focus-visible-polyfill-ready", e3);
          };
        }
        return self.applyFocusVisiblePolyfill(t3.shadowRoot), () => {
        };
      })(this));
    }
    disconnectedCallback() {
      super.disconnectedCallback && super.disconnectedCallback(), this[n2] != null && (this[n2](), this[n2] = null);
    }
  };
})(gp)))))))));
customElements.define("model-viewer", Hx);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
let VrApp = class extends LitElement {
  render() {
    return html`
            <model-viewer
                style="height:100vh; width: 100%"
                alt="Neil Armstrong's Spacesuit from the Smithsonian Digitization Programs Office and National Air and Space Museum"
                src="src/assets/NeilArmstrong.glb"
                ar-modes="webxr scene-viewer quick-look"
                environment-image="src/assets/moon_1k.hdr"
                seamless-poster
                shadow-intensity="1"
                camera-controls
            ></model-viewer>
        `;
  }
};
VrApp = __decorateClass([
  customElement("vr-app")
], VrApp);
